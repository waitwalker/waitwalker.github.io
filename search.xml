<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ivar objc_property_t Protocol解读</title>
      <link href="/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="Ivar声明"><a href="#Ivar声明" class="headerlink" title="Ivar声明"></a>Ivar声明</h3><p>在objc-private.h文件中我们可以看到Ivar的声明结构:</p><pre><code>typedef struct ivar_t *Ivar;</code></pre><p>在objc-runtime-new.h中可以找到ivar_t的完整结构声明:</p><pre><code>// MARK: - 成员变量结构声明struct ivar_t {#if __x86_64__    // *offset was originally 64-bit on some x86_64 platforms.    // We read and write only 32 bits of it.    // Some metadata provides all 64 bits. This is harmless for unsigned    // little-endian values.    // Some code uses all 64 bits. class_addIvar() over-allocates the    // offset for their benefit.#endif    int32_t *offset;    const char *name;//成员变量名称    const char *type;//成员变量类型    // alignment is sometimes -1; use alignment() instead    uint32_t alignment_raw;    uint32_t size;    uint32_t alignment() const {        if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT;        return 1 &lt;&lt; alignment_raw;    }};</code></pre><h3 id="Ivar相关接口"><a href="#Ivar相关接口" class="headerlink" title="Ivar相关接口"></a>Ivar相关接口</h3><p>在runtime.h文件:</p><h4 id="修改一个类的成员变量的值"><a href="#修改一个类的成员变量的值" class="headerlink" title="修改一个类的成员变量的值"></a>修改一个类的成员变量的值</h4><pre><code>// MARK: - 修改一个类的成员变量的值/** * Changes the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to modify. * @param name A C string. Pass the name of the instance variable whose value you wish to modify. * @param value The new value for the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and *  name of the instance variable specified by \e name. * * @note Instance variables with known memory management (such as ARC strong and weak) *  use that memory management. Instance variables with unknown memory management *  are assigned as if they were unsafe_unretained. */OBJC_EXPORT Ivar _Nullableobject_setInstanceVariable(id _Nullable obj, const char * _Nonnull name,                           void * _Nullable value)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)    OBJC_ARC_UNAVAILABLE;</code></pre><p>其实现在objc-class.mm文件中,其内部调用了一个私有函数:</p><pre><code>// 修改一个类的成员变量的值Ivar object_setInstanceVariable(id obj, const char *name, void *value){    return _object_setInstanceVariable(obj, name, value, false);}// 修改一个成员变量的值static ALWAYS_INLINEIvar _object_setInstanceVariable(id obj, const char *name, void *value,                                 bool assumeStrong){    Ivar ivar = nil;    if (obj  &amp;&amp;  name  &amp;&amp;  !obj-&gt;isTaggedPointer()) {        // 首先根据成员变量名称从ivar_list中获取ivar        if ((ivar = _class_getVariable(obj-&gt;ISA(), name))) {            // 更新ivar的value            _object_setIvar(obj, ivar, (id)value, assumeStrong);        }    }    return ivar;}</code></pre><p>首先根据成员变量名称从ivar_list中获取ivar:</p><pre><code>// MARK: - 根据成员变量名称获取成员变量/************************************************************************ _class_getVariable* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar_class_getVariable(Class cls, const char *name){    mutex_locker_t lock(runtimeLock);    for ( ; cls; cls = cls-&gt;superclass) {        ivar_t *ivar = getIvar(cls, name);        if (ivar) {            return ivar;        }    }    return nil;}// MARK: - 根据成员变量名称获取成员变量/************************************************************************ getIvar* Look up an ivar by name.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/static ivar_t *getIvar(Class cls, const char *name){    runtimeLock.assertLocked();    const ivar_list_t *ivars;    assert(cls-&gt;isRealized());    if ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)) {        for (auto&amp; ivar : *ivars) {            if (!ivar.offset) continue;  // anonymous bitfield            // ivar.name may be nil for anonymous bitfields etc.            if (ivar.name  &amp;&amp;  0 == strcmp(name, ivar.name)) {                return &amp;ivar;            }        }    }    return nil;}</code></pre><p>获取到成员变量后,更新ivar的value:</p><pre><code>// MARK: - 更新ivar的值static ALWAYS_INLINEvoid _object_setIvar(id obj, Ivar ivar, id value, bool assumeStrong){    if (!obj  ||  !ivar  ||  obj-&gt;isTaggedPointer()) return;    ptrdiff_t offset;    objc_ivar_memory_management_t memoryManagement;    _class_lookUpIvar(obj-&gt;ISA(), ivar, offset, memoryManagement);    if (memoryManagement == objc_ivar_memoryUnknown) {        if (assumeStrong) memoryManagement = objc_ivar_memoryStrong;        else memoryManagement = objc_ivar_memoryUnretained;    }    id *location = (id *)((char *)obj + offset);    switch (memoryManagement) {    case objc_ivar_memoryWeak:       objc_storeWeak(location, value); break;    case objc_ivar_memoryStrong:     objc_storeStrong(location, value); break;    case objc_ivar_memoryUnretained: *location = value; break;    case objc_ivar_memoryUnknown:    _objc_fatal(&quot;impossible&quot;);    }}</code></pre><p>更新值的规则主要根据ivar的内存管理语义:</p><pre><code>/*  &quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars  &quot;Strong&quot; includes ARC __strong ivars  &quot;Weak&quot; includes ARC and new MRC __weak ivars  &quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars*/typedef enum {    objc_ivar_memoryUnknown,     // unknown / unknown    objc_ivar_memoryStrong,      // direct access / objc_storeStrong    objc_ivar_memoryWeak,        // objc_loadWeak[Retained] / objc_storeWeak    objc_ivar_memoryUnretained   // direct access / direct access} objc_ivar_memory_management_t;</code></pre><p>strong修饰的直接调用objc_storeStrong,weak调用objc_storeWeak,unretained修饰的直接赋值.这个在以后内存管理中细说.</p><h4 id="修改一个strong修饰的ivar的值"><a href="#修改一个strong修饰的ivar的值" class="headerlink" title="修改一个strong修饰的ivar的值"></a>修改一个strong修饰的ivar的值</h4><pre><code>// MARK: - 修改一个strong修饰的ivar的值/** * Changes the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to modify. * @param name A C string. Pass the name of the instance variable whose value you wish to modify. * @param value The new value for the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and *  name of the instance variable specified by \e name. * * @note Instance variables with known memory management (such as ARC strong and weak) *  use that memory management. Instance variables with unknown memory management *  are assigned as if they were strong. */OBJC_EXPORT Ivar _Nullableobject_setInstanceVariableWithStrongDefault(id _Nullable obj,                                            const char * _Nonnull name,                                            void * _Nullable value)    OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0)    OBJC_ARC_UNAVAILABLE;</code></pre><p>其过程与上一个类似.</p><h4 id="获取一个类的实例的成员变量-的值"><a href="#获取一个类的实例的成员变量-的值" class="headerlink" title="获取一个类的实例的成员变量(的值)"></a>获取一个类的实例的成员变量(的值)</h4><pre><code>// MARK: - 获取一个类的实例的成员变量(的值)/** * Obtains the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to obtain. * @param name A C string. Pass the name of the instance variable whose value you wish to obtain. * @param outValue On return, contains a pointer to the value of the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and name of *  the instance variable specified by \e name. */OBJC_EXPORT Ivar _Nullableobject_getInstanceVariable(id _Nullable obj, const char * _Nonnull name,                           void * _Nullable * _Nullable outValue)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)    OBJC_ARC_UNAVAILABLE;// 获取实例的成员变量Ivar object_getInstanceVariable(id obj, const char *name, void **value){    if (obj  &amp;&amp;  name  &amp;&amp;  !obj-&gt;isTaggedPointer()) {        Ivar ivar;        if ((ivar = class_getInstanceVariable(obj-&gt;ISA(), name))) {            if (value) *value = (void *)object_getIvar(obj, ivar);            return ivar;        }    }    if (value) *value = nil;    return nil;}</code></pre><h4 id="获取一个类所有成员变量的size"><a href="#获取一个类所有成员变量的size" class="headerlink" title="获取一个类所有成员变量的size"></a>获取一个类所有成员变量的size</h4><pre><code>// MARK: - 获取一个类所有成员变量的size/** * Returns the size of instances of a class. * * @param cls A class object. * * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil. */OBJC_EXPORT size_tclass_getInstanceSize(Class _Nullable cls)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类所有成员变量的sizesize_t class_getInstanceSize(Class cls){    if (!cls) return 0;    return cls-&gt;alignedInstanceSize();}// Class&#39;s ivar size rounded up to a pointer-size boundary.    uint32_t alignedInstanceSize() {        return word_align(unalignedInstanceSize());    } // May be unaligned depending on class&#39;s ivars.    uint32_t unalignedInstanceSize() {        assert(isRealized());        // 返回一个类中所有成员变量的size        return data()-&gt;ro-&gt;instanceSize;    }</code></pre><p>这里也印证了我们之前文章所说的一个类的成员变量在编译后内存布局已经固定了,其获取大小是从data()-&gt;ro-&gt;instanceSize来.</p><h4 id="根据成员变量名称获取某个类中的成员变量-objc-getInstanceVariable中调用的就是此函数"><a href="#根据成员变量名称获取某个类中的成员变量-objc-getInstanceVariable中调用的就是此函数" class="headerlink" title="根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)"></a>根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)</h4><pre><code>// MARK: - 根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)/** * Returns the \c Ivar for a specified instance variable of a given class. * * @param cls The class whose instance variable you wish to obtain. * @param name The name of the instance variable definition to obtain. * * @return A pointer to an \c Ivar data structure containing information about *  the instance variable specified by \e name. */OBJC_EXPORT Ivar _Nullableclass_getInstanceVariable(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// MARK: - 根据名称获取一个类中的成员变量/************************************************************************ class_getInstanceVariable.  Return the named instance variable.**********************************************************************/Ivar class_getInstanceVariable(Class cls, const char *name){    if (!cls  ||  !name) return nil;    return _class_getVariable(cls, name);}</code></pre><h4 id="通过名称获取类成员变量"><a href="#通过名称获取类成员变量" class="headerlink" title="通过名称获取类成员变量"></a>通过名称获取类成员变量</h4><pre><code>// MARK: - 通过名称获取类成员变量/** * Returns the Ivar for a specified class variable of a given class. * * @param cls The class definition whose class variable you wish to obtain. * @param name The name of the class variable definition to obtain. * * @return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name. */OBJC_EXPORT Ivar _Nullableclass_getClassVariable(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取类中的类成员变量/************************************************************************ class_getClassVariable.  Return the named class variable.**********************************************************************/Ivar class_getClassVariable(Class cls, const char *name){    if (!cls) return nil;    return class_getInstanceVariable(cls-&gt;ISA(), name);}</code></pre><h4 id="获取一个类的所有成员变量"><a href="#获取一个类的所有成员变量" class="headerlink" title="获取一个类的所有成员变量"></a>获取一个类的所有成员变量</h4><pre><code>// MARK: - 获取一个类的所有成员变量/** * Describes the instance variables declared by a class. * * @param cls The class to inspect. * @param outCount On return, contains the length of the returned array. *  If outCount is NULL, the length is not returned. * * @return An array of pointers of type Ivar describing the instance variables declared by the class. *  Any instance variables declared by superclasses are not included. The array contains *outCount *  pointers followed by a NULL terminator. You must free the array with free(). * *  If the class declares no instance variables, or cls is Nil, NULL is returned and *outCount is 0. */OBJC_EXPORT Ivar _Nonnull * _Nullableclass_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类的所有成员变量/************************************************************************ class_copyIvarList* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar *class_copyIvarList(Class cls, unsigned int *outCount){    const ivar_list_t *ivars;    Ivar *result = nil;    unsigned int count = 0;    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    if ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)  &amp;&amp;  ivars-&gt;count) {        result = (Ivar *)malloc((ivars-&gt;count+1) * sizeof(Ivar));        for (auto&amp; ivar : *ivars) {            if (!ivar.offset) continue;  // anonymous bitfield            result[count++] = &amp;ivar;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return result;}</code></pre><p>其获取主要来自:cls-&gt;data()-&gt;ro-&gt;ivars.</p><h4 id="给一个类添加成员变量-必须在调用objc-allocateClassPair之后在objc-registerClassPair之前"><a href="#给一个类添加成员变量-必须在调用objc-allocateClassPair之后在objc-registerClassPair之前" class="headerlink" title="给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前"></a>给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前</h4><pre><code>// MARK: - 给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前/** * Adds a new instance variable to a class. * * @return YES if the instance variable was added successfully, otherwise NO *         (for example, the class already contains an instance variable with that name). * * @note This function may only be called after objc_allocateClassPair and before objc_registerClassPair. *       Adding an instance variable to an existing class is not supported. * @note The class must not be a metaclass. Adding an instance variable to a metaclass is not supported. * @note The instance variable&#39;s minimum alignment in bytes is 1&lt;&lt;align. The minimum alignment of an instance *       variable depends on the ivar&#39;s type and the machine architecture. *       For variables of any pointer type, pass log2(sizeof(pointer_type)). */OBJC_EXPORT BOOLclass_addIvar(Class _Nullable cls, const char * _Nonnull name, size_t size,              uint8_t alignment, const char * _Nullable types)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 给一个类添加成员变量/************************************************************************ class_addIvar* Adds an ivar to a class.* Locking: acquires runtimeLock**********************************************************************/BOOLclass_addIvar(Class cls, const char *name, size_t size,              uint8_t alignment, const char *type){    if (!cls) return NO;    if (!type) type = &quot;&quot;;    if (name  &amp;&amp;  0 == strcmp(name, &quot;&quot;)) name = nil;    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    // No class variables    if (cls-&gt;isMetaClass()) {        return NO;    }    // Can only add ivars to in-construction classes.    if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) {        return NO;    }    // Check for existing ivar with this name, unless it&#39;s anonymous.    // Check for too-big ivar.    // fixme check for superclass ivar too?    if ((name  &amp;&amp;  getIvar(cls, name))  ||  size &gt; UINT32_MAX) {        return NO;    }    class_ro_t *ro_w = make_ro_writeable(cls-&gt;data());    // fixme allocate less memory here    ivar_list_t *oldlist, *newlist;    if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) {        size_t oldsize = oldlist-&gt;byteSize();        newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1);        memcpy(newlist, oldlist, oldsize);        free(oldlist);    } else {        newlist = (ivar_list_t *)calloc(sizeof(ivar_list_t), 1);        newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t);    }    uint32_t offset = cls-&gt;unalignedInstanceSize();    uint32_t alignMask = (1&lt;&lt;alignment)-1;    offset = (offset + alignMask) &amp; ~alignMask;    ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++);#if __x86_64__    // Deliberately over-allocate the ivar offset variable.    // Use calloc() to clear all 64 bits. See the note in struct ivar_t.    ivar.offset = (int32_t *)(int64_t *)calloc(sizeof(int64_t), 1);#else    ivar.offset = (int32_t *)malloc(sizeof(int32_t));#endif    *ivar.offset = offset;    ivar.name = name ? strdupIfMutable(name) : nil;    ivar.type = strdupIfMutable(type);    ivar.alignment_raw = alignment;    ivar.size = (uint32_t)size;    ro_w-&gt;ivars = newlist;    cls-&gt;setInstanceSize((uint32_t)(offset + size));    // Ivar layout updated in registerClass.    return YES;}</code></pre><h4 id="获取成员变量名称"><a href="#获取成员变量名称" class="headerlink" title="获取成员变量名称"></a>获取成员变量名称</h4><pre><code>// MARK: - 获取成员变量名称/* Working with Instance Variables *//** * Returns the name of an instance variable. * * @param v The instance variable you want to enquire about. * * @return A C string containing the instance variable&#39;s name. */OBJC_EXPORT const char * _Nullableivar_getName(Ivar _Nonnull v)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取成员变量名称/************************************************************************ ivar_getName* fixme* Locking: none**********************************************************************/const char *ivar_getName(Ivar ivar){    if (!ivar) return nil;    return ivar-&gt;name;}</code></pre><h4 id="获取成员变量类型"><a href="#获取成员变量类型" class="headerlink" title="获取成员变量类型"></a>获取成员变量类型</h4><pre><code>// MARK: - 获取成员变量类型/** * Returns the type string of an instance variable. * * @param v The instance variable you want to enquire about. * * @return A C string containing the instance variable&#39;s type encoding. * * @note For possible values, see Objective-C Runtime Programming Guide &gt; Type Encodings. */OBJC_EXPORT const char * _Nullableivar_getTypeEncoding(Ivar _Nonnull v)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取成员变量名称/************************************************************************ ivar_getTypeEncoding* fixme* Locking: none**********************************************************************/const char *ivar_getTypeEncoding(Ivar ivar){    if (!ivar) return nil;    return ivar-&gt;type;}</code></pre><h3 id="property声明"><a href="#property声明" class="headerlink" title="property声明"></a>property声明</h3><pre><code>/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;</code></pre><p>完整声明在objc-runtime-new.h文件中:</p><pre><code>// MARK: - 属性声明struct property_t {    const char *name;    const char *attributes;};</code></pre><h4 id="根据名称获取一个类的属性"><a href="#根据名称获取一个类的属性" class="headerlink" title="根据名称获取一个类的属性"></a>根据名称获取一个类的属性</h4><pre><code>// MARK: - 根据名称获取一个类的属性/** * Returns a property with a given name of a given class. * * @param cls The class you want to inspect. * @param name The name of the property you want to inspect. * * @return A pointer of type \c objc_property_t describing the property, or *  \c NULL if the class does not declare a property with that name, *  or \c NULL if \e cls is \c Nil. */OBJC_EXPORT objc_property_t _Nullableclass_getProperty(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 根据名称获取一个类中的属性/************************************************************************ class_getProperty* fixme* Locking: read-locks runtimeLock**********************************************************************/objc_property_t class_getProperty(Class cls, const char *name){    if (!cls  ||  !name) return nil;    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    for ( ; cls; cls = cls-&gt;superclass) {        for (auto&amp; prop : cls-&gt;data()-&gt;properties) {            if (0 == strcmp(name, prop.name)) {                return (objc_property_t)&amp;prop;            }        }    }    return nil;}</code></pre><p>先判断cls有没有实现,然后可以看到其获取时从可变class_rw_t的成员变量properties中获得:cls-&gt;data()-&gt;properties.</p><h4 id="获取一个类的属性列表"><a href="#获取一个类的属性列表" class="headerlink" title="获取一个类的属性列表"></a>获取一个类的属性列表</h4><pre><code>// MARK: - 获取一个类的属性列表/** * Describes the properties declared by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. *  If \e outCount is \c NULL, the length is not returned. * * @return An array of pointers of type \c objc_property_t describing the properties *  declared by the class. Any properties declared by superclasses are not included. *  The array contains \c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free(). * *  If \e cls declares no properties, or \e cls is \c Nil, returns \c NULL and \c *outCount is \c 0. */OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类的属性列表/************************************************************************ class_copyPropertyList. Returns a heap block containing the* properties declared in the class, or nil if the class* declares no properties. Caller must free the block.* Does not copy any superclass&#39;s properties.* Locking: read-locks runtimeLock**********************************************************************/objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount){    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    // 先获取rw    auto rw = cls-&gt;data();    property_t **result = nil;    unsigned int count = rw-&gt;properties.count();    if (count &gt; 0) {        result = (property_t **)malloc((count + 1) * sizeof(property_t *));        count = 0;        for (auto&amp; prop : rw-&gt;properties) {            result[count++] = &amp;prop;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return (objc_property_t *)result;}</code></pre><h4 id="给一个类添加属性"><a href="#给一个类添加属性" class="headerlink" title="给一个类添加属性"></a>给一个类添加属性</h4><pre><code>// MARK: - 给一个类添加属性/** * Adds a property to a class. * * @param cls The class to modify. * @param name The name of the property. * @param attributes An array of property attributes. * @param attributeCount The number of attributes in \e attributes. * * @return \c YES if the property was added successfully, otherwise \c NO *  (for example, the class already has that property). */OBJC_EXPORT BOOLclass_addProperty(Class _Nullable cls, const char * _Nonnull name,                  const objc_property_attribute_t * _Nullable attributes,                  unsigned int attributeCount)    OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0);// 给一个类添加属性BOOLclass_addProperty(Class cls, const char *name,                  const objc_property_attribute_t *attrs, unsigned int n){    return _class_addProperty(cls, name, attrs, n, NO);}// 给一个类添加属性/************************************************************************ class_addProperty* Adds a property to a class.* Locking: acquires runtimeLock**********************************************************************/static bool_class_addProperty(Class cls, const char *name,                   const objc_property_attribute_t *attrs, unsigned int count,                   bool replace){    if (!cls) return NO;    if (!name) return NO;    property_t *prop = class_getProperty(cls, name);    if (prop  &amp;&amp;  !replace) {        // already exists, refuse to replace        return NO;    }    else if (prop) {        // replace existing        mutex_locker_t lock(runtimeLock);        try_free(prop-&gt;attributes);        prop-&gt;attributes = copyPropertyAttributeString(attrs, count);        return YES;    }    else {        mutex_locker_t lock(runtimeLock);        assert(cls-&gt;isRealized());        property_list_t *proplist = (property_list_t *)            malloc(sizeof(*proplist));        proplist-&gt;count = 1;        proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first);        proplist-&gt;first.name = strdupIfMutable(name);        proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count);        cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1);        return YES;    }}</code></pre><p>其操作的还是class_rw_t中的成员变量properties;侧面印证class_rw_t是可变的.</p><h4 id="更新某个属性值"><a href="#更新某个属性值" class="headerlink" title="更新某个属性值"></a>更新某个属性值</h4><pre><code>// MARK: - 更新某个属性值/** * Replace a property of a class. * * @param cls The class to modify. * @param name The name of the property. * @param attributes An array of property attributes. * @param attributeCount The number of attributes in \e attributes. */OBJC_EXPORT voidclass_replaceProperty(Class _Nullable cls, const char * _Nonnull name,                      const objc_property_attribute_t * _Nullable attributes,                      unsigned int attributeCount)    OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0);// 更新某个属性voidclass_replaceProperty(Class cls, const char *name,                      const objc_property_attribute_t *attrs, unsigned int n){    _class_addProperty(cls, name, attrs, n, YES);}</code></pre><h4 id="获取属性名称"><a href="#获取属性名称" class="headerlink" title="获取属性名称"></a>获取属性名称</h4><pre><code>// MARK: - 获取属性名称/* Working with Properties *//** * Returns the name of a property. * * @param property The property you want to inquire about. * * @return A C string containing the property&#39;s name. */OBJC_EXPORT const char * _Nonnullproperty_getName(objc_property_t _Nonnull property)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取属性名称const char *property_getName(objc_property_t prop){    return prop-&gt;name;}</code></pre><h4 id="获取属性的内存管理语义相关"><a href="#获取属性的内存管理语义相关" class="headerlink" title="获取属性的内存管理语义相关"></a>获取属性的内存管理语义相关</h4><pre><code>// MARK: - 获取属性的内存管理语义相关/** * Returns the attribute string of a property. * * @param property A property. * * @return A C string containing the property&#39;s attributes. * * @note The format of the attribute string is described in Declared Properties in Objective-C Runtime Programming Guide. */OBJC_EXPORT const char * _Nullableproperty_getAttributes(objc_property_t _Nonnull property)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取属性的内存管理语义const char *property_getAttributes(objc_property_t prop){    return prop-&gt;attributes;}</code></pre><p>这个获取的到的就是readwrite,stong,atomic等相关.</p><h3 id="Protocol的声明"><a href="#Protocol的声明" class="headerlink" title="Protocol的声明"></a>Protocol的声明</h3><pre><code>#ifdef __OBJC__@class Protocol;#elsetypedef struct objc_object Protocol;#endif@implementation Protocol#if __OBJC2__// fixme hack - make Protocol a non-lazy class+ (void) load { }#endif- (BOOL) conformsTo: (Protocol *)aProtocolObj{    return protocol_conformsToProtocol(self, aProtocolObj);}- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel{#if !__OBJC2__    return lookup_protocol_method((struct old_protocol *)self, aSel,                                  YES/*required*/, YES/*instance*/,                                  YES/*recursive*/);#else    return method_getDescription(protocol_getMethod((struct protocol_t *)self,                                                     aSel, YES, YES, YES));#endif}- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel{#if !__OBJC2__    return lookup_protocol_method((struct old_protocol *)self, aSel,                                  YES/*required*/, NO/*instance*/,                                  YES/*recursive*/);#else    return method_getDescription(protocol_getMethod((struct protocol_t *)self,                                                    aSel, YES, NO, YES));#endif}- (const char *)name{    return protocol_getName(self);}- (BOOL)isEqual:other{#if __OBJC2__    // check isKindOf:    Class cls;    Class protoClass = objc_getClass(&quot;Protocol&quot;);    for (cls = object_getClass(other); cls; cls = cls-&gt;superclass) {        if (cls == protoClass) break;    }    if (!cls) return NO;    // check equality    return protocol_isEqual(self, other);#else    return [other isKindOf:[Protocol class]] &amp;&amp; [self conformsTo: other] &amp;&amp; [other conformsTo: self];#endif}#if __OBJC2__- (NSUInteger)hash{    return 23;}#else- (unsigned)hash{    return 23;}#endif@end</code></pre><p>在runtime.h文件中我们可以看到Protocol被定义为一个类继承自上帝类NSObject.这个类并没有对外暴露什么接口.下面我们看一下protocol_t的完整声明:</p><pre><code>// MARK: - 协议的声明结构struct protocol_t : objc_object {    const char *mangledName;    struct protocol_list_t *protocols; //协议列表    method_list_t *instanceMethods;//实例方法列表    method_list_t *classMethods;//类方法列表    method_list_t *optionalInstanceMethods;//可选的实例方法列表    method_list_t *optionalClassMethods;//可选的类方法列表    property_list_t *instanceProperties;//属性列表    uint32_t size;   // sizeof(protocol_t)    uint32_t flags;    // Fields below this point are not always present on disk.    const char **_extendedMethodTypes;    const char *_demangledName;    property_list_t *_classProperties;    const char *demangledName();    const char *nameForLogging() {        return demangledName();    }    bool isFixedUp() const;    void setFixedUp();#   define HAS_FIELD(f) (size &gt;= offsetof(protocol_t, f) + sizeof(f))    bool hasExtendedMethodTypesField() const {        return HAS_FIELD(_extendedMethodTypes);    }    bool hasDemangledNameField() const {        return HAS_FIELD(_demangledName);    }    bool hasClassPropertiesField() const {        return HAS_FIELD(_classProperties);    }#   undef HAS_FIELD    const char **extendedMethodTypes() const {        return hasExtendedMethodTypesField() ? _extendedMethodTypes : nil;    }    property_list_t *classProperties() const {        return hasClassPropertiesField() ? _classProperties : nil;    }};</code></pre><h4 id="给一个类添加协议"><a href="#给一个类添加协议" class="headerlink" title="给一个类添加协议"></a>给一个类添加协议</h4><pre><code>// MARK: - 给一个类添加协议/** * Adds a protocol to a class. * * @param cls The class to modify. * @param protocol The protocol to add to \e cls. * * @return \c YES if the method was added successfully, otherwise \c NO *  (for example, the class already conforms to that protocol). */OBJC_EXPORT BOOLclass_addProtocol(Class _Nullable cls, Protocol * _Nonnull protocol)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 给一个类添加协议/************************************************************************ class_addProtocol* Adds a protocol to a class.* Locking: acquires runtimeLock**********************************************************************/BOOL class_addProtocol(Class cls, Protocol *protocol_gen){    protocol_t *protocol = newprotocol(protocol_gen);    if (!cls) return NO;    if (class_conformsToProtocol(cls, protocol_gen)) return NO;    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    // fixme optimize    protocol_list_t *protolist = (protocol_list_t *)        malloc(sizeof(protocol_list_t) + sizeof(protocol_t *));    protolist-&gt;count = 1;    protolist-&gt;list[0] = (protocol_ref_t)protocol;    // 添加到protocols里面    cls-&gt;data()-&gt;protocols.attachLists(&amp;protolist, 1);    // fixme metaclass?    return YES;}</code></pre><p>其操作的还是class_rw_t中的成员变量protocols;侧面印证class_rw_t是可变的.</p><h4 id="根据名称获取一个协议"><a href="#根据名称获取一个协议" class="headerlink" title="根据名称获取一个协议"></a>根据名称获取一个协议</h4><pre><code>// MARK: - 根据名称获取一个协议/* Working with Protocols *//** * Returns a specified protocol. * * @param name The name of a protocol. * * @return The protocol named \e name, or \c NULL if no protocol named \e name could be found. * * @note This function acquires the runtime lock. */OBJC_EXPORT Protocol * _Nullableobjc_getProtocol(const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议/************************************************************************ objc_getProtocol* Get a protocol by name, or return nil* Locking: read-locks runtimeLock**********************************************************************/Protocol *objc_getProtocol(const char *name){    mutex_locker_t lock(runtimeLock);    return getProtocol(name);}</code></pre><h4 id="获取运行时所有的协议列表"><a href="#获取运行时所有的协议列表" class="headerlink" title="获取运行时所有的协议列表"></a>获取运行时所有的协议列表</h4><pre><code>// MARK: - 获取运行时所有的协议列表/** * Returns an array of all the protocols known to the runtime. * * @param outCount Upon return, contains the number of protocols in the returned array. * * @return A C array of all the protocols known to the runtime. The array contains \c *outCount *  pointers followed by a \c NULL terminator. You must free the list with \c free(). * * @note This function acquires the runtime lock. */OBJC_EXPORT Protocol * __unsafe_unretained _Nonnull * _Nullableobjc_copyProtocolList(unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取运行时所有的协议列表/************************************************************************ objc_copyProtocolList* Returns pointers to all protocols.* Locking: read-locks runtimeLock**********************************************************************/Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount){    mutex_locker_t lock(runtimeLock);    NXMapTable *protocol_map = protocols();    unsigned int count = NXCountMapTable(protocol_map);    if (count == 0) {        if (outCount) *outCount = 0;        return nil;    }    Protocol **result = (Protocol **)malloc((count+1) * sizeof(Protocol*));    unsigned int i = 0;    Protocol *proto;    const char *name;    NXMapState state = NXInitMapState(protocol_map);    while (NXNextMapState(protocol_map, &amp;state,                          (const void **)&amp;name, (const void **)&amp;proto))    {        result[i++] = proto;    }    result[i++] = nil;    assert(i == count+1);    if (outCount) *outCount = count;    return result;}</code></pre><h4 id="获取某个协议中的某个属性"><a href="#获取某个协议中的某个属性" class="headerlink" title="获取某个协议中的某个属性"></a>获取某个协议中的某个属性</h4><pre><code>// MARK: - 获取某个协议中的某个属性/** * Returns the specified property of a given protocol. * * @param proto A protocol. * @param name The name of a property. * @param isRequiredProperty \c YES searches for a required property, \c NO searches for an optional property. * @param isInstanceProperty \c YES searches for an instance property, \c NO searches for a class property. * * @return The property specified by \e name, \e isRequiredProperty, and \e isInstanceProperty for \e proto, *  or \c NULL if none of \e proto&#39;s properties meets the specification. */OBJC_EXPORT objc_property_t _Nullableprotocol_getProperty(Protocol * _Nonnull proto,                     const char * _Nonnull name,                     BOOL isRequiredProperty, BOOL isInstanceProperty)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议中的某个属性objc_property_t protocol_getProperty(Protocol *p, const char *name,                              BOOL isRequiredProperty, BOOL isInstanceProperty){    if (!p  ||  !name) return nil;    mutex_locker_t lock(runtimeLock);    return (objc_property_t)        protocol_getProperty_nolock(newprotocol(p), name,                                    isRequiredProperty, isInstanceProperty);}</code></pre><h4 id="获取协议的属性列表"><a href="#获取协议的属性列表" class="headerlink" title="获取协议的属性列表"></a>获取协议的属性列表</h4><pre><code>// MARK: - 获取协议的属性列表/** * Returns an array of the required instance properties declared by a protocol. * * @note Identical to * \code * protocol_copyPropertyList2(proto, outCount, YES, YES); * \endcode */OBJC_EXPORT objc_property_t _Nonnull * _Nullableprotocol_copyPropertyList(Protocol * _Nonnull proto,                          unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议属性列表objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount){    return protocol_copyPropertyList2(proto, outCount,                                      YES/*required*/, YES/*instance*/);}// 获取协议属性列表objc_property_t *protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount,                           BOOL isRequiredProperty, BOOL isInstanceProperty){    if (!proto  ||  !isRequiredProperty) {        // Optional properties are not currently supported.        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    property_list_t *plist = isInstanceProperty        ? newprotocol(proto)-&gt;instanceProperties        : newprotocol(proto)-&gt;classProperties();    return (objc_property_t *)copyPropertyList(plist, outCount);}</code></pre><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a></strong>,里面有相关阅读注释.</p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class解读</title>
      <link href="/2019/04/15/Class%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/15/Class%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>首先我们在runtime.h文件中看到objc_class的结构声明:</p><pre><code>/// 类的声明结构struct objc_class {Class _Nonnull isa OBJC_ISA_AVAILABILITY;//isa 指针#if !__OBJC2__Class _Nullable super_class OBJC2_UNAVAILABLE;//指向父类的指针const char * _Nonnull name OBJC2_UNAVAILABLE;//类名long version OBJC2_UNAVAILABLE;//版本long info OBJC2_UNAVAILABLE;//其它信息long instance_size OBJC2_UNAVAILABLE;//实例变量空间大小struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;//成员变量列表struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;//方法列表struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;//方法缓存列表struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;//协议列表#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>以上是runtime暴露给我们的有关Class的接口,而在objc-runtime-new.h文件中有objc_class结构的完整声明:</p><pre><code>// MARK: - class的完整声明结构struct objc_class : objc_object {// Class ISA;Class superclass;//指向父类指针cache_t cache; // formerly cache pointer and vtable //缓存一些指针和虚表class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // 含有class_rw_t,内部存储方法,属性,遵循的协议等// class_rw_t指针class_rw_t *data() {return bits.data();}// set bitsvoid setData(class_rw_t *newData) {bits.setData(newData);}...下面未列出}</code></pre><p>可以看出,objc_class中有几个比较重要的成员变量和函数:</p><h5 id="superclass"><a href="#superclass" class="headerlink" title="superclass"></a><strong>superclass</strong></h5><p>指向父类的指针</p><h5 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a><strong>cache_t</strong></h5><p>cache里面存的是指针和虚表,为了方法调用时,快速查询,提高效率.其结构声明如下:</p><pre><code>// MARK: - cache_t结构声明struct cache_t {struct bucket_t *_buckets;mask_t _mask;mask_t _occupied;...下面未列出}</code></pre><h6 id="bucket-t"><a href="#bucket-t" class="headerlink" title="bucket_t"></a>bucket_t</h6><pre><code>// MARK: - bucket_t声明结构struct bucket_t {private:// IMP-first is better for arm64e ptrauth and no worse for arm64.// SEL-first is better for armv7* and i386 and x86_64.#if __arm64__MethodCacheIMP _imp;cache_key_t _key;#elsecache_key_t _key;MethodCacheIMP _imp;#endifpublic:inline cache_key_t key() const { return _key; }inline IMP imp() const { return (IMP)_imp; }inline void setKey(cache_key_t newKey) { _key = newKey; }inline void setImp(IMP newImp) { _imp = newImp; }void set(cache_key_t newKey, IMP newImp);};</code></pre><p>这个bucket_t类似于一个hash表,其没一个cache_key_t对应一个imp.其关系如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-2f6f114a344d02ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bucket_t"></p><h5 id="class-data-bits-t结构"><a href="#class-data-bits-t结构" class="headerlink" title="class_data_bits_t结构"></a><strong>class_data_bits_t结构</strong></h5><pre><code>// MARK: - class_data_bits_t声明结构struct class_data_bits_t {class_rw_t* data() {return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}void setData(class_rw_t *newData){assert(!data() || (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));// Set during realization or construction only. No locking needed.// Use a store-release fence because there may be concurrent// readers of data and data&#39;s contents.uintptr_t newBits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;atomic_thread_fence(memory_order_release);bits = newBits;}...其它未列出}</code></pre><p>class_data_bits_t中成员函数 data()函数,返回一个class_rw_t结构指针;</p><h5 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a><strong>class_rw_t</strong></h5><pre><code>// MARK: - class_rw_t结构声明struct class_rw_t {// Be warned that Symbolication knows the layout of this structure.uint32_t flags;uint32_t version;const class_ro_t *ro;method_array_t methods;property_array_t properties;protocol_array_t protocols;Class firstSubclass;Class nextSiblingClass;char *demangledName;#if SUPPORT_INDEXED_ISAuint32_t index;#endifvoid setFlags(uint32_t set){OSAtomicOr32Barrier(set, &amp;flags);}void clearFlags(uint32_t clear){OSAtomicXor32Barrier(clear, &amp;flags);}// set and clear must not overlapvoid changeFlags(uint32_t set, uint32_t clear){assert((set &amp; clear) == 0);uint32_t oldf, newf;do {oldf = flags;newf = (oldf | set) &amp; ~clear;} while (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (volatile int32_t *)&amp;flags));}};</code></pre><p>class_rw_t中的成员变量class_ro_t:</p><h5 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a><strong>class_ro_t</strong></h5><pre><code>// MARK: - class_ro_t结构声明struct class_ro_t {uint32_t flags;uint32_t instanceStart;uint32_t instanceSize;#ifdef __LP64__uint32_t reserved;#endifconst uint8_t * ivarLayout;const char * name;method_list_t * baseMethodList;protocol_list_t * baseProtocols;const ivar_list_t * ivars;const uint8_t * weakIvarLayout;property_list_t *baseProperties;method_list_t *baseMethods() const {return baseMethodList;}};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_ro_t有method_list_t,protocol_list_t,ivar_list_t,property_list_t等成员变量这些成员变量的作用是存储编译后已确定的一些信息.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_rw_t中同样有method_array_t(方法列表),property_array_t(属性列表),protocol_array_t(协议列表),这三者均继承自list_array_tt,list_array_tt可以扩充,内部分别存储的是method_list_t,property_list_t和protocol_list_t;这个三个成员变量主要是方便在运行时为类提供拓展能力.</p><h4 id="编译后class内存布局"><a href="#编译后class内存布局" class="headerlink" title="编译后class内存布局"></a>编译后class内存布局</h4><pre><code>// Person#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface Person : NSObject- (void)name;@endNS_ASSUME_NONNULL_ENDint main(int argc, const char * argv[]) {@autoreleasepool {Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);objc_registerClassPair(newClass);id newObject = [[newClass alloc]init];NSLog(@&quot;%s&quot;,class_getName([newObject class]));NSLog(@&quot;Hello, World!&quot;);Person *person = [Person new];[person name];[person name];Class cls = [Person class];}return 0;}</code></pre><p>我们来看cls这个class在编译后的内存布局,首先我们在main入口函数里面继续初始化一个Class cls = [Person class];然后运行一下获取当前cls的内存地址,然后将断点放过.</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-5d0150be3d085679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Person class address"></p><p>然后在_objc_init()函数(runtime初始化之前)加一个断点:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-11a62e46db779044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_objc_init()"></p><p>用lldb命令调试一下:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-ca7a1d8cedf5f4bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cls memory layout"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上图我们可以看到,name(“Person”)和baseMethodList这两个是有值,其它都为0x0000000000000000空指针,这个也反映出我们在Person中的最初定义:只有一个- (void)name方法,没有协议,成员变量,属性等.</p><p>我们从baseMethodList方法列表中第一个method_t</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-2cdabc19c9ae5403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="name func"></p><p>这个method_t正好对应我们定义的name方法;而baseMethodList里面也就有1个方法:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-562d498710ddaf8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="baseMethodList count"></p><h4 id="类的实现realizeClass"><a href="#类的实现realizeClass" class="headerlink" title="类的实现realizeClass"></a>类的实现realizeClass</h4><p>realizeClass是类初始化函数,类的运行时初始化都要调用此函数.</p><pre><code>// MARK: - 类的初始化/************************************************************************ realizeClass* Performs first-time initialization on class cls,* including allocating its read-write data.* Returns the real class structure for the class.* Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClass(Class cls){runtimeLock.assertLocked();const class_ro_t *ro;class_rw_t *rw;Class supercls;Class metacls;bool isMeta;if (!cls) return nil;if (cls-&gt;isRealized()) return cls;assert(cls == remapClass(cls));// fixme verify class is not in an un-dlopened part of the shared cache?ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) {// This was a future class. rw data is already allocated.rw = cls-&gt;data();ro = cls-&gt;data()-&gt;ro;cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else {// Normal class. Allocate writeable class data.rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw);}isMeta = ro-&gt;flags &amp; RO_META;rw-&gt;version = isMeta ? 7 : 0; // old runtime went up to 6// Choose an index for this class.// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are availablecls-&gt;chooseClassArrayIndex();if (PrintConnecting) {_objc_inform(&quot;CLASS: realizing class &#39;%s&#39;%s %p %p #%u&quot;,cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;,(void*)cls, ro, cls-&gt;classArrayIndex());}// Realize superclass and metaclass, if they aren&#39;t already.// This needs to be done after RW_REALIZED is set above, for root classes.// This needs to be done after class index is chosen, for root metaclasses.supercls = realizeClass(remapClass(cls-&gt;superclass));metacls = realizeClass(remapClass(cls-&gt;ISA()));#if SUPPORT_NONPOINTER_ISA// Disable non-pointer isa for some classes and/or platforms.// Set instancesRequireRawIsa.bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();bool rawIsaIsInherited = false;static bool hackedDispatch = false;if (DisableNonpointerIsa) {// Non-pointer isa disabled by environment or app SDK versioninstancesRequireRawIsa = true;}else if (!hackedDispatch &amp;&amp; !(ro-&gt;flags &amp; RO_META) &amp;&amp;0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)){// hack for libdispatch et al - isa also acts as vtable pointerhackedDispatch = true;instancesRequireRawIsa = true;}else if (supercls &amp;&amp; supercls-&gt;superclass &amp;&amp;supercls-&gt;instancesRequireRawIsa()){// This is also propagated by addSubclass()// but nonpointer isa setup needs it earlier.// Special case: instancesRequireRawIsa does not propagate// from root class to root metaclassinstancesRequireRawIsa = true;rawIsaIsInherited = true;}if (instancesRequireRawIsa) {cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);}// SUPPORT_NONPOINTER_ISA#endif// Update superclass and metaclass in case of remappingcls-&gt;superclass = supercls;cls-&gt;initClassIsa(metacls);// Reconcile instance variable offsets / layout.// This may reallocate class_ro_t, updating our ro variable.if (supercls &amp;&amp; !isMeta) reconcileInstanceVariables(cls, supercls, ro);// Set fastInstanceSize if it wasn&#39;t set already.cls-&gt;setInstanceSize(ro-&gt;instanceSize);// Copy some flags from ro to rwif (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) {cls-&gt;setHasCxxDtor();if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) {cls-&gt;setHasCxxCtor();}}// Connect this class to its superclass&#39;s subclass listsif (supercls) {addSubclass(supercls, cls);} else {addRootClass(cls);}// Attach categoriesmethodizeClass(cls);return cls;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们来验证class_ro_t确定时机.还是之前的步骤,先编译一次获取到cls的内存地址.在static Class realizeClass(Class cls){}入口添加一个条件断点,运行:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-4eeb6440a9f42fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition breakpoint"></p><p>然后lldb调试cls:</p><p>访问 class_data_bits_t 指针的内容:(class_data_bits_t) $2755 = (bits = 4294971696)</p><p>获取 class_rw_t:</p><pre><code>(class_rw_t) $2757 = {flags = 128version = 8ro = 0x0000000000000008methods = {list_array_tt&lt;method_t, method_list_t&gt; = {= {list = 0x0000000000000000arrayAndFlag = 0}}}properties = {list_array_tt&lt;property_t, property_list_t&gt; = {= {list = 0x0000000100000f84arrayAndFlag = 4294971268}}}protocols = {list_array_tt&lt;unsigned long, protocol_list_t&gt; = {= {list = 0x0000000100001110arrayAndFlag = 4294971664}}}firstSubclass = nilnextSiblingClass = nildemangledName = 0x0000000000000000 &lt;no value available&gt;}</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1715253-aac44a322f04f552.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class_rw_t"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到class_rw_t中的成员变量ro = 0x0000000000000008在运行前已经有值了.获取一下ro:</p><pre><code>(lldb) p $2757.ro(const class_ro_t *) $2758 = 0x0000000000000008</code></pre><p>由于lldb输出class_ro_t报错:</p><pre><code>(lldb) p *$2758error: Couldn&#39;t apply expression side effects : Couldn&#39;t dematerialize a result variable: couldn&#39;t read its memory</code></pre><p>我们直接单步断点,往下走两步,直接获取ro的值:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-db5d8af8cabe5ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class_ro_t"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们发现const指针 class_ro_t已经在编译期把类的相关信息(方法,属性,成员变量,协议)确定了.而类的初始化方法执行之后,编译期的ro赋值给了运行期的rw的成员变量ro了.</p><pre><code>ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) {// This was a future class. rw data is already allocated.rw = cls-&gt;data();ro = cls-&gt;data()-&gt;ro;cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else {// 将ro等信息赋值给class_rw_t// Normal class. Allocate writeable class data.rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw);}</code></pre><p>我们知道class_rw_t中除了class_ro_t成员变量外,还有以下三个成员变量:</p><pre><code>method_array_t methods;property_array_t properties;protocol_array_t protocols;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三个成员变量的赋值操作在static void methodizeClass(Class cls)()函数中,分别遍历ro中的方法,协议,属性列表分别加入到class_rw_t的methods,protocols,properties中.</p><pre><code>// MARK: - 将ro中的方法,属性,协议等列表添加到rw中对应的三个成员变量列表中/************************************************************************ methodizeClass* Fixes up cls&#39;s method list, protocol list, and property list.* Attaches any outstanding categories.* Locking: runtimeLock must be held by the caller**********************************************************************/static void methodizeClass(Class cls){runtimeLock.assertLocked();bool isMeta = cls-&gt;isMetaClass();auto rw = cls-&gt;data();auto ro = rw-&gt;ro;// Methodizing for the first timeif (PrintConnecting) {_objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;,cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);}// 遍历ro中方法将其加入到rw methods中// Install methods and properties that the class implements itself.method_list_t *list = ro-&gt;baseMethods();if (list) {prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));rw-&gt;methods.attachLists(&amp;list, 1);}// 遍历ro中属性列表将其加入到 rw properties中property_list_t *proplist = ro-&gt;baseProperties;if (proplist) {rw-&gt;properties.attachLists(&amp;proplist, 1);}// 遍历ro中协议列表将其加入到 rw protocols中protocol_list_t *protolist = ro-&gt;baseProtocols;if (protolist) {rw-&gt;protocols.attachLists(&amp;protolist, 1);}// Root classes get bonus method implementations if they don&#39;t have// them already. These apply before category replacements.if (cls-&gt;isRootMetaclass()) {// root metaclassaddMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);}// Attach categories.category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);attachCategories(cls, cats, false /*don&#39;t flush caches*/);if (PrintConnecting) {if (cats) {for (uint32_t i = 0; i &lt; cats-&gt;count; i++) {_objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;,isMeta ? &#39;+&#39; : &#39;-&#39;,cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);}}}if (cats) free(cats);#if DEBUG// Debug: sanity-check all SELs; log method list contentsfor (const auto&amp; meth : rw-&gt;methods) {if (PrintConnecting) {_objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;,cls-&gt;nameForLogging(), sel_getName(meth.name));}assert(sel_registerName(sel_getName(meth.name)) == meth.name);}#endif}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译期:通过objc_class-&gt;data()获取class_ro_t,class的method,property,protocol,ivar等已确定被赋值给class_ro_t,class_to_t只读,说明编译期类的内存布局已固定.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行期:通过realizeClass()类初始化函数,给class_rw_t分配空间,将class_ro_t赋值给class_rw_t的成员变量ro.将ro中的方法,协议,属性列表分别加入到class_rw_t的methods,protocols,properties中.class_rw_t提供了运行期这些成员变量的扩展性.</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a></strong>,里面有相关阅读注释.</p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/04/14/%E6%A0%91/"/>
      <url>/2019/04/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一棵树(tree)是一些节点的集合.这个集合可以为空集.若这个集合非空,则一个树由称做根(root)的节点r和多个子树T1,T2,…Tn组成,这些子树又可以有多个子树,这就让我们想到定义树一个常规方法就是递归,而每棵子树都与根节点r通过一条有向的边(edge)相连.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一棵子树叫做根r的儿子(child),根r称做每一棵子树的父亲(praent).所有节点组成的树,共有N个节点和N-1条边.没有儿子的节点也可以称做树叶(leaf),具有相同父亲的多个节点之间互称为兄弟(sibling).</p><h4 id="节点的度"><a href="#节点的度" class="headerlink" title="节点的度"></a>节点的度</h4><p>一个节点含有子节点的个数称为节点的度,树的度为树中某个节点的最大度即为树的度.</p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>从节点n1到nk看做是树的一条路径(path),这个路径包括了n1到nk的k个节点以及k-1条边,路径的长度也就是该路径上边的个数.</p><h4 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h4><p>对于任意节点ni的深度指的是从根节点r到节点ni的唯一有效路径的长度.根r的深度为0.</p><h4 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h4><p>对于任意节点ni的高度指的是从n到树叶节点最长路径的长.一棵树的高度指的是根r到树叶最长的路径长.</p><h4 id="节点的层次"><a href="#节点的层次" class="headerlink" title="节点的层次"></a>节点的层次</h4><p>节点的层次指的是节点的层级,根r的层数是1,其儿子节点层次是2.所有子节点层次比父亲节点层次大1.</p><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><p>由多棵树组成的集合称为森林.</p><p><img src="http://abc.waitwalker.cn/tree.jpg" alt="tree"></p><h3 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h3><h4 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h4><pre><code>// MARK: - 树class Tree&lt;T:Equatable&gt; {    // 节点value    var value:T    // 子节点    private(set) var children:[Tree] = []    // 父节点    var parent:Tree?    // MARK: - 构造函数    init(value:T) {        self.value = value    }}</code></pre><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><pre><code>/// 添加节点    ///    /// - Parameter treeNode: 子节点    func addChild(treeNode:Tree) -&gt; Void {        children.append(treeNode)        treeNode.parent = self    }</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快识别隐私政策(Fast OCR Privacy Policy)</title>
      <link href="/2019/04/13/%E5%BF%AB%E8%AF%86%E5%88%AB%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96-Fast-OCR-Privacy-Policy/"/>
      <url>/2019/04/13/%E5%BF%AB%E8%AF%86%E5%88%AB%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96-Fast-OCR-Privacy-Policy/</url>
      
        <content type="html"><![CDATA[<p><strong>我们尊重用户的隐私并对非法窃取用户隐私的行为予以坚决抵制.</strong><br>We respect user privacy and resist those who illegally steal user privacy.</p><p><strong>1.快识别是一个本地化的App,您的识别数据不会涉及任何网络传输及访问.</strong><br>Fast OCR is a localized App that does not involve any network transmission and access.</p><p><strong>2.您的任何信息只会保存在本地,您有任何操作本地数据的权限.</strong><br>Any information you have will only be saved locally and you have any privileges to manipulate local data.</p><p><strong>3.您在使用App的过程中可能会让您授权访问相册,相机等,请知晓,权限由您操作.</strong><br>In the process of using App, you may authorize access to albums, cameras, etc. Please know that the privileges are operated by you.</p><p><strong>4.使用过程中有任何问题,可以在设置页面点击关注,然后进行相关问题反馈.</strong><br>If you have any problems in the process of using App, you can click on the settings page and follow me, feedback on related issues.</p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快识别隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狗圈儿隐私政策</title>
      <link href="/2019/04/13/%E7%8B%97%E5%9C%88%E5%84%BF%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
      <url>/2019/04/13/%E7%8B%97%E5%9C%88%E5%84%BF%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
      
        <content type="html"><![CDATA[<p>请您仔细阅读以下条款，如果您对本协议的任何条款表示异议，您可以选择不进入狗圈儿。当您注册成功，无论是进入狗圈儿，还是在狗圈儿上发布任何内容，或者是直接或通过各类方式（如站外API引用等）间接使用狗圈儿网服务和数据的行为，都将被视作已无条件接受本声明所涉全部内容。若您对本声明的任何条款有异议，请停止使用狗圈儿网所提供的全部服务。</p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a><strong>使用规则</strong></h3><p>1、用户注册成功后，狗圈儿将给予每个用户一个用户帐号及相应的密码，该用户帐号和密码由用户负责保管；用户应当对以其用户帐号进行的所有活动和事件负法律责任。<br>2、用户须对在狗圈儿的注册信息的真实性、合法性、有效性承担全部责任，用户不得冒充他人；不得利用他人的名义发布任何信息；不得恶意使用注册帐号导致其他用户误认； 任何机构或个人注册和使用的互联网用户账号名称，不得有下列情形：<br>(一）违反宪法或法律法规规定的；<br>（二）危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；<br>（三）损害国家荣誉和利益的，损害公共利益的；<br>（四）煽动民族仇恨、民族歧视，破坏民族团结的；<br>（五）破坏国家宗教政策，宣扬邪教和封建迷信的；<br>（六）散布谣言，扰乱社会秩序，破坏社会稳定的；<br>（七）散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；<br>（八）侮辱或者诽谤他人，侵害他人合法权益的；<br>（九）含有法律、行政法规禁止的其他内容的。</p><h3 id="关于用户名的管理"><a href="#关于用户名的管理" class="headerlink" title="关于用户名的管理"></a><strong>关于用户名的管理</strong></h3><p>请勿以党和国家领导人或其他名人的真实姓名、字、号、艺名、笔名、头衔等注册和使用昵 称（如确为本人，需要提交相关证据并通过审核方可允许使用）；<br>请勿以国家组织机构或其他组织机构的名称等注册和使用昵称（如确为该机构，需要提交相关证据并通过审核方可允许使用）；<br>请勿注册和使用与其他网友相同、相仿的名字或昵称；<br>请勿注册和使用不文明、不健康的ID和昵称；<br>请勿注册和使用易产生歧义、引起他人误解或带有各种奇形怪状符号的ID和昵称。<br>用户以虚假信息骗取账号名称注册，或账号头像、简介等注册信息存在违法和不良信息的，狗圈儿将暂停或注销。<br>用户连续一年没有在狗圈儿上更新动态，狗圈儿有权收回该用户昵称。<br>3、狗圈儿是一个信息分享及传播的平台。用户通过狗圈儿发表的信息为公开的信息，其他第三方均可以通过狗圈儿获取用户发表的信息，用户对任何信息的发表即认可该信息为公开的信息，并单独对此行为承担法律责任；任何用户不愿被其他第三人获知的信息都不应该在狗圈儿上进行发表。<br>4、用户承诺不得以任何方式利用狗圈儿直接或间接从事违反中国法律、以及社会公德的行为，狗圈儿有权对违反上述承诺的内容予以删除。<br>5、狗圈儿用户不得利用狗圈儿服务制作、上载、复制、发布、传播或者转载如下内容：<br>· 反对宪法所确定的基本原则的；<br>· 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；<br>· 损害国家荣誉和利益的；<br>· 煽动民族仇恨、民族歧视，破坏民族团结的；<br>· 破坏国家宗教政策，宣扬邪教和封建迷信的；<br>· 散布谣言，扰乱社会秩序，破坏社会稳定的；<br>· 散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；<br>· 侮辱或者诽谤他人，侵害他人合法权益的；<br>· 含有法律、行政法规禁止的其他内容的信息。<br>6、狗圈儿有权对用户使用狗圈儿的情况进行审查和监督，如用户在使用狗圈儿时违反任何上述规定，狗圈儿或其授权的人有权要求用户改正或直接采取一切必要的措施（包括但不限于更改或删除用户张贴的内容、暂停或终止用户使用狗圈儿的权利）以减轻用户不当行为造成的影响。</p><h3 id="知识产权"><a href="#知识产权" class="headerlink" title="知识产权"></a><strong>知识产权</strong></h3><p>狗圈儿是一个信息获取、分享及传播的平台，我们尊重和鼓励狗圈儿用户创作的内容，认识到保护知识产权对狗圈儿生存与发展的重要性，承诺将保护知识产权作为狗圈儿运营的基本原则之一。<br>1、用户在狗圈儿上发表的全部原创内容，著作权均归用户本人所有。用户可授权第三方以任何方式使用，不需要得到狗圈儿的同意。<br>2、狗圈儿提供的网络服务中包含的标识、版面设计、排版方式、文本、图片、图形等均受著作权、商标权及其它法律保护，未经相关权利人（含狗圈儿及其他原始权利人）同意，上述内容均不得在任何平台被直接或间接发布、使用、出于发布或使用目的的改写或再发行，或被用于其他任何商业目的。<br>3、为了促进其创作内容的分享和传播，用户将其在狗圈儿上发表的全部内容，授予狗圈儿免费的、不可撤销的、非独家使用许可，狗圈儿有权将该内容用于狗圈儿各种形态的产品和服务上，包括但不限于网站以及发表的应用或其他互联网产品。<br>第三方若出于非商业目的，将用户在狗圈儿上发表的内容转载在狗圈儿之外的地方，应当在作品的正文开头的显著位置注明原作者姓名（或原作者在狗圈儿上使用的帐号名称），给出原始链接，注明「发表于狗圈儿」，并不得对作品进行修改演绎。若需要对作品进行修改，或用于商业目的，第三方应当联系用户获得单独授权，按照用户规定的方式使用该内容。<br>4、狗圈儿为用户提供「保留所有权利，禁止转载」的选项。除非获得原作者的单独授权，并邮件通知狗圈儿（邮箱：<a href="mailto:waitwalker@163.com" target="_blank" rel="noopener">waitwalker@163.com</a>），任何第三方不得转载标注了「禁止转载」的内容，否则均视为侵权。<br>5、在狗圈儿上传或发表的内容，用户应保证其为著作权人或已取得合法授权，并且该内容不会侵犯任何第三方的合法权益。如果第三方提出关于著作权的异议，狗圈儿有权根据实际情况删除相关的内容有权追究用户的法律责任，给狗圈儿或任何第三方造成损失的，用户应负责全额赔偿。<br>6、如果任何第三方侵犯了狗圈儿用户相关的权利，用户同意授权狗圈儿或其指定的代理人代表狗圈儿自身或用户对该第三方提出警告、投诉、发起行政执法、诉讼、进行上诉，或谈判和解，并且用户同意在狗圈儿认为必要的情况下参与共同维权。<br>7、狗圈儿有权但无义务对用户发布的内容进行审核，有权根据相关证据结合《侵权责任法》、《信息网络传播权保护条例》等法律法规及狗圈儿指导原则对侵权信息进行处理。</p><h3 id="个人隐私"><a href="#个人隐私" class="headerlink" title="个人隐私"></a><strong>个人隐私</strong></h3><p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><ol><li>适用范围<br>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息，留存的个人身份信息主要包括但不限于个人用户服务账号及密码、拍照/摄像等。如您拒绝提供将无法使用我们的产品或服务。<br>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您访问应用服务器和手机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；<br>(c)为确保本APP正常运转，我们会在您的移动设备上存储名为 Cookie的小数据文件。Cookie通常包含标识符、站点名称以及一些号码和字符。借助于Cookie能够存储您的偏好等数据。我们不会将Cookie用于本政策所述目的之外的任何用途。您可根据自己的偏好管理或删除Cookie。您可以清除本设备上保存的所有Cookie，大部分网络浏览器都设有阻止Cookie的功能。但如果您这么做，则需要在每一次使用本APP时更改用户设置<br>(d) 如果我们需要将信息用于本政策未载明的其它用途时，会事先征求您的同意。</li><li>信息使用及信息披露<br>(a)本应用不会向任何无关第三方及其所使用的SDK等提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。<br>(b) 本应用亦不允许任何第三方及其所使用的SDK等以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。<br>(c) 为向您提供服务及改善服务质量，在遵守国家法律法规及监管政策的前提下，我们可能将收集到的您的个人信息用于以下目的：<br>(1)为您提供服务, 经您事先同意，向第三方披露,例如设备一些崩溃信息的收集等以改善服务质量；<br>(2) 与公共安全、公共卫生、重大公共利益有关的；<br>(3) 与犯罪侦查、起诉、审判和判决执行等有关的；<br>(4) 出于维护个人信息主体或其他个人的生命、财产等重大合法权益但又很难得到本人同意的；<br>(5) 所收集的个人信息是个人信息主体自行向社会公众公开的；<br>(6) 从合法公开披露的信息中收集的您的个人信息的，如合法的新闻报道、政府信息公开等渠道；<br>(7) 根据您的要求签订和履行合同所必需的；<br>(8) 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障；<br>(9) 法律法规及监管政策规定的其他情形。</li><li>信息存储和交换<br>本应用收集的有关您的信息和资料将保存在本应用及（或）其应用关联的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</li><li>信息安全<br>本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。<br>5.本隐私政策的更改<br>(a)如果决定更改隐私政策，我们会在本政策中、网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。<br>(b)我们保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，我们会通过及时通过各种形式发布告知。<br>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</li></ol><h3 id="侵权举报"><a href="#侵权举报" class="headerlink" title="侵权举报"></a><strong>侵权举报</strong></h3><p>1、处理原则<br>狗圈儿高度重视自由表达和企业正当权利的平衡。依照法律规定删除违法信息是狗圈儿的法定义务，狗圈儿亦未与任何中介机构合作开展此项业务。<br>2、受理范围<br>受理狗圈儿内侵犯企业或个人合法权益的侵权举报，包括但不限于涉及个人隐私、造谣与诽谤、商业侵权。<br>涉及个人隐私：发布内容中直接涉及身份信息，如个人姓名、家庭住址、身份证号码、工作单位、私人电话等详细个人隐私；<br>造谣、诽谤：发布内容中指名道姓（包括自然人和企业）的直接谩骂、侮辱、虚构中伤、恶意诽谤等；<br>商业侵权：泄露企业商业机密及其他根据保密协议不能公开讨论的内容。<br>3、举报条件<br>如果个人或单位发现狗圈儿上存在侵犯自身合法权益的内容，请与狗圈儿取得联系（邮箱：<a href="mailto:waitwalker@163.com" target="_blank" rel="noopener">waitwalker@163.com</a>）。为了保证问题能够及时有效地处理，请务必提交真实有效、完整清晰的材料，否则不予受理。请使用以下格式（包括各条款的序号）：<br>A、权利人对涉嫌侵权内容拥有商标权、著作权和/或其他依法可以行使权利的权属证明；如果举报人非权利人，请举报人提供代表企业进行举报的书面授权证明。<br>B、充分、明确地描述侵犯了权利人合法权益的内容，提供涉嫌侵权内容在狗圈儿上的具体页面地址，指明涉嫌侵权内容中的哪些内容侵犯了上述列明的权利人的合法权益；<br>C、权利人具体的联络信息，包括姓名、身份证或护照复印件（对自然人）、单位登记证明复印件（对单位）、通信地址、电话号码、传真和电子邮件；<br>D、在侵权举报中加入如下关于举报内容真实性的声明：<br>· 我本人为所举报内容的合法权利人；<br>· 我举报的发布在狗圈儿中的内容侵犯了本人相应的合法权益；<br>· 如果本侵权举报内容不完全属实，本人将承担由此产生的一切法律责任。<br>4、处理流程<br>出于网络社区的监督属性，并非所有申请都必须受理。狗圈儿自收到举报邮件七个工作日内处理完毕并给出回复。处理期间，不提供任何电话、邮件及其他方式的查询服务。<br>出现狗圈儿已经删除或处理的内容，但是百度、谷歌等搜索引擎依然可以搜索到的现象，是因为百度、谷歌等搜索引擎自带缓存，此类问题狗圈儿无权也无法处理，因此相关申请不予受理。<br>此为狗圈儿唯一的官方的侵权投诉渠道，暂不提供其他方式处理此业务。用户在狗圈儿中的商业行为引发的法律纠纷，由交易双方自行处理，与狗圈儿无关。<br>服务终止及暂停<br>任何引起其他用户反感的行为，包括但不限于利用狗圈儿平台发布广告或是垃圾信息，利用简信骚扰其他用户等，网站可随时行使暂停、收回、删除帐号的权利。</p><p>1、用户在狗圈儿发表的内容仅表明其个人的立场和观点，并不代表狗圈儿的立场或观点。作为内容的发表者，需自行对所发表内容负责，因所发表内容引发的一切纠纷，由该内容的发表者承担全部法律及连带责任。狗圈儿不承担任何法律及连带责任。<br>2、狗圈儿不保证网络服务一定能满足用户的要求，也不保证网络服务不会中断，对网络服务的及时性、安全性、准确性也都不作保证。<br>3、对于因不可抗力或狗圈儿不能控制的原因造成的网络服务中断或其它缺陷，狗圈儿不承担任何责任，但将尽力减少因此而给用户造成的损失和影响。</p><h3 id="协议修改"><a href="#协议修改" class="headerlink" title="协议修改"></a><strong>协议修改</strong></h3><p>1、根据互联网的发展和有关法律、法规及规范性文件的变化，或者因业务发展需要，狗圈儿有权对本协议的条款作出修改或变更，一旦本协议的内容发生变动，狗圈儿将会直接在狗圈儿网站上公布修改之后的协议内容，该公布行为视为狗圈儿已经通知用户修改内容。狗圈儿也可采用电子邮件或私信的传送方式，提示用户协议条款的修改、服务变更、或其它重要事项。<br>2、如果不同意狗圈儿对本协议相关条款所做的修改，用户有权并应当停止使用狗圈儿。如果用户继续使用狗圈儿，则视为用户接受狗圈儿对本协议相关条款所做的修改。</p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 狗圈儿隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bedrock Privacy Policy</title>
      <link href="/2019/04/13/Bedrock-Privacy-Policy/"/>
      <url>/2019/04/13/Bedrock-Privacy-Policy/</url>
      
        <content type="html"><![CDATA[<p><font size="3"><strong>1.我们尊重用户的隐私并对非法窃取用户隐私的行为予以坚决抵制.</strong></font></p><p><font size="3">We respect user privacy and resist those who illegally steal user privacy.</font><br><br></p><p><font size="3"><strong>2.Bedrock 仅收集用户数据以便高效运营，以及为您提供最佳的产品体验。 您的节点信息只会保存在本地,Bedrock 不会收集更不会上传这些信息.</strong></font></p><p><font size="3">Bedrock only collects user data to operate effectively and provide you the best experiences with our products.</font><br><br></p><p><font size="3"><strong>3.您的个人隐私和网络访问数据仅会存储在本地,从基础做起,我们会一步一步来完善功能,将来您可以把个人信息存到iCloud.</strong></font></p><p><font size="3">Your personal data and network request data will only be stored locally. Getting down to basics,we will improve our functions step by step. In the future, the function will be perfected, and you may save your personal information to iCloud.</font><br></p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bedrock隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method解读</title>
      <link href="/2019/04/12/Method%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/12/Method%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道iOS程序的入口函数在main.其实mian只是苹果给我们的”直观能够感受”的入口,在执行main之前,编译器已经帮我们做了相当多的事情.具体可以参考objc-os.h文件.Objective-C的Runtime库也是在main之前创建好的.我们关注sel_init()</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL:"></a>SEL:</h3><pre><code>/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void){    static bool initialized = false;    if (initialized) return;    initialized = true;    // fixme defer initialization until an objc-using image is found?    environ_init();    tls_init();    static_init();    lock_init();    exception_init();    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);}</code></pre><p>接口我们可以到sel_init()调用栈:</p><pre><code>_|   _objc_init()  _|   _dyld_objc_notify_register    _|    map_images_nolock()       _|   sel_init()</code></pre><p>在map_images_nolock()方法中我们看到在sel_init()下面有arr_init():</p><pre><code>void arr_init(void){    AutoreleasePoolPage::init();    SideTableInit();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数就是我们熟悉的AutoreleasePoolPage的初始化和全局SideTable的初始化,这个以后再分析.这里我们看一下sel_init()所做的工作:</p><pre><code>/************************************************************************ sel_init* Initialize selector tables and register selectors used internally.**********************************************************************/void sel_init(size_t selrefCount){    // save this value for later    SelrefCount = selrefCount;#if SUPPORT_PREOPT    builtins = preoptimizedSelectors();    if (PrintPreopt  &amp;&amp;  builtins) {        uint32_t occupied = builtins-&gt;occupied;        uint32_t capacity = builtins-&gt;capacity;        _objc_inform(&quot;PREOPTIMIZATION: using selopt at %p&quot;, builtins);        _objc_inform(&quot;PREOPTIMIZATION: %u selectors&quot;, occupied);        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%u%%) hash table occupancy&quot;,                     occupied, capacity,                     (unsigned)(occupied/(double)capacity*100));        }#endif    // Register selectors used by libobjc#define s(x) SEL_##x = sel_registerNameNoLock(#x, NO)#define t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO)    mutex_locker_t lock(selLock);    s(load);    s(initialize);    t(resolveInstanceMethod:, resolveInstanceMethod);    t(resolveClassMethod:, resolveClassMethod);    t(.cxx_construct, cxx_construct);    t(.cxx_destruct, cxx_destruct);    s(retain);    s(release);    s(autorelease);    s(retainCount);    s(alloc);    t(allocWithZone:, allocWithZone);    s(dealloc);    s(copy);    s(new);    t(forwardInvocation:, forwardInvocation);    t(_tryRetain, tryRetain);    t(_isDeallocating, isDeallocating);    s(retainWeakReference);    s(allowsWeakReference);#undef s#undef t}</code></pre><p>我们可以看到一些常见系统内置方法分别调用__sel_registerName()这个方法:</p><pre><code>static SEL __sel_registerName(const char *name, bool shouldLock, bool copy){    SEL result = 0;    if (shouldLock) selLock.assertUnlocked();    else selLock.assertLocked();    if (!name) return (SEL)0;    result = search_builtins(name);    if (result) return result;    conditional_mutex_locker_t lock(selLock, shouldLock);    if (namedSelectors) {        result = (SEL)NXMapGet(namedSelectors, name);    }    if (result) return result;    // No match. Insert.    if (!namedSelectors) {        namedSelectors = NXCreateMapTable(NXStrValueMapPrototype,                                          (unsigned)SelrefCount);    }    if (!result) {        // 初始化sel_alloc        result = sel_alloc(name, copy);        // 将selector 插入到NXMapTable 表中        // fixme choose a better container (hash not map for starters)        NXMapInsert(namedSelectors, sel_getName(result), result);    }    return result;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这方法的作用是将selector注册到NXMapTable表中,如果selector不存在则调用selector初始化方法,然后将selector作为selector作为key,selector作为value存到NXMapTable哈希表中:</p><pre><code>static SEL sel_alloc(const char *name, bool copy){    selLock.assertLocked();    return (SEL)(copy ? strdupIfMutable(name) : name);}</code></pre><p>在objc.h文件中我们可以看到SEL的声明:</p><pre><code>/// An opaque type that represents a method selector.typedef struct objc_selector *SEL;</code></pre><p>至此我们可以理解了,SEL就是一个表示方法的selector指针,映射方法的名字.</p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP:"></a>IMP:</h3><pre><code>/// A pointer to the function of a method implementation.#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ );#elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);#endif</code></pre><p>从定义来看,IMP是一个指向实现函数的<strong>指针</strong>.IMP也是实现函数的入口,其和SEL的关系等以后将消息发送在细说.</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method:"></a>Method:</h3><p>method的声明结构:</p><pre><code>typedef struct method_t *Method;</code></pre><p>继续查看method_t的定义:</p><pre><code>struct method_t {    SEL name;    const char *types;    MethodListIMP imp;    struct SortBySELAddress :        public std::binary_function&lt;const method_t&amp;,                                    const method_t&amp;, bool&gt;    {        bool operator() (const method_t&amp; lhs,                         const method_t&amp; rhs)        { return lhs.name &lt; rhs.name; }    };};</code></pre><p>method_t中有两个我们熟悉的成员变量:SEL和MethodListIMP,看一下MethodListIMP:</p><pre><code>#if __has_feature(ptrauth_calls)// Method lists use process-independent signature for compatibility.// Method caches use process-dependent signature for extra protection.//   (fixme not yet __ptrauth(...) because of `stp` inline asm in objc-cache.mm)using MethodListIMP = IMP __ptrauth_objc_method_list_imp;using MethodCacheIMP =    StorageSignedFunctionPointer&lt;IMP, ptrauth_key_process_dependent_code&gt;;#elseusing MethodListIMP = IMP;using MethodCacheIMP = IMP;#endif</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodListIMP其实就是IMP,method可以理解为SEL(方法名称)和IMP(方法实现)相互对应的集合体.正常的情况一个SEL对应一个IMP,而SEL和IMP的绑定到运行时才确定的.</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是NSObject.h和runtime.h文件为我们提供的有关SEL,IMP和Method相关的接口及说明:</p><h4 id="runtime-h文件"><a href="#runtime-h文件" class="headerlink" title="runtime.h文件:"></a>runtime.h文件:</h4><h5 id="根据SEL获取实例Method指针"><a href="#根据SEL获取实例Method指针" class="headerlink" title="根据SEL获取实例Method指针"></a>根据SEL获取实例Method指针</h5><pre><code>// 获取Method声明OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// 获取Method实现/************************************************************************ class_getInstanceMethod.  Return the instance method for the* specified class and selector.**********************************************************************/Method class_getInstanceMethod(Class cls, SEL sel){    if (!cls  ||  !sel) return nil;    // This deliberately avoids +initialize because it historically did so.    // This implementation is a bit weird because it&#39;s the only place that    // wants a Method instead of an IMP.#warning fixme build and search caches    // Search method lists, try method resolver, etc.    lookUpImpOrNil(cls, sel, nil,                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);#warning fixme build and search caches    return _class_getMethod(cls, sel);}</code></pre><p>这里面调用了_class_getMethod()私有函数:</p><pre><code>/************************************************************************ _class_getMethod* fixme* Locking: read-locks runtimeLock**********************************************************************/static Method _class_getMethod(Class cls, SEL sel){    mutex_locker_t lock(runtimeLock);    return getMethod_nolock(cls, sel);}/************************************************************************ getMethod_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *getMethod_nolock(Class cls, SEL sel){    method_t *m = nil;    runtimeLock.assertLocked();    // fixme nil cls?    // fixme nil sel?    assert(cls-&gt;isRealized());    while (cls  &amp;&amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {        cls = cls-&gt;superclass;    }    return m;}</code></pre><p>这个函数内部调用的是getMethodNoSuper_nolock():</p><pre><code>static method_t *getMethodNoSuper_nolock(Class cls, SEL sel){    runtimeLock.assertLocked();    assert(cls-&gt;isRealized());    // fixme nil cls?    // fixme nil sel?    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),              end = cls-&gt;data()-&gt;methods.endLists();         mlists != end;         ++mlists)    {        method_t *m = search_method_list(*mlists, sel);        if (m) return m;    }    return nil;}</code></pre><p>查找方法的过程是先从本class的方法列表中查看是否存在,不存再在看父类递归这个过程( cls = cls-&gt;superclass).这个我们在以后讲消息发送,转发时在细看.</p><h5 id="根据SEL获取类Method指针"><a href="#根据SEL获取类Method指针" class="headerlink" title="根据SEL获取类Method指针"></a>根据SEL获取类Method指针</h5><pre><code>OBJC_EXPORT Method _Nullableclass_getClassMethod(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</code></pre><p>类对象的方法列表存放在元类中,所以获取类方法要去元类中查找,其在获取的时候参数已经指明元类:</p><pre><code>/************************************************************************ class_getClassMethod.  Return the class method for the specified* class and selector.**********************************************************************/Method class_getClassMethod(Class cls, SEL sel){    if (!cls  ||  !sel) return nil;    //这里cls获取的是元类    return class_getInstanceMethod(cls-&gt;getMeta(), sel);}</code></pre><h5 id="返回一个函数的实现指针"><a href="#返回一个函数的实现指针" class="headerlink" title="返回一个函数的实现指针:"></a>返回一个函数的实现指针:</h5><pre><code>OBJC_EXPORT IMP _Nullableclass_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</code></pre><p>其实现过程:</p><pre><code>IMP class_getMethodImplementation(Class cls, SEL sel){    IMP imp;    if (!cls  ||  !sel) return nil;    imp = lookUpImpOrNil(cls, sel, nil,                         YES/*initialize*/, YES/*cache*/, YES/*resolver*/);    // Translate forwarding function to C-callable external version    if (!imp) {        return _objc_msgForward;    }    return imp;}</code></pre><p>其内部我们可以看到两个主要的调用函数:lookUpImpOrNil()和_objc_msgForward.前面函数是获取SEL对应的IMP,其实现过程如下:</p><pre><code>/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst,                   bool initialize, bool cache, bool resolver){    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);    if (imp == _objc_msgForward_impcache) return nil;    else return imp;}// MARK: - 获取imp,先从缓存中查找imp,如果存在直接返回imp./************************************************************************ lookUpImpOrForward.* The standard IMP lookup.* initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known.*   If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use*   must be converted to _objc_msgForward or _objc_msgForward_stret.*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst,                       bool initialize, bool cache, bool resolver){    IMP imp = nil;    bool triedResolver = NO;    runtimeLock.assertUnlocked();    // Optimistic cache lookup    if (cache) {        imp = cache_getImp(cls, sel);        if (imp) return imp;    }    // runtimeLock is held during isRealized and isInitialized checking    // to prevent races against concurrent realization.    // runtimeLock is held during method search to make    // method-lookup + cache-fill atomic with respect to method addition.    // Otherwise, a category could be added but ignored indefinitely because    // the cache was re-filled with the old value after the cache flush on    // behalf of the category.    runtimeLock.lock();    checkIsKnownClass(cls);    if (!cls-&gt;isRealized()) {        realizeClass(cls);    }    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {        runtimeLock.unlock();        _class_initialize (_class_getNonMetaClass(cls, inst));        runtimeLock.lock();        // If sel == initialize, _class_initialize will send +initialize and        // then the messenger will send +initialize again after this        // procedure finishes. Of course, if this is not being called        // from the messenger then it won&#39;t happen. 2778172    } retry:    runtimeLock.assertLocked();    // 从缓存中尝试查找IMP    // Try this class&#39;s cache.    imp = cache_getImp(cls, sel);    if (imp) goto done;    // 从本类的方法列表中尝试查找IMP    // Try this class&#39;s method lists.    {        Method meth = getMethodNoSuper_nolock(cls, sel);        if (meth) {            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);            imp = meth-&gt;imp;            goto done;        }    }    // 从父类的方法列表中尝试查找IMP    // Try superclass caches and method lists.    {        unsigned attempts = unreasonableClassCount();        for (Class curClass = cls-&gt;superclass;             curClass != nil;             curClass = curClass-&gt;superclass)        {            // Halt if there is a cycle in the superclass chain.            if (--attempts == 0) {                _objc_fatal(&quot;Memory corruption in class list.&quot;);            }            // Superclass cache.            imp = cache_getImp(curClass, sel);            if (imp) {                if (imp != (IMP)_objc_msgForward_impcache) {                    // Found the method in a superclass. Cache it in this class.                    log_and_fill_cache(cls, imp, sel, inst, curClass);                    goto done;                }                else {                    // Found a forward:: entry in a superclass.                    // Stop searching, but don&#39;t cache yet; call method                    // resolver for this class first.                    break;                }            }            // Superclass method list.            Method meth = getMethodNoSuper_nolock(curClass, sel);            if (meth) {                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);                imp = meth-&gt;imp;                goto done;            }        }    }    // 如果以上过程都没有找到,尝试一次动态方法解析    // No implementation found. Try method resolver once.    if (resolver  &amp;&amp;  !triedResolver) {        runtimeLock.unlock();        _class_resolveMethod(cls, sel, inst);        runtimeLock.lock();        // Don&#39;t cache the result; we don&#39;t hold the lock so it may have        // changed already. Re-do the search from scratch instead.        triedResolver = YES;        goto retry;    }    // 如果方法解析也没有IMP,启动消息转发    // No implementation found, and method resolver didn&#39;t help.    // Use forwarding.    imp = (IMP)_objc_msgForward_impcache;    cache_fill(cls, sel, imp, inst); done:    runtimeLock.unlock();    return imp;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据SEL在缓存中如果没有找到IMP,则在本类的Method获取找IMP,如果没有找到去父类中查找.以上过程都没有找到IMP的话,启动一次方法解析,方法解析也没有IMP的话就启动消息转发.</p><h5 id="一个对象是否响应某个方法"><a href="#一个对象是否响应某个方法" class="headerlink" title="一个对象是否响应某个方法"></a>一个对象是否响应某个方法</h5><pre><code>// MARK: - 一个实例对象是否响应某个方法/** * Returns a Boolean value that indicates whether instances of a class respond to a particular selector. * * @param cls The class you want to inspect. * @param sel A selector. * * @return \c YES if instances of the class respond to the selector, otherwise \c NO. * * @note You should usually use \c NSObject&#39;s \c respondsToSelector: or \c instancesRespondToSelector: *  methods instead of this function. */OBJC_EXPORT BOOLclass_respondsToSelector(Class _Nullable cls, SEL _Nonnull sel)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 是否响应某个方法BOOL class_respondsToSelector(Class cls, SEL sel){    return class_respondsToSelector_inst(cls, sel, nil);}// MARK: - 是否响应某个方法,其内部是通过获取IMP是否存在来判断// inst is an instance of cls or a subclass thereof, or nil if none is known.// Non-nil inst is faster in some cases. See lookUpImpOrForward() for details.bool class_respondsToSelector_inst(Class cls, SEL sel, id inst){    IMP imp;    if (!sel  ||  !cls) return NO;    // Avoids +initialize because it historically did so.    // We&#39;re not returning a callable IMP anyway.    imp = lookUpImpOrNil(cls, sel, inst,                         NO/*initialize*/, YES/*cache*/, YES/*resolver*/);    return bool(imp);}</code></pre><p>其最终还是痛SEL是否有对应IMP来判断对象能否响应某个方法.</p><h5 id="获取一个类的方法列表"><a href="#获取一个类的方法列表" class="headerlink" title="获取一个类的方法列表"></a>获取一个类的方法列表</h5><pre><code>// MARK: - 获取一个类的方法列表/** * Describes the instance methods implemented by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. *  If outCount is NULL, the length is not returned. * * @return An array of pointers of type Method describing the instance methods *  implemented by the class—any instance methods implemented by superclasses are not included. *  The array contains *outCount pointers followed by a NULL terminator. You must free the array with free(). * *  If cls implements no instance methods, or cls is Nil, returns NULL and *outCount is 0. * * @note To get the class methods of a class, use \c class_copyMethodList(object_getClass(cls), &amp;count). * @note To get the implementations of methods that may be implemented by superclasses, *  use \c class_getInstanceMethod or \c class_getClassMethod. */OBJC_EXPORT Method _Nonnull * _Nullableclass_copyMethodList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个类所有实现的方法列表/************************************************************************ class_copyMethodList* fixme* Locking: read-locks runtimeLock**********************************************************************/Method *class_copyMethodList(Class cls, unsigned int *outCount){    unsigned int count = 0;    Method *result = nil;    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    count = cls-&gt;data()-&gt;methods.count();    if (count &gt; 0) {        result = (Method *)malloc((count + 1) * sizeof(Method));        count = 0;        for (auto&amp; meth : cls-&gt;data()-&gt;methods) {            result[count++] = &amp;meth;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return result;}</code></pre><h5 id="获取一个方法名称"><a href="#获取一个方法名称" class="headerlink" title="获取一个方法名称"></a>获取一个方法名称</h5><pre><code>// MARK: - 获取一个方法名称/** * Returns the name of a method. * * @param m The method to inspect. * * @return A pointer of type SEL. * * @note To get the method name as a C string, call \c sel_getName(method_getName(method)). */OBJC_EXPORT SEL _Nonnullmethod_getName(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法名称/************************************************************************ method_getName* Returns this method&#39;s selector.* The method must not be nil.* The method must already have been fixed-up.* Locking: none**********************************************************************/SELmethod_getName(Method m){    if (!m) return nil;    assert(m-&gt;name == sel_registerName(sel_getName(m-&gt;name)));    return m-&gt;name;}</code></pre><p>获取一个方法名字最终还是通过sel_registerName()来获取,也是我们最开始的部分sel_init()提到.</p><h5 id="获取一个方法的IMP"><a href="#获取一个方法的IMP" class="headerlink" title="获取一个方法的IMP"></a>获取一个方法的IMP</h5><pre><code>// MARK: - 获取一个方法的实现/** * Returns the implementation of a method. * * @param m The method to inspect. * * @return A function pointer of type IMP. */OBJC_EXPORT IMP _Nonnullmethod_getImplementation(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的IMPIMPmethod_getImplementation(Method m){    return m ? m-&gt;imp : nil;}</code></pre><p>通过直接Method中的imp成员变量</p><h5 id="获取一个方法的参数和返回值类型"><a href="#获取一个方法的参数和返回值类型" class="headerlink" title="获取一个方法的参数和返回值类型"></a>获取一个方法的参数和返回值类型</h5><pre><code>// MARK: - 获取一个方法的参数和返回值类型/** * Returns a string describing a method&#39;s parameter and return types. * * @param m The method to inspect. * * @return A C string. The string may be \c NULL. */OBJC_EXPORT const char * _Nullablemethod_getTypeEncoding(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的参数和返回值类型/************************************************************************ method_getTypeEncoding* Returns this method&#39;s old-style type encoding string.* The method must not be nil.* Locking: none**********************************************************************/const char *method_getTypeEncoding(Method m){    if (!m) return nil;    return m-&gt;types;}</code></pre><h5 id="获取一个方法的参数数量"><a href="#获取一个方法的参数数量" class="headerlink" title="获取一个方法的参数数量"></a>获取一个方法的参数数量</h5><pre><code>// MARK: - 获取一个方法参数数量/** * Returns the number of arguments accepted by a method. * * @param m A pointer to a \c Method data structure. Pass the method in question. * * @return An integer containing the number of arguments accepted by the given method. */OBJC_EXPORT unsigned intmethod_getNumberOfArguments(Method _Nonnull m)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的参数数量/************************************************************************ method_getNumberOfArguments.**********************************************************************/unsigned int method_getNumberOfArguments(Method m){    if (!m) return 0;    return encoding_getNumberOfArguments(method_getTypeEncoding(m));}</code></pre><h5 id="获取一个方法的返回值类型"><a href="#获取一个方法的返回值类型" class="headerlink" title="获取一个方法的返回值类型"></a>获取一个方法的返回值类型</h5><pre><code>// MARK: - 获取一个方法的返回值类型/** * Returns a string describing a method&#39;s return type. * * @param m The method to inspect. * * @return A C string describing the return type. You must free the string with \c free(). */OBJC_EXPORT char * _Nonnullmethod_copyReturnType(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法的返回值类型char * method_copyReturnType(Method m){    return encoding_copyReturnType(method_getTypeEncoding(m));}</code></pre><h5 id="获取方法某个参数的类型"><a href="#获取方法某个参数的类型" class="headerlink" title="获取方法某个参数的类型"></a>获取方法某个参数的类型</h5><pre><code>// MARK: - 获取方法某个参数的类型/** * Returns a string describing a single parameter type of a method. * * @param m The method to inspect. * @param index The index of the parameter to inspect. * * @return A C string describing the type of the parameter at index \e index, or \c NULL *  if method has no parameter index \e index. You must free the string with \c free(). */OBJC_EXPORT char * _Nullablemethod_copyArgumentType(Method _Nonnull m, unsigned int index)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法某个参数类型char * method_copyArgumentType(Method m, unsigned int index){    return encoding_copyArgumentType(method_getTypeEncoding(m), index);}</code></pre><h5 id="获取方法返回值类型"><a href="#获取方法返回值类型" class="headerlink" title="获取方法返回值类型"></a>获取方法返回值类型</h5><pre><code>// MARK: - 获取方法返回值类型/** * Returns by reference a string describing a method&#39;s return type. * * @param m The method you want to inquire about. * @param dst The reference string to store the description. * @param dst_len The maximum number of characters that can be stored in \e dst. * * @note The method&#39;s return type string is copied to \e dst. *  \e dst is filled as if \c strncpy(dst, parameter_type, dst_len) were called. */OBJC_EXPORT voidmethod_getReturnType(Method _Nonnull m, char * _Nonnull dst, size_t dst_len)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法返回值类型void method_getReturnType(Method m, char *dst, size_t dst_len){    encoding_getReturnType(method_getTypeEncoding(m), dst, dst_len);}</code></pre><h5 id="更新设置某个方法的IMP"><a href="#更新设置某个方法的IMP" class="headerlink" title="更新设置某个方法的IMP"></a>更新设置某个方法的IMP</h5><pre><code>// MARK: - 更新设置某个方法的IMP/** * Sets the implementation of a method. * * @param m The method for which to set an implementation. * @param imp The implemention to set to this method. * * @return The previous implementation of the method. */OBJC_EXPORT IMP _Nonnullmethod_setImplementation(Method _Nonnull m, IMP _Nonnull imp)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 更新设置某个方法IMPIMPmethod_setImplementation(Method m, IMP imp){    // Don&#39;t know the class - will be slow if RR/AWZ are affected    // fixme build list of classes whose Methods are known externally?    mutex_locker_t lock(runtimeLock);    return _method_setImplementation(Nil, m, imp);}// MARK: - 更新设置某个方法的IMP/************************************************************************ method_setImplementation* Sets this method&#39;s implementation to imp.* The previous implementation is returned.**********************************************************************/static IMP_method_setImplementation(Class cls, method_t *m, IMP imp){    runtimeLock.assertLocked();    if (!m) return nil;    if (!imp) return nil;    IMP old = m-&gt;imp;    m-&gt;imp = imp;    // Cache updates are slow if cls is nil (i.e. unknown)    // RR/AWZ updates are slow if cls is nil (i.e. unknown)    // fixme build list of classes whose Methods are known externally?    flushCaches(cls);    updateCustomRR_AWZ(cls, m);    return old;}</code></pre><p>先找到old imp,然后把old imp 替换成 new imp.</p><h5 id="交换两个方法的实现即交换两个方法的IMP"><a href="#交换两个方法的实现即交换两个方法的IMP" class="headerlink" title="交换两个方法的实现即交换两个方法的IMP"></a>交换两个方法的实现即交换两个方法的IMP</h5><pre><code>// MARK: - 交换两个方法的实现即交换两个方法的IMP/** * Exchanges the implementations of two methods. * * @param m1 Method to exchange with second method. * @param m2 Method to exchange with first method. * * @note This is an atomic version of the following: *  \code *  IMP imp1 = method_getImplementation(m1); *  IMP imp2 = method_getImplementation(m2); *  method_setImplementation(m1, imp2); *  method_setImplementation(m2, imp1); *  \endcode */OBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 交换两个方法的实现即交换两个方法的IMPvoid method_exchangeImplementations(Method m1, Method m2){    if (!m1  ||  !m2) return;    mutex_locker_t lock(runtimeLock);    IMP m1_imp = m1-&gt;imp;    m1-&gt;imp = m2-&gt;imp;    m2-&gt;imp = m1_imp;    // RR/AWZ updates are slow because class is unknown    // Cache updates are slow because class is unknown    // fixme build list of classes whose Methods are known externally?    flushCaches(nil);    updateCustomRR_AWZ(nil, m1);    updateCustomRR_AWZ(nil, m2);}</code></pre><h4 id="NSObject-h文件"><a href="#NSObject-h文件" class="headerlink" title="NSObject.h文件"></a>NSObject.h文件</h4><h5 id="执行某个方法"><a href="#执行某个方法" class="headerlink" title="执行某个方法"></a>执行某个方法</h5><p>执行某个方法,一般用于方法解析中动态添加方法,下面这几个方法功能类似:</p><pre><code>// MARK: - 执行某个方法 一般用于方法解析中动态添加方法- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;// MARK: -  执行某个方法 一般用于方法解析中动态添加方法- (id)performSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL))objc_msgSend)(self, sel);}- (id)performSelector:(SEL)sel withObject:(id)obj {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);}- (id)performSelector:(SEL)sel withObject:(id)obj1 withObject:(id)obj2 {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL, id, id))objc_msgSend)(self, sel, obj1, obj2);}</code></pre><p>先判断这个方法是否存在doesNotRecognizeSelector(),不存在报错”unrecognized selector sent to instance”.然后调用了message.h中的消息发送函数.</p><h5 id="内省方法-是否响应某个方法"><a href="#内省方法-是否响应某个方法" class="headerlink" title="内省方法:是否响应某个方法"></a>内省方法:是否响应某个方法</h5><pre><code>// MARK: - 内省方法:是否响应某个方法- (BOOL)respondsToSelector:(SEL)aSelector;// MARK: - 是否响应某个方法- (BOOL)respondsToSelector:(SEL)sel {    if (!sel) return NO;    return class_respondsToSelector_inst([self class], sel, self);}// MARK: - 是否响应某个方法,其内部是通过获取IMP是否存在来判断// inst is an instance of cls or a subclass thereof, or nil if none is known.// Non-nil inst is faster in some cases. See lookUpImpOrForward() for details.bool class_respondsToSelector_inst(Class cls, SEL sel, id inst){    IMP imp;    if (!sel  ||  !cls) return NO;    // Avoids +initialize because it historically did so.    // We&#39;re not returning a callable IMP anyway.    imp = lookUpImpOrNil(cls, sel, inst,                         NO/*initialize*/, YES/*cache*/, YES/*resolver*/);    return bool(imp);}</code></pre><h5 id="一个实例对象是否响应某个方法"><a href="#一个实例对象是否响应某个方法" class="headerlink" title="一个实例对象是否响应某个方法"></a>一个实例对象是否响应某个方法</h5><pre><code>// MARK: - 一个对象是否响应某个方法+ (BOOL)instancesRespondToSelector:(SEL)aSelector;// MARK: - 一个对象是否响应某个方法+ (BOOL)instancesRespondToSelector:(SEL)sel {    if (!sel) return NO;    return class_respondsToSelector(self, sel);}</code></pre><h5 id="获取一个SEL对应的IMP"><a href="#获取一个SEL对应的IMP" class="headerlink" title="获取一个SEL对应的IMP"></a>获取一个SEL对应的IMP</h5><pre><code>// MARK: - 获取一个SEL对应的IMP- (IMP)methodForSelector:(SEL)aSelector;// MARK: - 获取一个SEL对应的IMP- (IMP)methodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return object_getMethodImplementation(self, sel);}</code></pre><h5 id="获取一个实例方法SEL对应的IMP"><a href="#获取一个实例方法SEL对应的IMP" class="headerlink" title="获取一个实例方法SEL对应的IMP"></a>获取一个实例方法SEL对应的IMP</h5><pre><code>// MARK: - 获取一个实例方法SEL对应的IMP+ (IMP)instanceMethodForSelector:(SEL)aSelector;// MARK: - 获取一个实例方法SEL对应的IMP+ (IMP)instanceMethodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return class_getMethodImplementation(self, sel);}</code></pre><h5 id="不能响应某个SEL"><a href="#不能响应某个SEL" class="headerlink" title="不能响应某个SEL"></a>不能响应某个SEL</h5><pre><code>// MARK: - 不能响应某个SEL,报错- (void)doesNotRecognizeSelector:(SEL)aSelector;// MARK: - 不能响应某个方法// Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel {    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;,                object_getClassName(self), sel_getName(sel), self);}</code></pre><h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>动态方法解析,一般用来给某个没有实现的方法添加一个实现;返回false时,执行消息转发流程</p><pre><code>// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel {    return NO;}+ (BOOL)resolveInstanceMethod:(SEL)sel {    return NO;}</code></pre><h5 id="消息转发相关"><a href="#消息转发相关" class="headerlink" title="消息转发相关"></a>消息转发相关</h5><pre><code>// MARK: - 消息转发相关- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍了SEL,IMP,Method的定义和实现,以及系统为我们提供的常用API.这里面涉及到到向一个对象发送消息的流程及转发过程,这个会在以后的章节中讲到.<br><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a></strong>,里面有相关阅读注释.</p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2019/04/11/%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/11/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>像栈一样,队列(queue)也是表.队列的操作操两端进行,一端插入,一端删除.</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><h4 id="入队-Enqueue-操作"><a href="#入队-Enqueue-操作" class="headerlink" title="入队(Enqueue)操作"></a>入队(Enqueue)操作</h4><p>入队是在队列的末尾插入元素.</p><h4 id="出队-Dequeue-操作"><a href="#出队-Dequeue-操作" class="headerlink" title="出队(Dequeue)操作"></a>出队(Dequeue)操作</h4><p>出队是移除队列的首元素.<br><img src="http://abc.waitwalker.cn/queue.jpg" alt="队列"></p><h3 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h3><p>队列的实现也相对简单,这里我们直接用数组来实现.</p><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><pre><code>// MARK: - 队列struct Queue&lt;T&gt; {    private(set) var elements:[T] = []    // MARK: - 构造函数    init() {    }}</code></pre><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h4><p>入队操作在数组的末尾插入元素</p><pre><code>/// enqueue操作    ///    /// - Parameter element: 入队元素    mutating func enqueue(element:T) -&gt; Void {        elements.append(element)    }</code></pre><h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p>出队操作移除数组的首元素</p><pre><code>/// dequeue操作    mutating func dequeue() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeFirst()    }</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2019/04/11/%E6%A0%88/"/>
      <url>/2019/04/11/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈(stack)是限制插入和删除只能在一端进行的表,该位置称为栈顶(top).对栈的基本操作有Push(压栈)和Pop(出栈).前者相当于插入,后者相当于删除栈顶元素.栈又叫做LIFO(后进先出)表.只有栈顶元素是可访问的<br><img src="http://abc.waitwalker.cn/stack.jpg" alt="stack"></p><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于栈是一个表,因此任何实现表的方法都能实现栈,其中有两个比较常用的实现方法:1)栈的链表实现;2)栈的数组实现</p><h4 id="1-栈的链表实现"><a href="#1-栈的链表实现" class="headerlink" title="1.栈的链表实现"></a>1.栈的链表实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈可以用单链表来实现,在栈顶插入元素来实现Push操作,通过对栈顶元素移除来实现Pop操作.</p><h5 id="1-1-栈的链表定义"><a href="#1-1-栈的链表定义" class="headerlink" title="1.1 栈的链表定义"></a>1.1 栈的链表定义</h5><pre><code>private(set) var nodeList:NodeList&lt;T&gt;?    // 是否为空    var isEmpty:Bool {        get {            return nodeList == nil ? true : false        }    }    // MARK: - 构造方法    init() {    }</code></pre><h5 id="1-2-push-压栈操作"><a href="#1-2-push-压栈操作" class="headerlink" title="1.2 push()压栈操作"></a>1.2 push()压栈操作</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为主要基于单链表来实现,所以压栈操作首先判断链表是否为空,为空先创建一个链表元素并将首元素添加到链表中;如果不为空,获取链表的最后一个节点,将最后一个节点的next指针指向压栈元素节点.</p><pre><code>/// 压栈操作    ///    /// - Parameter element: 压栈元素    func push(element:T) -&gt; Void {        if let node = nodeList {            let nodeLength = node.traverse(with: node)            let newNode = NodeList(val: element)            let lastNode = node.find(with: node, at: nodeLength - 1)            lastNode?.next = newNode        } else {            nodeList = NodeList(val: element)        }    }</code></pre><h5 id="1-3-top栈顶元素"><a href="#1-3-top栈顶元素" class="headerlink" title="1.3 top栈顶元素"></a>1.3 top栈顶元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取栈顶元素也就是获取链表的最后一个节点</p><pre><code>/// 获取栈顶元素    ///    /// - Returns: 栈顶元素    func top() -&gt; T? {        guard let nodeL = nodeList else { return nil }        let nodeLength = nodeL.traverse(with: nodeL)        if nodeLength &gt; 1 {            return nodeL.find(with: nodeL, at: nodeLength - 1)?.value        } else {            return nodeL.value        }    }</code></pre><h5 id="1-4-pop-移除栈顶元素"><a href="#1-4-pop-移除栈顶元素" class="headerlink" title="1.4 pop()移除栈顶元素"></a>1.4 pop()移除栈顶元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop操作判断链表长度是否大于1,大于1移除链表最后一个节点.</p><pre><code>/// 获取栈顶元素    ///    /// - Returns: 栈顶元素    func top() -&gt; T? {        guard let nodeL = nodeList else { return nil }        let nodeLength = nodeL.traverse(with: nodeL)        if nodeLength &gt; 1 {            return nodeL.find(with: nodeL, at: nodeLength - 1)?.value        } else {            return nodeL.value        }    }</code></pre><h4 id="2-栈的数组实现"><a href="#2-栈的数组实现" class="headerlink" title="2.栈的数组实现"></a>2.栈的数组实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组实现栈相对简单,Array已经帮我们实现了相关接口,不用自己去实现.这里不再详述了,直接贴出源码.</p><pre><code>// MARK: - 栈的数组实现struct StackA&lt;T&gt; {    private(set) var elements:[T] = []    /// isEmpty    var isEmpty:Bool{        get {            return elements.count == 0 ? true : false        }    }    /// top    var top:T? {        get {            return elements.count &gt; 0 ? elements.last : nil        }    }    // MARK: - 构造函数    init() {    }    /// push压栈操作    ///    /// - Parameter element: 压栈元素    mutating func push(element:T) -&gt; Void {        elements.append(element)    }    /// pop出栈操作    mutating func pop() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeLast()    }}</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_mutating</title>
      <link href="/2019/04/11/Swift-mutating/"/>
      <url>/2019/04/11/Swift-mutating/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在swift中:struct,enum,class都可以定义方法和属性.但是struct和enum是值类型,值类型存储在栈区.class是引用类型,引用类型存在在堆区.</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型:"></a>值类型:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平时我们常用的数据类型Int,Double,String,Array,Set等都是用结构体实现的,即也是值类型.当我们赋值或者复制一个值类型时,Swift编译器会复制一个全新的实例,包括它的所有成员属性,每次复制都会产生一个单独的,没有数据共享的新实例.值类型的复制是深拷贝类型.</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型:"></a>引用类型:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用类型是隐式数据共享,复制一个引用类型时,Swift编译器将会复制实例的一个引用,但不包括实例的属性,当对一个引用类型进行多次复制时,每一份复制将共享一份数据,执行的是浅拷贝.</p><pre><code>struct Student {    var name:String = &quot;&quot;    var age:Int = 18    init(name:String, age:Int) {        self.name = name        self.age = age    }}class Teacher {    var name:String = &quot;&quot;    var age:Int = 18    init(name:String, age:Int) {        self.name = name        self.age = age    }}func printAddress(values:AnyObject...){        for value in values {            print(Unmanaged.passUnretained(value).toOpaque())        }        print(&quot;-----------------------------------------&quot;)    }        let stuA = Student(name: &quot;张三&quot;, age: 18)        let stuB = stuA        printAddress(values: stuA.name as AnyObject)        printAddress(values: stuB.name as AnyObject)        let tchA = Teacher(name: &quot;李四&quot;, age: 28)        let tchB = tchA        printAddress(values: tchA)        printAddress(values: tchB)// log:stuA 和 stuB0x000060000387b660-----------------------------------------0x000060000387c1a0-----------------------------------------tchA 和 tchB0x000060000366bcf0-----------------------------------------0x000060000366bcf0-----------------------------------------</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出stuA完全深拷贝了一份给stuB.</p><h3 id="mutating关键字"><a href="#mutating关键字" class="headerlink" title="mutating关键字"></a>mutating关键字</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。如果要在某个function中修改属性的值就必须要在这个function前使用mutating关键词.</p><pre><code>private(set) var elements:[T] = []    /// isEmpty    var isEmpty:Bool{        get {            return elements.count == 0 ? true : false        }    }    /// top    var top:T? {        get {            return elements.count &gt; 0 ? elements.last : nil        }    }    // MARK: - 构造函数    init() {    }    mutating func push(element:T) -&gt; Void {        elements.append(element)    }    mutating func pop() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeLast()    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift开发 </tag>
            
            <tag> mutating </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objc_object解读</title>
      <link href="/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是面向对象的语言.面向对象语言有一句话说:”万物皆对象”,这个”对象”从哪里来呢?下面从Runtime源码实现来进一步查看.</p><h3 id="一-objc-object声明相关"><a href="#一-objc-object声明相关" class="headerlink" title="一. objc_object声明相关"></a>一. objc_object声明相关</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先看runtime.h文件,这个文件相当于Runtime对外部提供的接口文件.包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明.当我们使用Xcode创建一个类的时候一般都是调用的这里.</p><pre><code>/**    Runtime对外提供的接口,包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明 **//* Types */#if !OBJC_TYPES_DEFINED/// 表示一个类中的方法/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// 表示类中的一个成员变量/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// 表示一个分类/// An opaque type that represents a category.typedef struct objc_category *Category;/// 表示一个属性/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;/// 类的声明结构struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>可以看到objc_class的结构声明中有isa指针,这个指针是Class类型,然后我们顺藤摸瓜,继续查找Class的定义来源.然后找到了objc-private.h文件,进入文件后我们看到结构体objc_class和objc_object的不完整声明如下:</p><pre><code>// MARK: - objc_class 和 objc_object 不完整声明struct objc_class;struct objc_object;</code></pre><p>接着是用typedef 将这两个类型取了两个熟悉的名字:Class指针和id指针:</p><pre><code>// MARK: - 将objc_class类型取名为Class指针类型;将objc_object类型取名为id指针类型typedef struct objc_class *Class;typedef struct objc_object *id;</code></pre><p><br><br>往下就是isa的声明union(联合体),isa_t中有两个初始化函数,两个成员变量,cls和bits,还有一个结构体成员.其中在不同的os平台,有不同的声明.</p><pre><code># if __arm64__#   define ISA_MASK        0x0000000ffffffff8ULL#   define ISA_MAGIC_MASK  0x000003f000000001ULL#   define ISA_MAGIC_VALUE 0x000001a000000001ULL#   define ISA_BITFIELD                                                      \      uintptr_t nonpointer        : 1;                                       \      uintptr_t has_assoc         : 1;                                       \      uintptr_t has_cxx_dtor      : 1;                                       \      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \      uintptr_t magic             : 6;                                       \      uintptr_t weakly_referenced : 1;                                       \      uintptr_t deallocating      : 1;                                       \      uintptr_t has_sidetable_rc  : 1;                                       \      uintptr_t extra_rc          : 19#   define RC_ONE   (1ULL&lt;&lt;45)#   define RC_HALF  (1ULL&lt;&lt;18)# elif __x86_64__#   define ISA_MASK        0x00007ffffffffff8ULL#   define ISA_MAGIC_MASK  0x001f800000000001ULL#   define ISA_MAGIC_VALUE 0x001d800000000001ULL#   define ISA_BITFIELD                                                        \      uintptr_t nonpointer        : 1;                                         \      uintptr_t has_assoc         : 1;                                         \      uintptr_t has_cxx_dtor      : 1;                                         \      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \      uintptr_t magic             : 6;                                         \      uintptr_t weakly_referenced : 1;                                         \      uintptr_t deallocating      : 1;                                         \      uintptr_t has_sidetable_rc  : 1;                                         \      uintptr_t extra_rc          : 8#   define RC_ONE   (1ULL&lt;&lt;56)#   define RC_HALF  (1ULL&lt;&lt;7)# else#   error unknown architecture for packed isa# endif// SUPPORT_PACKED_ISA#endif#if SUPPORT_INDEXED_ISA# if  __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)    // armv7k or arm64_32#   define ISA_INDEX_IS_NPI_BIT  0#   define ISA_INDEX_IS_NPI_MASK 0x00000001#   define ISA_INDEX_MASK        0x0001FFFC#   define ISA_INDEX_SHIFT       2#   define ISA_INDEX_BITS        15#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)#   define ISA_INDEX_MAGIC_MASK  0x001E0001#   define ISA_INDEX_MAGIC_VALUE 0x001C0001#   define ISA_BITFIELD                         \      uintptr_t nonpointer        : 1;          \      uintptr_t has_assoc         : 1;          \      uintptr_t indexcls          : 15;         \      uintptr_t magic             : 4;          \      uintptr_t has_cxx_dtor      : 1;          \      uintptr_t weakly_referenced : 1;          \      uintptr_t deallocating      : 1;          \      uintptr_t has_sidetable_rc  : 1;          \      uintptr_t extra_rc          : 7#   define RC_ONE   (1ULL&lt;&lt;25)#   define RC_HALF  (1ULL&lt;&lt;6)</code></pre><p>nonpointer: 标记此isa是否是tagged pointer优化后的isa.占用1bit.值为1说明是优化后的isa.具体参考<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">链接</a>,tagged pointer是对实例对象的优化,默认是true,并且是isClass的判断,这是我看源码的理解,不对请指正<br><br>has_assoc:标记object是否有关联对象,没有,释放更快<br><br>has_cxx_dtor:标记是否有西沟函数,没有,释放更快<br><br>shiftcls:类对象(Class,meta-Class对象)内存地址信息<br><br>magic:标记object是否初始化完成<br><br>weakly_refrenced:标记object是否有weak指针指向它<br><br>deallocating:标记object是否正在释放<br><br>has_sidetable_rc:标记object的extra_rc位数能否存的下object的引用计数,存不下即has_sidetable_rc=1,存在全局的SideTable里面<br><br>extra_rc:存储object的引用计数,存不下,存在全局的SideTable里面<br></p><p><strong>下面是object的完整声明:</strong></p><pre><code>// MARK: - object的完整声明struct objc_object {private:    // 私有成员变量: isa指针    isa_t isa;// 公有函数public:    // 通过这个函数获取不支持tagged pointer的类指针    // ISA() assumes this is NOT a tagged pointer object    Class ISA();    // 通过这个函数获取支持tagged pointer的类指针    // getIsa() allows this to be a tagged pointer object    Class getIsa();    // 以下几个函数是isa的初始化函数    // initIsa()用来初始化一个新的对象的isa    // initIsa() should be used to init the isa of new objects only.    // changeIsa 修改一个对象的isa    // If this object already has an isa, use changeIsa() for correctness.    // initInstanceIsa()用来初始化一个实例对象的isa    // initInstanceIsa(): objects with no custom RR/AWZ    // initClassIsa()用来初始化一个类对象的isa    // initClassIsa(): class objects    // initProtocolIsa()用来初始化一个protocol的isa    // initProtocolIsa(): protocol objects    // initIsa()还用来初始化其它类型对象的isa    // initIsa(): other objects    void initIsa(Class cls /*nonpointer=false*/);    void initClassIsa(Class cls /*nonpointer=maybe*/);    void initProtocolIsa(Class cls /*nonpointer=maybe*/);    void initInstanceIsa(Class cls, bool hasCxxDtor);    // changeIsa() should be used to change the isa of existing objects.    // If this is a new object, use initIsa() for performance.    Class changeIsa(Class newCls);    // tagged pointer 相关    bool hasNonpointerIsa();    bool isTaggedPointer();    bool isBasicTaggedPointer();    bool isExtTaggedPointer();    // 是否是Class    bool isClass();    // 关联对象相关    // object may have associated objects?    bool hasAssociatedObjects();    void setHasAssociatedObjects();    // weak指针相关    // object may be weakly referenced?    bool isWeaklyReferenced();    void setWeaklyReferenced_nolock();    // 对象是否有析构函数    // object may have -.cxx_destruct implementation?    bool hasCxxDtor();    // retain 和 release 操作对象的引用计数 声明函数    // Optimized calls to retain/release methods    id retain();    void release();    id autorelease();    // retain 和 release 操作对象的引用计数 实现函数    // Implementations of retain/release methods    id rootRetain();    bool rootRelease();    id rootAutorelease();    bool rootTryRetain();    bool rootReleaseShouldDealloc();    uintptr_t rootRetainCount();    // 释放销毁对象相关    // Implementation of dealloc methods    bool rootIsDeallocating();    void clearDeallocating();    void rootDealloc();// 私有函数 上面一些公有函数的调用函数private:    void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor);    // Slow paths for inline control    id rootAutorelease2();    bool overrelease_error();#if SUPPORT_NONPOINTER_ISA    // Unified retain count manipulation for nonpointer isa    id rootRetain(bool tryRetain, bool handleOverflow);    bool rootRelease(bool performDealloc, bool handleUnderflow);    id rootRetain_overflow(bool tryRetain);    bool rootRelease_underflow(bool performDealloc);    void clearDeallocating_slow();    // Side table retain count overflow for nonpointer isa    void sidetable_lock();    void sidetable_unlock();    void sidetable_moveExtraRC_nolock(size_t extra_rc, bool isDeallocating, bool weaklyReferenced);    bool sidetable_addExtraRC_nolock(size_t delta_rc);    size_t sidetable_subExtraRC_nolock(size_t delta_rc);    size_t sidetable_getExtraRC_nolock();#endif    // Side-table-only retain count    bool sidetable_isDeallocating();    void sidetable_clearDeallocating();    bool sidetable_isWeaklyReferenced();    void sidetable_setWeaklyReferenced_nolock();    id sidetable_retain();    id sidetable_retain_slow(SideTable&amp; table);    uintptr_t sidetable_release(bool performDealloc = true);    uintptr_t sidetable_release_slow(SideTable&amp; table, bool performDealloc = true);    bool sidetable_tryRetain();    uintptr_t sidetable_retainCount();#if DEBUG    bool sidetable_present();#endif};</code></pre><p>以上就是objc_object的具体声明结构,里面有许多值得深究的问题,也是接下来会继续关注的问题.</p><h3 id="二-实例对象的初始化"><a href="#二-实例对象的初始化" class="headerlink" title="二.实例对象的初始化"></a>二.实例对象的初始化</h3><h4 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1.alloc"></a>1.alloc</h4><p>下面我们来看一个对象的实例化过程:</p><pre><code>Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);</code></pre><p>上面代码时创建一个newClass类,并且用这个新类实例化一个newObject对象.查看一下alloc方法和init方法的调用栈,其中省略了中间过程:</p><pre><code>id _objc_rootAlloc(Class cls)└── static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)    └── id class_createInstance(Class cls, size_t extraBytes)        └── id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct, size_t *outAllocatedSize)            ├── size_t instanceSize(size_t extraBytes)            ├── void    *calloc(size_t, size_t)            └── inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</code></pre><p>其中NSObject.mm中对alloc的实现如下:</p><pre><code>+ (id)alloc {    return _objc_rootAlloc(self);}</code></pre><p>这里面调用了一个私有函数,返回一个id类型(objc_object)如下:</p><pre><code>id_objc_rootAlloc(Class cls){    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);}</code></pre><p>NSObject.mm对callAlloc()实现:</p><pre><code>// Call [cls alloc] or [cls allocWithZone:nil], with appropriate// shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){    if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) {        // No alloc/allocWithZone implementation. Go straight to the allocator.        // fixme store hasCustomAWZ in the non-meta class and        // add it to canAllocFast&#39;s summary        if (fastpath(cls-&gt;canAllocFast())) {            // No ctors, raw isa, etc. Go straight to the metal.            bool dtor = cls-&gt;hasCxxDtor();            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());            if (slowpath(!obj)) return callBadAllocHandler(cls);            obj-&gt;initInstanceIsa(cls, dtor);            return obj;        }        else {            // Has ctor or raw isa or something. Use the slower path.            id obj = class_createInstance(cls, 0);            if (slowpath(!obj)) return callBadAllocHandler(cls);            return obj;        }    }#endif    // No shortcuts available.    if (allocWithZone) return [cls allocWithZone:nil];    return [cls alloc];}</code></pre><p>其中有个class_createInstance()函数,这函数中会调用_class_createInstanceFromZone()函数:</p><pre><code>static __attribute__((always_inline))id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil){    if (!cls) return nil;    assert(cls-&gt;isRealized());    // Read class&#39;s info bits all at once for performance    bool hasCxxCtor = cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size = cls-&gt;instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (!zone  &amp;&amp;  fast) {        obj = (id)calloc(1, size);        if (!obj) return nil;        obj-&gt;initInstanceIsa(cls, hasCxxDtor);    }    else {        if (zone) {            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);        } else {            obj = (id)calloc(1, size);        }        if (!obj) return nil;        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj-&gt;initIsa(cls);    }    if (cxxConstruct &amp;&amp; hasCxxCtor) {        obj = _objc_constructOrFree(obj, cls);    }    return obj;}</code></pre><p>这里面有:1)instanceSize()是给对象分配内存空间:</p><pre><code>size_t instanceSize(size_t extraBytes) {    size_t size = alignedInstanceSize() + extraBytes;    if (size &lt; 16) size = 16;    return size;}uint32_t alignedInstanceSize() {    return word_align(unalignedInstanceSize());}uint32_t unalignedInstanceSize() {    assert(isRealized());    return data()-&gt;ro-&gt;instanceSize;}</code></pre><p>2)initIsa()初始化isa指针</p><pre><code>inline voidobjc_object::initIsa(Class cls){    initIsa(cls, false, false);}inline voidobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor){    assert(!isTaggedPointer());    // 不是tagged pointer    if (!nonpointer) {        isa.cls = cls;    } else {        assert(!DisableNonpointerIsa);        assert(!cls-&gt;instancesRequireRawIsa());        isa_t newisa(0);#if SUPPORT_INDEXED_ISA        assert(cls-&gt;classArrayIndex() &gt; 0);        newisa.bits = ISA_INDEX_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else        newisa.bits = ISA_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif        // This write must be performed in a single store in some cases        // (for example when realizing a class because other threads        // may simultaneously try to use the class).        // fixme use atomics here to guarantee single-store and to        // guarantee memory order w.r.t. the class index table        // ...but not too atomic because we don&#39;t want to hurt instantiation        isa = newisa;    }}</code></pre><h4 id="2-init"><a href="#2-init" class="headerlink" title="2.init"></a>2.init</h4><p>init()函数调用栈很简单,只是调用了_objc_rootInit()私有函数,并返回对象本身</p><pre><code>- (id)init {    return _objc_rootInit(self);}id_objc_rootInit(id obj){    // In practice, it will be hard to rely on this function.    // Many classes do not properly chain -init calls.    return obj;}</code></pre><p><strong>对象的初始化过程可以总结为分配内存空间并且初始化isa_t结构的过程.</strong></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">https://blog.devtang.com/2014/05/30/understand-tagged-pointer/</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Extension</title>
      <link href="/2019/04/09/Swift-Extension/"/>
      <url>/2019/04/09/Swift-Extension/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift Extension 字面意思就是扩展.有点类似OC中Category,按照官方文档,Extension可以用来:</p><h3 id="1-添加计算型属性"><a href="#1-添加计算型属性" class="headerlink" title="1.添加计算型属性"></a>1.添加计算型属性</h3><p><strong>拓展一下:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算型属性:计算型属性不直接存储值,而是提供一个getter和setter来间接获取和设置属性值</p><pre><code>var name:Stringvar _name:String {set {name = newValue}get {return name}}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储型属性:用来存储一个变量或者常量</p><pre><code>var name:String = &quot;zhangsan&quot;let age:Int = 10</code></pre><pre><code>// MARK: - 扩展计算型属性extension UIView {    var x:CGFloat {        set{            self.frame.origin.x = newValue        }        get{           return self.frame.origin.x        }    }}</code></pre><h3 id="2-添加方法"><a href="#2-添加方法" class="headerlink" title="2.添加方法"></a>2.添加方法</h3><p><strong>扩展实例方法</strong></p><pre><code>// MARK: - 扩展实例方法    func size(height:CGFloat, width:CGFloat) -&gt; CGFloat {        return height * width    }</code></pre><p><strong>添加突变方法 - mutating method:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过extension添加的实例方法同样可以修改(modify)或突变(mutate)该实例本身，如果结构体和枚举定义的方法想要改变自身或自身的属性，那么该实例方法必须被标记为突变(mutating)的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的例子为Int类型添加了一个名为square的突变方法，它的作用是计算原始值的平方:</p><pre><code>extension Int {    mutating func square() {        self = self * self    }}</code></pre><h3 id="3-提供便利构造器"><a href="#3-提供便利构造器" class="headerlink" title="3.提供便利构造器"></a>3.提供便利构造器</h3><pre><code>// MARK: - 便利构造器    convenience init(info:[String:String]) {        self.init()// todo:    }</code></pre><h3 id="4-定义下标subscripts"><a href="#4-定义下标subscripts" class="headerlink" title="4.定义下标subscripts"></a>4.定义下标subscripts</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附属脚本可以定义在class,struct,enum中,可以认为是访问对象,集合或者序列的快捷方式,凌辱我们常用的通过所以访问数组中的值,array[index];通过key访问字典中的value,dict[key]等.</p><pre><code>// MARK: - 官方示例:计算某个整数第某位上的值extension Int {    subscript(digitIndex: Int) -&gt; Int {        var decimalBase = 1        for _ in 0..&lt;digitIndex {            decimalBase *= 10        }        return (self / decimalBase) % 10    }}746381295[0]// returns 5746381295[1]// returns 9746381295[2]// returns 2746381295[8]// returns 7</code></pre><h3 id="5-添加嵌套类型"><a href="#5-添加嵌套类型" class="headerlink" title="5.添加嵌套类型"></a>5.添加嵌套类型</h3><pre><code>extension Int {    enum Kind {        case negative, zero, positive    }    var kind: Kind {        switch self {        case 0:            return .zero        case let x where x &gt; 0:            return .positive        default:            return .negative        }    }}</code></pre><h3 id="6-实现遵守协议的方法"><a href="#6-实现遵守协议的方法" class="headerlink" title="6.实现遵守协议的方法"></a>6.实现遵守协议的方法</h3><pre><code>// MARK: - 实现遵守协议的方法extension UIView:UITableViewDataSource {    public func numberOfSections(in tableView: UITableView) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        &lt;#code#&gt;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Equable</title>
      <link href="/2019/04/09/Swift-Equable/"/>
      <url>/2019/04/09/Swift-Equable/</url>
      
        <content type="html"><![CDATA[<p>一般判断两个对象是否相等方法:<br><br>如果两个对象相等其hashValue一定相等,不能反过来倒推.<br><br>1)如果两个对象的hashValue不相等,则认为这两个对象一定不相等<br><br>2)如果两个对象的hashValue相等,则比较两个对象的指针和两对象的内容是否相等,如果相等,则认为这两个对象是相等的<br><br>Swift中一些数据类型Int,Double,Bool等均已遵守实现Equable协议,所以在使用的时候可以用”==”操作符直接比较两个变量就行.<br></p><p>如果有一些自定义类型需要比较,需要遵守Equable协议,并且重写 public static func == (lhs: Self, rhs: Self) -&gt; Bool方法.<br></p><pre><code>class Person {    var name:String?    var age:Int?    init(name:String,age:Int) {        self.name = name        self.age = age    }}extension Person:Equatable {    static func == (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age    }}let person1 = Person(name: &quot;zhangsan&quot;, age: 18)let person2 = Person(name: &quot;lisi&quot;, age: 20)print(person1==person2) //false</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/04/09/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/09/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="表的简单定义"><a href="#表的简单定义" class="headerlink" title="表的简单定义:"></a>表的简单定义:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将处理一般的形如A1,A2,A3,…An的表,称这个表的大小是N.我们称大小为0的表为空表.表是一种线性的数据结构集合.对于除空表外的任何表,我们称Ai+1是Ai的后继,Ai-1是Ai的前驱.</p><h2 id="表常见的操作"><a href="#表常见的操作" class="headerlink" title="表常见的操作:"></a>表常见的操作:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find返回关键字首次出现的位置例程,Delete删除某个关键字例程,Insert在某个位置插入例程,遍历等</p><h2 id="表的实现方式"><a href="#表的实现方式" class="headerlink" title="表的实现方式:"></a>表的实现方式:</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于表的所有操作都可以通过数组来实现,数组实现表有一定的局限性,数组的大小事先要指定;数组的插入和删除操作会对插入和删除以后的所有元素都要调整,这种时间复杂度最坏为O(n).但是数组的查找和遍历是线性时间复杂度,而查找某个位置上的元素时间复杂度仅为常数时间,这些可以算作数组的优势.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为插入和删除的运行时间以及表的大小还要事先已知,因此对于插入和删除操作比较多的情况,一般不用数组来实现表结构.</p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表由一系列不必在内存中相连的结构组成.每一个结构均含有表元素和指向包含该元素后继元的结构的指针,即next指针.最后一个结构的next指针指向NULL.遍历和查找某个元素链表的时间复杂度为线性时间,我们只要将一个指针传递到该表的第一个元素,然后用一些next指针穿越该表即可.而查找某个位置上的元素其优势不如数组效率高.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除操作可以将待删除结构前驱的next指针指向待删除结构的后继即可.插入操作需要先实例化创建一个结构,然后获取插入位置的结构的前驱,将其next指针指向新创建的结构,然后新创建的结构next指针指向插入位置结构后继.</p><h3 id="3-链表结构类型"><a href="#3-链表结构类型" class="headerlink" title="3.链表结构类型"></a>3.链表结构类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表分为单链表,双链表,循环链表,块链表等.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双链表比单链表多了一个previous指针,指向前驱.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环链表是将首尾连接起来,这种方式在单向和双向链表中皆可实现.要转换一个循环链表,你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点.再来看另一种方法,循环链表可以被视为“无头无尾”.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块状链表本身是一个链表,但是链表储存的并不是一般的数据,而是由这些数据组成的顺序表.每一个块状链表的节点,也就是顺序表,可以被叫做一个块.<br></p><p>[图片上传失败…(image-e79610-1554800955920)])</p><h4 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h4><pre><code>/// 节点元素的值var value:T/// 节点元素的next指针var next:NodeList?/// 链表节点元素的构造函数////// - Parameter val: 值init(val:T) {self.value = val}</code></pre><h4 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历链表用next指针穿越整个表,创建一个临时节点,把当前节点赋值给临时节点.如果当前节点不为nil,将当前节点的next赋值给临时节点.</p><pre><code>/// 遍历链表////// - Parameter nodeList: 链表/// - Returns: 链表长度func traverse(with nodeList:NodeList?) -&gt; Int {var nodeListLength:Int = 0var tmpNode = nodeListwhile tmpNode != nil {nodeListLength += 1tmpNode = tmpNode!.next}return nodeListLength}</code></pre><h4 id="根据给定索引查找对应节点的值"><a href="#根据给定索引查找对应节点的值" class="headerlink" title="根据给定索引查找对应节点的值"></a>根据给定索引查找对应节点的值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找例程还是基于遍历思想,用next指针穿越.如果当前节点不为空,比较当前索引与指定索引事都相等,相等返回当前节点的值;不相等则递增当前索引并且将当前节点的后继赋值给当前节点,直到当前索引与指定索引相等.</p><pre><code>/// 根据指定索引查找某个链表节点的值////// - Parameters:/// - nodeList: 链表/// - index: 要查询的节点/// - Returns: 某个索引节点的值func find(with nodeList:NodeList?, index:Int) -&gt; T? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if currentIndex == index {return tmpNode?.value}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="根据指定值查找某个链表节点的索引"><a href="#根据指定值查找某个链表节点的索引" class="headerlink" title="根据指定值查找某个链表节点的索引"></a>根据指定值查找某个链表节点的索引</h4><pre><code>/// 根据指定值查找某个链表节点的索引////// - Parameters:/// - nodeList: 链表/// - value: 值/// - Returns: 值对应节点的索引func find(with nodeList:NodeList?, value:T?) -&gt; Int? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if tmpNode?.value == value {return currentIndex}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="在指定位置插入新的节点"><a href="#在指定位置插入新的节点" class="headerlink" title="在指定位置插入新的节点"></a>在指定位置插入新的节点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先判断当前链表是否存在,然后获取插入位置的前一个节点previousN,把previousN的后继赋值给插入节点的next指针;把插入节点赋值给previousN的next指针;</p><pre><code>/// 在链表指定位置插入新的节点并返回新的链表////// - Parameters:/// - nodeList: 链表/// - node: 待插入节点/// - index: 插入位置/// - Returns: 新的链表func insert(with nodeList:NodeList?, node:NodeList, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return node }if traverse(with: nodeL) &lt;= index {return node}var previousN:NodeList?if index != 0 {previousN = nodeL.find(with: nodeL, at: index - 1)node.next = previousN!.nextpreviousN!.next = nodereturn nodeL} else {node.next = nodeLreturn node}}</code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除指定位置的节点先要找到当前节点currentN和当前节点的前驱previousN,然后把previousN的next指针指向currentN的后继.</p><pre><code>/// 删除指定位置的节点并返回新的列表////// - Parameters:/// - nodeList: 链表/// - index: 待删除的位置/// - Returns: 删除后的链表func delete(with nodeList:NodeList?, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return nil }if nodeL.traverse(with: nodeL) &lt;= index {return nodeL}if index == 0 {return nodeL.next}let previousN = nodeL.find(with: nodeL, at: index - 1)let currentN = nodeL.find(with: nodeL, at: index)previousN?.next = currentN?.nextreturn nodeL}</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime源码编译</title>
      <link href="/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是基于c语言的封装,使C语言具有了面向对象的能力.OC的本质最终还是转换c语言来执行,而这个转换的过程是通过Runtime这个运行时库来完成的.平常我们只需要写面对对象的OC代码,不用太关心一些底层转换原理及过程.但是有些情况.比如需要动态给一个类添加方法,添加成员变量,添加协议,没有实现方法的报错解析定位等,就需要了解这个底层实现来更好的解决实际开发中遇到的问题.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文也是对之前编译查看的Runtime源码的一个复习过程,主要有以下几步:</p><h3 id="一-下载源码及相关依赖"><a href="#一-下载源码及相关依赖" class="headerlink" title="一.下载源码及相关依赖"></a>一.下载源码及相关依赖<br></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果开源网站:<a href="http://opensource.apple.com/" target="_blank" rel="noopener">http://opensource.apple.com/</a>,其为我们提供了Runtime的实现源码objc4,这个objc4有多个版本,版本号越大说明是最新源码.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-131232ef2da1515f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果开源平台"></p><h4 id="1-下载objc4源码"><a href="#1-下载objc4源码" class="headerlink" title="1.下载objc4源码"></a>1.下载objc4源码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先打开苹果开源网站,可以看到苹果针对不同的设备平台有不同的开源项目已经对应的系统版本,找到对应的平台对应的版本点击下载objc4源码,本文依赖的是objc4-750版本.也可以在<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/</a>上面搜索所有开源项目源码的压缩包.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fbed6e632659dcff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc4源码"></p><h4 id="2-下载objc4相关依赖库"><a href="#2-下载objc4相关依赖库" class="headerlink" title="2.下载objc4相关依赖库"></a>2.下载objc4相关依赖库</h4><p>objc4相关依赖库:Libc，dyld，libauto，libclosure，libdispatch，libpthread，xnu.这些依赖库中包含了Runtime源码库中需要的一些文件.</p><h4 id="3-解压缩所有下载的压缩包库"><a href="#3-解压缩所有下载的压缩包库" class="headerlink" title="3.解压缩所有下载的压缩包库."></a>3.解压缩所有下载的压缩包库.</h4><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fabaa6bd03263beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码解压后"></p><h3 id="二-编译-amp-错误解决"><a href="#二-编译-amp-错误解决" class="headerlink" title="二.编译&amp;错误解决"></a>二.编译&amp;错误解决<br></h3><h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境:"></a>1.环境:</h4><p>target platform:<strong>macOS</strong><br><br>macOS:<strong>10.14</strong><br><br>Xcode:<strong>10.1</strong><br></p><h4 id="2-遇到的错误-amp-解决"><a href="#2-遇到的错误-amp-解决" class="headerlink" title="2.遇到的错误&amp;解决"></a>2.遇到的错误&amp;解决</h4><p><strong>1)error: The i386 architecture is deprecated. You should update your ARCHS build setting to remove the i386 architecture. (in target ‘objc’)</strong><br><br>解决:找target对应编译设置(Build Settings)-&gt;CPU架构(Architecture)-&gt;标准(Standard arcgutectures)<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-bebc4c3e29d47f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误1"><br><strong>2)在objc-os.h头文件中报’sys/reason.h’ file not found错误</strong><br><br>解决:工程目录下创建include/sys目录,在编译设置(Build Settings里面搜索,Header Search Paths,然后将include索引添加进去),然后在之前下载的依赖包中搜索reason.h头文件,复制到include/sys目录下<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-149cea545b66f79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误2"><br><strong>3)在objc-os.h头文件中报’mach-o/dyld_priv.h’ file not found错误</strong><br><br>解决:同上一步,创建include/mach-o目录,复制dyld_priv.h头文件到相应目录<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7a009d4875664966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误3"><br><strong>4)在objc-os.h头文件中报’os/lock_private.h’ file not found错误</strong><br><br>解决:这个文件并没有再我们下载的依赖库中,需要去开源官网下载,然后操作同上一步<br><br><strong>5)以下是遇到的类似问题:</strong><br><br>‘os/base_private.h’ file not found;<br><br>‘pthread/tsd_private.h’ file not found;<br><br>‘System/machine/cpu_capabilities.h’ file not found;<br><br>‘os/tsd.h’ file not found;<br><br>‘pthread/spinlock_private.h’ file not found;<br><br>‘System/pthread_machdep.h’ file not found;<br><br>‘CrashReporterClient.h’ file not found;这个需要在编译设置(Build Settings添加宏变量Build Settings-&gt;Preprocessor Macros中加入：LIBC_NO_LIBCRASHREPORTERCLIENT)<br><br>‘Block_private.h’ file not found;<br><br>‘objc-shared-cache.h’ file not found;<br><br>‘isa.h’ file not found;<br><br>‘_simple.h’ file not found;<br><br>在objc-errors.mm文件中报:Use of undeclared identifier ‘CRGetCrashLogMessage’错误;<br><br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7730fb32289af992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误5"><br><strong>6)链接时候错误:</strong><br><br>ld: can’t open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/<br>Developer/SDKs/MacOSX10.14.sdk/AppleInternal/OrderFiles/libobjc.order<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br><br>解决:将Build Settings-&gt;Linking-&gt;Order File改为工程根目录下的libobjc.order，即：$(SRCROOT)/libobjc.order。<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-81be9877600720d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误6"><br><strong>7)编译脚本错误</strong><br><br>xcodebuild: error: SDK “macosx.internal” cannot be located.<br>xcrun: error: unable to find utility “clang++”, not a developer tool or in PATH<br><br>解决:把Target-objc的Build Phases-&gt;Run Script(markgc)里的内容macosx.internal改为macosx，这里猜测macosx.internal为苹果内部的macosx<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fe07a0f8d034da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误7"><br><strong>8)error: no such public header file: ‘/tmp/objc.dst/usr/include/objc/ObjectiveC.apinotes’错误</strong><br><br>解决:把Text-Based InstallAPI Verification Model里的值改为Errors Only<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-0bd60bd7502eb574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误8"></p><h4 id="3-编译成功"><a href="#3-编译成功" class="headerlink" title="3.编译成功"></a>3.编译成功</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决以上错误后,再次编译应该基本Succeeded.<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-d6481492106e77dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功"><br></p><h3 id="三-调试"><a href="#三-调试" class="headerlink" title="三.调试"></a>三.调试<br></h3><h4 id="1-创建调试target"><a href="#1-创建调试target" class="headerlink" title="1.创建调试target"></a>1.创建调试target</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文编译针对的是macOS平台,可以创建一个macOS app或者一个 Command Line Tool 来调试.这里我们就创建一个Command Line Tool target:<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-5b9356137395b41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug target"></p><h4 id="2-编写代码调试"><a href="#2-编写代码调试" class="headerlink" title="2.编写代码调试"></a>2.编写代码调试</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新创建一个class,命名为newClass,打印出class name.可以查看调用栈,确实调用的是我们编译后的Runtime库:</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/message.h&gt;#import &lt;objc/runtime.h&gt;int main(int argc, const char * argv[]) {    @autoreleasepool {        Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);    }    return 0;}</code></pre><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-ff32f2b6e67bfb93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_1"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-41cd2b1e03f16de5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_2"></p><h3 id="四-编译后源码库"><a href="#四-编译后源码库" class="headerlink" title="四.编译后源码库"></a>四.编译后源码库</h3><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a></strong></p><h3 id="五-参考文献"><a href="#五-参考文献" class="headerlink" title="五.参考文献"></a>五.参考文献</h3><p><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="noopener">https://pewpewthespells.com/blog/buildsettings.html</a><br><br><a href="https://blog.csdn.net/wotors/article/details/52489464" target="_blank" rel="noopener">https://blog.csdn.net/wotors/article/details/52489464</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中Objective-C和Swift混编及第三方框架相互调用</title>
      <link href="/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
      <url>/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将详细介绍一下OC和swift混编问题,其中涉及两大部分:1)oc项目中混编swift的实现; 2)oc或者swift第三库的导入及使用.</p><p>#1 oc项目中混编swift<br>在oc项目中想要使用swift,并且实现相互调用,需要一些基本的设置,桥接文件也是必须得.</p><p>#1. 1 基本设置支持swift<br>在bulid setting中找到 Packaging 下的 define module,将是否定义模块布尔值改成YES,这样OC就可以支持swift了.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-a50523996ab98cb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="define module.png"></p><p>#1. 2 创建桥接文件<br>桥接文件可以在你创建swift文件的时候Xcode自动生成,也可以自己手动创建,手动创建也就是一个头文件(.h文件).<br>这里需要说明一点的是,在oc项目中创建的swift文件必须都要继承自NSObject基类,而你自己想要创建的一些类可以这样来创建:</p><p>####创建步骤1<br><img src="http://upload-images.jianshu.io/upload_images/1715253-6cacd2bc47564e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>####创建步骤2<br><img src="http://upload-images.jianshu.io/upload_images/1715253-fd2a1b324f032568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><p>####创建步骤3<br>这里选择Create Bridging Header,如果不选的话,那就自己手动创建,然后指定索引位置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-e88dda48a82bc616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>####创建步骤4<br><img src="http://upload-images.jianshu.io/upload_images/1715253-19219fab149a7ca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>第三步中如果没有创建桥接文件的话,手动创建一个桥接文件,然后build setting 中搜索 Objective-C Bridging Header,将你手动创建的桥接文件路径输入进去</p><p>####桥接文件设置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-b9b8484bfd32bc58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接文件设置"></p><p>#1.3 swift中调用oc文件<br>现在基本上可以实现swift调用oc中代码了,首先在桥接文件中导入你想在swift中用到的oc类</p><p>####导入oc类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1228e43af95e8399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入oc类"></p><p>####使用oc中的类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-2b410f5097f1786c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用oc中的类"></p><p>#1. 4 oc中调用swift文件<br><img src="http://upload-images.jianshu.io/upload_images/1715253-25d7b46b350c3dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="oc中调用swift文件"></p><p>#2 oc和swift第三方库的使用<br>如果你的项目用cocoapods来管理你使用的第三方库,并且OC项目中已经集成了多个第三方库,那么这时你想在导入swift编写的第三方库,这时你不能用cocoapods管理第三方库了,因为Swift连接时不支持静态库,cocoapods也在其Podfile中有说明:</p><h1 id="Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks"><a href="#Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks" class="headerlink" title="Uncomment the next line if you’re using Swift or would like to use dynamic frameworks"></a>Uncomment the next line if you’re using Swift or would like to use dynamic frameworks</h1><h1 id="use-frameworks"><a href="#use-frameworks" class="headerlink" title="use_frameworks!"></a>use_frameworks!</h1><p>翻译过来就是:如果你想使用swift或者动态库,就把下面一行注释打开<br>然而打开后你是编译不过去的,这时需要手动导入swift库<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1910c75b87225c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用swift或者动态库使用use_frameworks"></p><p>下面手动导入Alamofire作为例子:</p><p>##1)首先下载Alamofire项目源码,解压<br><img src="http://upload-images.jianshu.io/upload_images/1715253-cc75cc2e87dd1875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alamofire项目源码"><br>可以删除多余的不需要的文件,比如Example文件夹,等等</p><p>##2)将Alamofire项目整个拖到你的项目中<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d0e942f8f731ffc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拖到自己项目中"></p><p>##3)在Embedded Binaries中添加Alamofire.framework<br><img src="http://upload-images.jianshu.io/upload_images/1715253-8007cc13803cec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Embedded Binaries中添加Alamofire.framework"></p><p>这样就可以cocoapods管理OC第三方库,swift第三方库手动管理,实现不同第三方框架的调用.</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--tableView优化</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者基于之前自己所写的Swift项目–仿照推特客户端用纯Swift写的一个项目,目前已经公开放在GitHub上(<strong><em><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a></em></strong>); 接口用Python写的几个(<strong><em><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a></em></strong>),目前所实现的功能是登录,注册,发推,首页列表等功能,其他页面都是一些假数据.这里不主要分析项目了,有时间在详细说一下.本文的主要重点是说说自己对性能调优–tableView控件优化的一点理解,有些问题理解的不是很透彻,希望大家能多给些意见,建议,谢谢.下图是整个项目的总览(文章中多是gif动态,尺寸较大,使用流量看得慎重):<br><img src="https://upload-images.jianshu.io/upload_images/1715253-360caafd286f9f10.gif?imageMogr2/auto-orient/strip" alt="项目总览1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-35ff9103000752d7.GIF?imageMogr2/auto-orient/strip" alt="项目总览2.GIF"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>有一句话说:过早的优化是万恶之源, 过早并不是开发过程的早期，而是在还没弄清楚业务需求的情形下去做所谓的优化,有时候会适得其反——费时、费力、不讨好。正确的方法是，先有质量地实现你的需求，写够测试用例，然后做profile去找到性能的瓶颈，考虑究竟哪些地方应该优化，应该如何优化，哪些不应该优化.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-0e7f39942a7a6c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章结构.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者对一些显示的垂直信号,水平信号原理不是了解,大家如果想深入了解的可以查一下相关资料,相关大神也有总结,或许从硬件底层优化可能效果会更好.造成tableView卡顿的原因,从硬件上来说无非就两个,一个是CPU原因,一个是GPU原因.如果CPU核数较多,并发处理问题的能力也就越强,处理大量计算也不在话下;如果GPU显存够大,渲染能力足够强,处理复杂图形界面也就得心应手.但是,硬件的配置是有限度的,我们的目标是在有限度的硬件上,让其发挥最大限度的作用.这个也就是造成tableView卡顿的程序原因(软件原因)–卡住了主线程,本文将主要讨论是从程序角度讨论怎么优化tableView问题.</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最基本的就是减少cell的自定义类型,重用cell,每次只绘制屏幕显示cell的数量,其它cell从缓存中取.这些基础大家应该比我了解,这里不再陈述了.</p><h2 id="1-减轻CPU负荷"><a href="#1-减轻CPU负荷" class="headerlink" title="1. 减轻CPU负荷"></a>1. 减轻CPU负荷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道CPU的主要负责快速调度任务,大量计算工作,所以在tableView快速滚动的过程中让CPU的计算量降低是优化应该考虑的方向.下面总结了三个方面来尽可能的降低CPU计算:</p><h3 id="1-1提前计算好cell的高度-缓存在相应的数据源模型中"><a href="#1-1提前计算好cell的高度-缓存在相应的数据源模型中" class="headerlink" title="1.1提前计算好cell的高度,缓存在相应的数据源模型中"></a>1.1提前计算好cell的高度,缓存在相应的数据源模型中</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都已经知道tableView的代理回调方法中,先调用的是返回cell高度的方法,然后在返回实例化cell的方法.我们可以在返回cell高度时,提前计算好cell的高度,缓存到数据源模型中.例如:<em>MTTHomeModel</em>对应的是首页cell的数据模型,我们可以看到下面两个变量,是来存储cell的高度和内容高度的,:</p><pre><code>var cellHeight:CGFloat?var contentHeight:CGFloat?</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获取数据后台数据的时候,把cell高度计算出来,缓存起来:</p><pre><code>homeModel.contentHeight  = self.calculateTextHeight(text: homeModel.contentTextString!) + 150if(homeModel.retwitterType?.count)! &gt; Int(0){    homeModel.cellHeight = 255 + homeModel.contentHeight! - 150} else{    homeModel.cellHeight = 230 + homeModel.contentHeight! - 150 + 15}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在返回cell高度的方法中,直接读取缓存的高度,而不需要在重新计算了.</p><pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat    {        if self.homeDataArray != nil        {            let homeModel = homeDataArray![indexPath.row]            return homeModel.cellHeight!        } else        {            return 300        }    }</code></pre><h3 id="1-2-尽可能的降低storyboard-xib等使用度"><a href="#1-2-尽可能的降低storyboard-xib等使用度" class="headerlink" title="1.2 尽可能的降低storyboard,xib等使用度"></a>1.2 尽可能的降低storyboard,xib等使用度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前看到一些大家分享的相关资料,通过Interface知道xib或者storyboard本身就是一个xml文件,添加删除控件必然中间多了一个encode/decode过程,增加了cpu的计算量.并且 还要避免臃肿的 XIB 文件,因为XIB文件在主线程中进行加载布局.当用到一些自定义View或者XIB文件时,XIB的加载会把所有内容加载进来,如果XIB里面的一些控件并不会用到,这就可能造成一些资源的消耗浪费.网上有说:Storyboard 没这个问题,只会按需加载,这个作者还没有去考证.</p><h3 id="1-3-滑动过程中尽量减少重新布局"><a href="#1-3-滑动过程中尽量减少重新布局" class="headerlink" title="1.3 滑动过程中尽量减少重新布局"></a>1.3 滑动过程中尽量减少重新布局</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局就是给控件添加约束,约束最终还是转换成frame.所以,在满足业务需求情况下,如果图层层次较为复杂,要尽量减少自动布局约束,转为手动计算布局,大量的约束重叠也会增加cpu的计算量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者在获取到数据源时,每次都重新布局控件,这个也是一个重要开销,也是接下来需要优化的方向.</p><pre><code>private funclayoutSubview(homeModel:MTTHomeModel) -&gt; Void{       topLineView?.snp.makeConstraints({ (make) in           make.left.right.top.equalTo(0)           make.height.equalTo(0.3)       })}</code></pre><h2 id="2-不要阻塞主线程"><a href="#2-不要阻塞主线程" class="headerlink" title="2. 不要阻塞主线程"></a>2. 不要阻塞主线程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>UIKit的工作基本上都是在主线程上进行,界面绘制,用户输入响应等等.当所有的代码逻辑都放在主线程时,某些耗时任务可能会卡住主线程造成程序无法响应,流畅度降低等问题;在主线程中绘制大量界面图层,网络I/O,磁盘I/O等都可以造成界面卡顿现象.</strong></p><p>下面我们通过Xcode自带的调试工具Instruments来看看项目界面的流畅度,及其一些建议,Instruments给我提供了各种各样的调试查看工具,下面简单介绍一下:<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)Blank: 创建一个空的模板,可以从Library库中添加其他模板.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Activity Monitor: 监控进程级别的CPU,内存,磁盘,网络使用情况,可以得到你的应用程序在手机运行时总共占用的内存大小.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)Allocations: 跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史,可以检测每一个堆对象的分配内存情况.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Cocoa Layout : 观察NSLayoutConstraint对象的改变,帮助我们判断什么时间什么地点的constraint是否合理.观察约束变化,找出布局代码的问题所在.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5)Core Animation: 这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6)CoreData: 这个模块跟踪Core Data文件系统活动.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7)Counters : 收集使用时间或基于事件的抽样方法的性能监控计数器(PMC)事件.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8)Energy Log: 耗电量监控.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9)File Activity: 检测文件创建,移动,变化,删除等.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10)Leak: 一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11)Metal System Trace: Metal API是apple 2014年在ios平台上推出的高效底层的3D图形API,它通过减少驱动层的API调用CPU的消耗提高渲染效率.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12)Network: 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13)SceneKit: 3D性能状况分析.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14)System Trace: 系统跟踪,通过显示当前被调度线程提供综合的系统表现,显示从用户到系统的转换代码通过两个系统调用或内存操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15)System Usage: 这个模板记录关于文件读写,sockets,I/O系统活动,输入输出.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16)Time Profiler(时间探查): 执行对系统的CPU上运行的进程低负载时间为基础采样.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17)Zombies: 测量一般的内存使用,专注于检测过度释放的野指针对象,也提供对象分配统计，以及主动分配的内存地址历史.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要使用的是Instruments中的第5个工具:Core Animation(图形性能),这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们必须要把源码安装到测试设备上,1)连接Xcode运行程序;2)然后选择快捷键(Command + Control + i)调出Instruments,选择Core Animation.打开后我们可以看到Debug Options里面有多个调试选项,下面我们挨个尽量来分析看一下:</p><p>###2.1 Color Blended Layers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示,越红表示性能越差,会对帧率等指标造成较大的影响.红色通常是由于多个半透明图层叠加引起.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者项目可能项目比较简单,图层也不是很复杂,所以通过Color Blended Layers查看,深红色并不是很明显,在快速滑动的过程中,帧率依然能够保持在55+以上,并且图层中也没有大量的深红色区域出现.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-423fc34374dc56a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ColorBlendedLayers1-1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8641c471649c93a1.gif?imageMogr2/auto-orient/strip" alt="ColorBlendedLayers1-2-.gif"></p><p>###2.2 Color Hits Green and Misses Red<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当UIView.layer.shouldRasterize = YES 时,耗时的图片绘制会被缓存,并当做一个简单的扁平图片来呈现.这时候,如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中,就显示绿色,反之,如果不命中,这时就显示红色.红色越多,性能越差.因为栅格化生成缓存的过程是有开销的,如果缓存能被大量命中和有效使用,则总体上会降低开销,反之则意味着要频繁生成新的缓存,这会让性能问题雪上加霜.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-f99e1282e6919417.gif?imageMogr2/auto-orient/strip" alt="ColorHitsGreenandMissesRed2-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里笔者还要提一下图片的加载方式,我们知道图片的一般加载方式有两种:imageNamed 和imageWithContentsOfFile;它们的不同在于前者会对图片进行缓存,而后者只是简单的从文件加载文件.如果你加载的是大图,并且只会用到一次,比如欢迎引导图,那么就没必要缓存这个图片,可以使用[UIImage imageWithContentsOfFile:],用完就释放了.如果会多次使用到一张图时,用[UIImage imageNamed:] 就会高效很多,因为这种加载图片方式有一个缓存机制.YYImage实现原理应该就是后面这种思路,自己手动添加缓存.</p><p>###2.3 Color Copied Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理,把这样的图片标为蓝色.蓝色越多,性能越差.因为,我们不希望在滚动视图的时候,由 CPU 来处理图片,这样可能会对主线程造成阻塞.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-e802ac2215033c3f.gif?imageMogr2/auto-orient/strip" alt="ColorCopiedImages3-1.gif"></p><p>###2.4 Color Immediately<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说,这显然太慢了.这个选项就可以用来设置每帧都更新(可能会影响到渲染性能,而且会导致帧率测量不准,所以不要一直都设置它).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-d53301f12380ce80.gif?imageMogr2/auto-orient/strip" alt="ColorImmediately4-1.gif"></p><p>###2.5 Color Misaligned Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项检查了图片是否被缩放,以及像素是否对齐.被放缩的图片会被标记为黄色,像素不对齐则会标注为紫色.黄色,紫色越多,性能越差.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-7785ce1122d31e88.gif?imageMogr2/auto-orient/strip" alt="ColorMisalignedImages5-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里UI在切图的时候尽量切得尺寸和你控件的尺寸保持一致,尽量让图片保持原始尺寸.笔者这里所用图片几乎全部拉伸,由于图片都是从本地加载的,没有经过处理.</p><p>###2.6 Color Offscreen-Rendered Yellow<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把那些离屏渲染的图层显示为黄色.黄色越多,性能越差.这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-cdcbfd43e7b5efa2.gif?imageMogr2/auto-orient/strip" alt="ColorOffscreen-RenderedYellow6-1.gif"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染,即 Off-Screen Rendering.与之相对的是 On-Screen Rendering,即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行.那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染需要多次切&gt;换上下文环境:先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);等到离屏渲染结束以后,将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕,而上下文环境的切换是一项高开销的动作.<br>一般对控件属性操作会触发离屏渲染:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)阴影(UIView.layer.shadowOffset/shadowRadius/…)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)圆角(当 UIView.layer.cornerRadius 和UIView.layer.maskToBounds 一起使用时)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)图层蒙板<br>在实际开发中应尽量避免触发离屏渲染.</p></blockquote><p>###2.7 Color OpenGL Fast Path Blue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把任何直接使用OpenGL 绘制的图层显示为蓝色.蓝色越多,性能越好.如果仅仅使用 UIKit 或者 Core Animation 的 API,那么不会有任何效果.如果使用 GLKView 或者 CAEAGLLayer,那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理,而不是绘制到屏幕.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>任何优化都是以业务需求为前提,在满足基本需求的情况下,逐步提高代码的质量,提升程序性能,不仅是自我能力的表现,也能从中获得一些收获及成就感.以上优化方向思路也是在前人总结的基础上,作者在自己的项目中的简单应用,里面还有许许多多需要改进提升的地方,也希望大家能给一些深层次上的建议意见.</strong></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><strong><em><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--内存管理</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS内存管理无论是早期的MRC还是现在的ARC本质都是通过引用计数(Reference Counting)机制管理内存,当一个对象被创建出来时,它的引用计数从0到1,当有外部对象对它进行强引用时,它的应用计数会+1,当该对象收到一条release消息时,它的引用计数会-1;当对象的引用计数为0时,对象将被释放,对象指向的内存被回收.</p><h2 id="1-ARC内存管理的本质"><a href="#1-ARC内存管理的本质" class="headerlink" title="1. ARC内存管理的本质"></a>1. ARC内存管理的本质</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MRC时代需要程序员手动管理对象的生命周期,也就是对象的引用计数有程序员来控制,什么时候retain,什么时候release,完全自己掌握.ARC(Automatic Reference Counting)自动引用计数是编译器的一个特性,能够自动管理OC对象内存生命周期.在ARC中你需要专注于写你的代码, retain ,release, autorelease操作交给编译器去处理就行了.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-27c80639ff2b00b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MRC_ARC_示意图_来源_Apple_Document.jpg"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC 下编译器如何自动管理内存,其中,能想到的是在类的 dealloc 方法中，对该类的所持有的成员变量(strong)执行 release 操作,让所有成员变量的引用计数为0。对于局部变量,更可能是的对象在出作用域之前,编译器自动给对象加上一条 release消息.这些工作都是编译器为我们处理了.</p><pre><code>// 作用域    {        NSString *str = [[NSString alloc]initWithFormat:@&quot;%@&quot;,@&quot;str&quot;];        NSLog(@&quot;%@&quot;,str);        // 在对象出作用域时,编译器自动给对象发一条release消息        [str release];    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC,则无需我们自己显式持有(retain)和释放(release)对象,ARC通过对对像加上所有权修饰符(__strong等),编译器通过对象的所有权修饰符将会自动管理对象的引用计数.</p><h2 id="2-所有权修饰符"><a href="#2-所有权修饰符" class="headerlink" title="2. 所有权修饰符"></a>2. 所有权修饰符</h2><blockquote><p>基础知识:指针是其实也是一个对象,它指向一个内存地址单元,内存单元里存着各种变量.这样指针就可以指向这样变量,当我们用的时候我们就可以从内存单元取出变量内容.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C对象的ARC是通过所有权修饰符来管理对象的持有和释放。所有权修饰符一共有4种：</p></blockquote><h3 id="2-1-strong-修饰符"><a href="#2-1-strong-修饰符" class="headerlink" title="2.1 __strong 修饰符"></a>2.1 __strong 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认的修饰符,只要有一个强指针指向这个对象,这个对象就一直不会销毁,这个对象指向的指针也不会置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __strong person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:19:09.822168 TestARC[16592:5864784] person_one:(null),person_one地址:0x02018-03-19 16:19:22.443524 TestARC[16592:5864784] person_two:&lt;Person: 0x17001e450&gt;,person_two地址:0x17001e450</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-2902fc1e9aff3193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strong所有权修饰.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到,person_two是person_one的浅拷贝对象,也就是指针拷贝对象,而person_two是通过__strong修饰,相当于强指针,指向的是与person_one一块内存区域.而这块内存区域被retain了两次,引用计数为2,即使person_one = nil将引用计数-1了,person_two依然可以打印出内存地址.person_one的指针已经被置为NULL,所以打印出的地址是0x0.</p><h3 id="2-2-weak-修饰符"><a href="#2-2-weak-修饰符" class="headerlink" title="2.2 __weak 修饰符"></a>2.2 __weak 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当没有强指针指向弱引用的对象时,弱引用的对象将被置为nil,对象的指针置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __weak person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:28:21.453255 TestARC[16599:5866487] person_one:(null),person_one地址:0x02018-03-19 16:28:25.521762 TestARC[16599:5866487] person_two:(null),person_two地址:0x0</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-062710f6ab6758cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道__weak修饰的对象不会对对象进行retain,所以person_two指向的内存区域对象引用计数还是1.这里只有person_one强引用那块内存区域,当person_one = nil时,引用计数为0,内存区域被释放,person_two指向的内存地址为:0x0.</p><h3 id="2-3-unsafe-unretained-修饰符"><a href="#2-3-unsafe-unretained-修饰符" class="headerlink" title="2.3 __unsafe_unretained 修饰符"></a>2.3 __unsafe_unretained 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其表面意思一样:当没有强指针指向__unsafe_unretained修饰的对象时,这个对象会被置为nil,但是指向对象的指针不会被清空,苹果官方: the pointer is left dangling.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __unsafe_unretained person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:42:52.400375 TestARC[16608:5869804] person_one:(null),person_one地址:0x0这里已经报错:Thread 1: EXC_BAD_ACCESS (code=1, address=0xb84d2beb8)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-5666a219c62ae22c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unsafe__unretained所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在主线程中收到一条崩溃信息(EXC_BAD_ACCESS),通过<strong>unsafe_unretained官方文档解释,我们可以猜出address=0xb84d2beb8应该是person_one没被置为nil之前的内存地址,而当person_one = nil时,这块内存已经被回收,而person_two因为被</strong>unsafe_unretained修饰,其指针还没有被销毁,还想指向这块内存地址,所以造成了野指针错误.</p><h3 id="2-4-autoreleasing-修饰符"><a href="#2-4-autoreleasing-修饰符" class="headerlink" title="2.4 __autoreleasing 修饰符"></a>2.4 __autoreleasing 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorelease 本质上就是延迟调用 release,这里不做细致的分析了,大家感兴趣的可以自己找相关资料查看.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里我们对ARC的引用计数管理应该有了大概的了解.</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用计数的实现,我们可以通过查看苹果的源码(<a href="https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法</a>:</p><pre><code>- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上方法,就是编译器在合适的时机给对象所要发送的消息.我们点进去retain方法,我们可以在NSObject.mm文件的2138行可以看到其实现:</p><pre><code>// Replaced by ObjectAlloc- (id)retain {    return ((id)self)-&gt;rootRetain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;沿着调用链,我们可以在objc-object.h文件中看到id rootRetain(bool tryRetain, bool handleOverflow)方法的实现:</p><pre><code>LWAYS_INLINE idobjc_object::rootRetain(bool tryRetain, bool handleOverflow){    assert(!UseGC);    if (isTaggedPointer()) return (id)this;    bool sideTableLocked = false;    bool transcribeToSideTable = false;    isa_t oldisa;    isa_t newisa;    do {        transcribeToSideTable = false;        oldisa = LoadExclusive(&amp;isa.bits);        newisa = oldisa;        if (!newisa.indexed) goto unindexed;        // don&#39;t check newisa.fast_rr; we already called any RR overrides        if (tryRetain &amp;&amp; newisa.deallocating) goto tryfail;        uintptr_t carry;        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++        if (carry) {            // newisa.extra_rc++ overflowed            if (!handleOverflow) return rootRetain_overflow(tryRetain);            // Leave half of the retain counts inline and            // prepare to copy the other half to the side table.            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();            sideTableLocked = true;            transcribeToSideTable = true;            newisa.extra_rc = RC_HALF;            newisa.has_sidetable_rc = true;        }    } while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));    if (transcribeToSideTable) {        // Copy the other half of the retain counts to the side table.        sidetable_addExtraRC_nolock(RC_HALF);    }    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return (id)this; tryfail:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return nil; unindexed:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;    else return sidetable_retain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行sidetable_retain(),这个也是retain方法的最终调用的方法.而sidetable_retain()的实现:</p><pre><code>idobjc_object::sidetable_retain(){#if SUPPORT_NONPOINTER_ISA    assert(!isa.indexed);#endif    SideTable&amp; table = SideTables()[this];    if (table.trylock()) {        size_t&amp; refcntStorage = table.refcnts[this];        if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {            refcntStorage += SIDE_TABLE_RC_ONE;        }        table.unlock();        return (id)this;    }    return sidetable_retain_slow(table);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到这个方法中SideTable这个结构体,</p><pre><code>struct SideTable {    spinlock_t slock;    RefcountMap refcnts;    weak_table_t weak_table;    SideTable() {        memset(&amp;weak_table, 0, sizeof(weak_table));    }    ~SideTable() {        _objc_fatal(&quot;Do not delete SideTable.&quot;);    }    void lock() { slock.lock(); }    void unlock() { slock.unlock(); }    bool trylock() { return slock.trylock(); }    // Address-ordered lock discipline for a pair of side tables.    template&lt;bool HaveOld, bool HaveNew&gt;    static void lockTwo(SideTable *lock1, SideTable *lock2);    template&lt;bool HaveOld, bool HaveNew&gt;    static void unlockTwo(SideTable *lock1, SideTable *lock2);};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 RefcountMap 应该就是引用计数哈希表，而weak_table_t则是弱引用表(weak table).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefcountMap 则是一个简单的 map,其 key 为 object 内存地址，value 为引用计数值.通过SideTable源码，还可以得出如下结论：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在全局的若干个SideTable实例，它们保存在 static 成员变量table_buf中；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序运行过程中生成的所有对象都会通过其内存地址映射到table_buf中相应的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SideTable实例上.这里之所以会存在多个SideTable实例,object 映射到不同SideTable实例上,猜测是出于性能优化的目的，避免SideTable中的 reference table、weak table 过大.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到上面的sidetable_retain方法，其首先通过 object 的地址找到对应的 sidetale，然后通过 RefcountMap将该 object 的引用计数加1.简单地说，Apple 通过全局的 map 来记录Reference Counting，其key 为 object 地址，value 为引用计数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release、retainCount等相关方法的代码在该开源代码中也能找到,这里不细说了.</p><h2 id="4-ARC开发环境需要注意的管理内存"><a href="#4-ARC开发环境需要注意的管理内存" class="headerlink" title="4. ARC开发环境需要注意的管理内存:"></a>4. ARC开发环境需要注意的管理内存:</h2><h3 id="4-1CoreFoundation-Runtime以及其他C语言库的使用"><a href="#4-1CoreFoundation-Runtime以及其他C语言库的使用" class="headerlink" title="4.1CoreFoundation,Runtime以及其他C语言库的使用"></a>4.1CoreFoundation,Runtime以及其他C语言库的使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过malloc,create,copy等创建对象,还需要手动释放.</p><h3 id="4-2-循环引用"><a href="#4-2-循环引用" class="headerlink" title="4.2 循环引用"></a>4.2 循环引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环引用是两个或多个对象之间相互持有,形成环状,即使在没有外部对象指针指向这些对象内存区域(堆区)的时候,系统无法将每个对象的引用计数置为0,从而导致这些开辟出来的内存一直发挥着”占着茅坑不拉屎”的作用.这部分不容易检测,也容易背锅.不管新老司机遇到问题不假思索:循环引用的问题(所以遇到问题的时候,我们更多的是多思考,而不是在没有分析问题的情况下脱口而出,不仅误导别人,而且显得自己很水,多说了两句,见笑).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-674749fa15d20829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环引用示意图.png"></p><h2 id="5-内存管理检测"><a href="#5-内存管理检测" class="headerlink" title="5. 内存管理检测"></a>5. 内存管理检测</h2><h3 id="5-1-Analyze静态分析"><a href="#5-1-Analyze静态分析" class="headerlink" title="5.1 Analyze静态分析"></a>5.1 Analyze静态分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态内存分析, 指的是在程序没运行的时候, 通过预编译对代码进行预判断分析,分析代码的基本数据结构,语法等,编译器检查是否存在潜在的内存泄露及不规范的地方.常遇到问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)The ‘viewWillDisappear:’ instance method in UIViewController subclass ‘xxxxx’ is missing a [super viewWillDisappear:] call;这个错误提示是:重写父类中的实例方法viewWillDisappear,没有在子类中调用,从下图我们可以看到确实是这样,-(void)viewWillDisappear:(BOOL)animated方法内部调用的是[super viewDidAppear:animated];这种是很低级的错误.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-85ff5e032f373642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Value stored to ‘xxxxx’ is never read,声明的变量没有被用到<br><img src="https://upload-images.jianshu.io/upload_images/1715253-b74144bbc8d2352c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) API Misuse 接口应用错误,这里主要针对的是系统提供的接口<br>从下图中我们可以看到,_cachedStatements是一个字典,字典是不允许出现nil对象的,所以存数据之前我们要做容错判断.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-29cf84141853dc67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改完后就不再提示了<br><img src="https://upload-images.jianshu.io/upload_images/1715253-aa89d613c271f245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Memory error,内存错误:nil returned from a method that is expected to return a non-null value,方法返回中需要一个对象(指针),你返回了一个空指针.例如,下图在UITableView的数据源回调方法返回cell的方法中,本应返回一个UITableViewCell对象,可是这里返回了一个nil对象(空指针)<br><img src="https://upload-images.jianshu.io/upload_images/1715253-00e5d7fd34a88fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_4.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还存在其他潜在问题错误或者不规范的地方,大家可以照着这个自己去查找一下自己的项目.</p><h3 id="5-2-Instruments内存泄露检测"><a href="#5-2-Instruments内存泄露检测" class="headerlink" title="5.2 Instruments内存泄露检测"></a>5.2 Instruments内存泄露检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruments内存分析你应用内存的使用情况,帮助你查找定位出现问题的代码区域.详细介绍可以参考apple developer documentation(<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1</a>)<br>从文档中我们大概可以看到,一个应用所使用的内存可能占三种:</p><blockquote><p>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).<br>泄露的内存:应用无法再次应用或者释放的内存.<br>Abandoned memory: Memory still referenced by your application that has no useful purpose.<br>废弃的内存:你的应用还占据着这块内存,但是这块内存无法释放了,ARC中最有可能的是循环引用.<br>Cached memory: Memory still referenced by your application that might be used again for better performance.<br>缓存的内存:能够被你的应用正常释放回收利用的内存.<br>内存泄露：如果程序运行时一直分配内存而不及时释放无用的内存，程序占用的内存越来越大，直到把系统分配给该APP的内存消耗殚尽，程序因无内存可用导致崩溃，这样的情况我们称之为内存泄漏。可能引起的问题:<br>1)内存消耗殆尽的时候，程序会因没有内存被杀死，即crash。<br>2)当内存快要用完的时候，会非常的卡顿<br>3)如果是ViewController没有释放掉，引起的内存泄露，还会引起其他很多问题，尤其是和通知相关的。没有被释放掉的ViewController还能接收通知，还会执行相关的动作，所以会引起各种各样的异常情况的发生。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以我们现在开发的项目为例:这里打个广告,我们现在开发的应用叫做爱学.横版主要有我的班级,自学,消息,设置等模块,下面我们用Instruments来检查一下:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)打开调试工具步骤:首先先将待检测的源码安装到你的真机设备上(Command + r 或者 直接Run运行);然后按着快捷键:Command + Control + i,打开Instruments,选择Leaks.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)定位内存泄露区域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们选择call_tree,也就是函数调用栈,顺藤摸瓜,找到内存泄露的地方<br><img src="https://upload-images.jianshu.io/upload_images/1715253-35a0756984c09923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="call_tree.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8dd8d2a4259d6606.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="memory_leak.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不出意外,就可以看到具体内存泄露的代码了,我们这里是由于使用Runtime了,调用了class_copyPropertyList方法.我们知道Runtime是OC的底层,是OC的幕后工作者,所写的OC代码最终都转换成Runtime的C代码执行.这里通过class_copyPropertyList方法来获取类的所有成员变量的时候,没有释放.所以在使用C语言相关库的时候,一定要做好释放工作(不然装B就装大了😄,玩笑).最终在使用遍历完类中的成员变量后,free(properties);就没问题了.</p><pre><code>-(NSArray *)modelInfo:(Class)cls{    unsigned int  count = 0;    objc_property_t  * properties= class_copyPropertyList(cls, &amp;count);    NSMutableArray  * infoarr = [NSMutableArray new];    for (int i = 0; i&lt;count; i++)    {        objc_property_t property = properties[i];        NSString * name = [[NSString alloc]initWithCString:property_getName(property) encoding:NSUTF8StringEncoding ];        [infoarr addObject:name];    }    free(properties);    return infoarr;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的学习任务中一个视频类型的任务,视频播放器估计是从网上找的别人封装好的,没有细致分析就用了.从下图中我们可以看到至少有三个环,我们需要打破这种环状,消除引用循环,这里不细说,大家可以根据需要去详细看看怎么处理引用循环.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-96a1e31299fb670a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-bb436103f2dc0783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_2.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-15920f2bec2bed6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_3.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中简单介绍了iOS内存管理的相关内容,主要的还是ARC相关内容,这些大都是基于实际开发中的总结和平时学习的积累,里面不乏一些错误和不规范之处,希望没有没有大家没有被误导,更希望大家多给意见和建议.其实,基础知识扎牢了,对一些问题的理解,解决可能也会更加游刃有余,而不是天天纠结于一些”界面”上的问题.</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">https://blog.devtang.com/2016/07/30/ios-memory-management/</a><br><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS持续集成构建</title>
      <link href="/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前市面上持续集成的方案很多:例如,<strong>Jenkins, Fastlane,Xcode server</strong>等,这些持续集成的方案大同小异,他们之间的性能差异笔者没有做大量的横向分析,只是大体比较了一下打包时间.总结来说,持续集成主要是三个步骤:1.拉取代码;2.编译打包;3.分发数据(打包结果),下面将通过两种方案(Jenkins和Xcode server)来分析一下这三个过程.</p><h1 id="Jenkins集成方案"><a href="#Jenkins集成方案" class="headerlink" title="Jenkins集成方案"></a>Jenkins集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins作为免费集成方案,其社区拥有大量插件,非常友好,所以用户也众多.<br>首先来安装Jenkins,Jenkins官网提供了多个系统环境的软件包,我选择的是macOs系统,选择下载安装,步骤如下图:</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-74793443eb9d2e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Jenkins.png"></p><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-3767d8e62b58ab6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装Jenkins.png"></p><h3 id="设置管理员账号密码"><a href="#设置管理员账号密码" class="headerlink" title="设置管理员账号密码"></a>设置管理员账号密码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后,一般mac环境集成了Apache服务器会自动配置启动8080端口,Jenkins的初始化页面也会在安装完成后自动弹出.此时只要找到图中红色标记路径cat或者vi看一下里面的秘钥,进入Jenkins初始化设置工作.这个过程会设置管理员账号密码等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d1d90f913140c3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取初始密码Jenkins.png"></p><h3 id="Jenkins插件安装"><a href="#Jenkins插件安装" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化完成后,就可以利用管理员账号登录.登录后通常可以安装一些常用插件,一般有默认插件和自定义插件,选择默认插件即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4568ef21195c5c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins安装插件.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的环境搭建完成后,就可以实施上面的三个过程了.其实Jenkins的主要工作流程,可以通过下图来直观看出来.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-355b1d4d4cfc90bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins工作流程.png"></p><h2 id="步骤1-拉取代码"><a href="#步骤1-拉取代码" class="headerlink" title="步骤1 拉取代码"></a>步骤1 拉取代码</h2><p><img src="http://upload-images.jianshu.io/upload_images/1715253-fadcbca7317ace47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git仓库分支配置.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉取代码过程比较简单,主要是从指定仓库中克隆代码到Jenkins的工作目录.</p><h2 id="步骤2-编译打包"><a href="#步骤2-编译打包" class="headerlink" title="步骤2 编译打包"></a>步骤2 编译打包</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译打包命令主要有xcodebuild,xcrun,xctool(facebook)等,前两个是官方的,后一个是Facebook出品,xctool里面集成了个性化定制,需要的可以细研究一下,文中只是对xcodebuild做出使用分析.<br>xcodebuild编译过程也主要分三个过程:</p><pre><code>- clean    xcodebuild -workspace MyWorkspace.xcworkspace -scheme SchemeName- archive     xcodebuild archive -workspace MyWorkspace.xcworkspace -scheme SchemeName- export ipa     xcodebuild -exportArchive -archivePath MyMobileApp.xcarchive -exportPath ExportDestination.ipa -exportOptionsPlist &#39;exportPlist.plist&#39;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里多说两句:由于IDE变化,导致编辑脚本稍微有一些出入,主要是在编译的第三步(- export ipa),这步Xcode 8.0需要指定描述文件,Xcode 9.0需要指定exportOptionsPlist(这个是主要包含一些证书, ipa模式等键值表).下面贴出打包执行脚本的全部命令(Xcode 9.0):</strong></p><pre><code>export ETT_APP_NAME=app名称export ETT_WORKSPACE_NAME=工作区名称export ETT_SCHEME=scheme名称export ETT_PROVISIONING_PROFILE=描述文件(Xcode9.0用不到)export ETT_BUILD_TYPE=编译类型(用于区分发布还是AdHoc模式,可以忽略)export ETT_CONFIGURATION=编译配置(主要根据自己的多环境进行配置,比如Release,Debug等)###############################################################################################################export ETT_JENKINS_TIME=$(date +%m%d)export ETT_GIT_COMMIT=${GIT_COMMIT:0:7}export ETT_GIT_REV=`git rev-list HEAD | wc -l | awk &#39;{print $1}&#39;`export ETT_VERSION_PRO=`/usr/bin/agvtool mvers -terse1`export ETT_VERSION_NUMBER=$ETT_VERSION_PRO$ETT_BUILD_TYPEexport ETT_BUILD_VERSION=$ETT_GIT_REV.$BUILD_NUMBERexport ETT_BUILD_ID=$ETT_VERSION_NUMBER-$ETT_JENKINS_TIME-$ETT_GIT_REV-$BUILD_NUMBER-G$ETT_GIT_COMMITexport NEXUS_JENKINS_NAME=打包后上传账号export NEXUS_JENKINS_PASSWD=密码export ExportOptionsPlistPath=/Users/用户/Downloads/zhengshu/ExportOptions.plistexport XCODE=/usr/binexport ETT_DIST_ROOT_PATH=工作区路径export ETT_DIST_PATH=$ETT_DIST_ROOT_PATH/$BUILD_NUMBERexport ETT_ARCHIVE_PATH=$ETT_DIST_PATH/$ETT_APP_NAME.xcarchiveexport ETT_WORK_SPACE=$WORKSPACE/$ETT_WORKSPACE_NAME.xcworkspaceexport ETT_FILE_NAME=$ETT_APP_NAME-$ETT_BUILD_IDexport ETT_IPA_NAME=$ETT_FILE_NAME.ipaexport ETT_EXPORT_PATH=$ETT_DIST_PATH/$ETT_IPA_NAMEexport ETT_PACKAGE_NAME=$ETT_FILE_NAME.tar.gzexport ETT_PACKAGE_PATH=$ETT_DIST_PATH/$ETT_PACKAGE_NAMEexport ETT_NEXUS_FILE_NAME=$ETT_APP_NAME-$ETT_JENKINS_TIME-$BUILD_NUMBER-$ETT_GIT_COMMIT.tar.gzexport ETT_UPLOAD_DSYM_SRC=$ETT_WORKSPACE_NAME.app.dSYMexport ETT_UPLOAD_DSYM_FILE=$ETT_FILE_NAME-dSYM.zipexport ETT_UPLOAD_DSYM_PATH=$ETT_DIST_PATH/$ETT_UPLOAD_DSYM_FILEif [ ! -d &quot;$ETT_DIST_ROOT_PATH&quot; ]; then  mkdir $ETT_DIST_ROOT_PATHfiif [ ! -d &quot;$ETT_DIST_PATH&quot; ]; then  mkdir $ETT_DIST_PATHfi#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1/usr/bin/agvtool new-marketing-version $ETT_VERSION_PRO/usr/bin/agvtool new-version -all $ETT_VERSION_PRO.$ETT_BUILD_VERSION#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1$XCODE/xcodebuild clean build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; archive -archivePath &quot;$ETT_ARCHIVE_PATH&quot; -workspace $ETT_WORK_SPACE -destination generic/platform=iOS -scheme $ETT_SCHEME -configuration &quot;$ETT_CONFIGURATION&quot; BUILD_NUMBER=&quot;$ETT_BUILD_ID&quot; CONFIGURATION_BUILD_DIR=$ETT_DIST_PATH UPLOAD_dSYM_FILE=$ETT_UPLOAD_DSYM_FILE$XCODE/xcodebuild -exportArchive -archivePath $ETT_ARCHIVE_PATH -exportPath $ETT_EXPORT_PATH -exportOptionsPlist $ExportOptionsPlistPath -allowProvisioningUpdates</code></pre><h2 id="步骤3-分发数据-发布打包"><a href="#步骤3-分发数据-发布打包" class="headerlink" title="步骤3 分发数据(发布打包)"></a>步骤3 分发数据(发布打包)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程可以直接发布,也可以上传到自己指定的服务器,第三方托管服务器等.我们直接在执行打包脚本的最后面,将打包处理的ipa文件以及符号化文件打包后直接上传到指定服务器:</p><pre><code>cd $ETT_DIST_PATHzip -r $ETT_UPLOAD_DSYM_PATH $ETT_UPLOAD_DSYM_SRCtar -C $ETT_DIST_PATH -zcvf  $ETT_PACKAGE_PATH $ETT_IPA_NAME $ETT_UPLOAD_DSYM_FILEcurl -v -u $NEXUS_JENKINS_NAME:$NEXUS_JENKINS_PASSWD --upload-file $ETT_PACKAGE_PATH  服务器路径$ETT_APP_NAME/ios/$ETT_VERSION_PRO$ETT_BUILD_TYPE/$ETT_NEXUS_FILE_NAME</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>到这里,Jenkins的简单集成过程算完成了,里面涉及到一些环境变量和参数的设置,笔者因为还涉及到Swift和OC混合打包,问题稍多一点.因为业务需求不一样,需要自己去单独设置,有疑问的地方可以一起沟通一下.</strong></p><h1 id="Xcode-Server集成方案"><a href="#Xcode-Server集成方案" class="headerlink" title="Xcode Server集成方案"></a>Xcode Server集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案,将会把上面三个过程穿插进去,不在单列出来.网上有其他方案是macOS Server + Xcode Server集成方案,本文只是简单介绍一下通过Xcode Server集成</p><h3 id="打开Xcode-Server"><a href="#打开Xcode-Server" class="headerlink" title="打开Xcode Server"></a>打开Xcode Server</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-4cd4f93cfe501b21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Xcode Server.png"></p><h3 id="配置Xcode-Server管理员账号"><a href="#配置Xcode-Server管理员账号" class="headerlink" title="配置Xcode Server管理员账号"></a>配置Xcode Server管理员账号</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-6753a803a134b39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Xcode Server管理员账号.png"></p><h3 id="创建Bot-值守机器人"><a href="#创建Bot-值守机器人" class="headerlink" title="创建Bot(值守机器人)"></a>创建Bot(值守机器人)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置完成后,然后通过Xcode-&gt;Product-&gt;Create Bot<img src="http://upload-images.jianshu.io/upload_images/1715253-53baf11c43225437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建值守机器人.png"></p><h3 id="配置仓库分支"><a href="#配置仓库分支" class="headerlink" title="配置仓库分支"></a>配置仓库分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置代码仓库,Xcode集成了Git所以针对你的项目仓库直接添加分支即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-141e6996076bebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置仓库分支.png"></p><h3 id="编译打包参数配置"><a href="#编译打包参数配置" class="headerlink" title="编译打包参数配置"></a>编译打包参数配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分支添加完成后,就可配置编译的一些选项:scheme,ExportOptionsPlist,Configuration等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-5bacde388ac4ab5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译打包参数配置.png"></p><h3 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-1f389e834485879e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-04787e6efa4abd74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"></p><h3 id="添加签名文件"><a href="#添加签名文件" class="headerlink" title="添加签名文件"></a>添加签名文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步添加证书,描述文件等,作者这里选择的是自动签名模式,如果需要可自己指定签名证书,描述文件等,这里不再细说.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-24a9e3f9e9ab7c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加签名文件.png"></p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-bf5c804e22e172cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加环境变量.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步就是添加编译之前和编译打包之后的动作</p><h3 id="添加打包后的脚本命令"><a href="#添加打包后的脚本命令" class="headerlink" title="添加打包后的脚本命令"></a>添加打包后的脚本命令</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-200c086c7d6d92ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加打包后的脚本命令.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里你可以把打包结果上传到指定位置,脚本可自行查找.</p><h3 id="集成打包"><a href="#集成打包" class="headerlink" title="集成打包"></a>集成打包</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人创建完成后会自动运行编译打包一次,下次打包可以直接通过点击Integrate触发打包.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4ffe92eeb5c28e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集成打包.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两种方案,整个过程走下来并不是很复杂.这里提醒一下,由于Jenkins打包通过脚本命令执行编译打包,这个又依赖于一些环境变量和参数,如果一些插件和参数变了,IDE更新了,系统更新了等等原因,这些很容易造成打包失败,笔者经历多次了,一般就是先把命令拿到终端里面编译打包试一下,排除编译命令问题,然后在调试Jenkins环境.总结下来就是遇到问题时不要着急,慢慢分析,一点一点调试,总会解决的.</strong></p><p>最后打个广告:<br>模仿推特客户端(纯Swift开发,develop分支):<br><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a><br>针对这个客户端简单用Python写了几个接口:<br><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a><br>文章地址:<a href="https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉" target="_blank" rel="noopener">https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉</a>!</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
