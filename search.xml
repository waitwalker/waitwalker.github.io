<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flutter开发-Dart语言基础-2</title>
      <link href="/2019/06/12/Flutter%E5%BC%80%E5%8F%91-Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2/"/>
      <url>/2019/06/12/Flutter%E5%BC%80%E5%8F%91-Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2/</url>
      
        <content type="html"><![CDATA[<p>接着上篇Dart语言基础.</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Dart和其他语言一样多种,支持多种运算.</p><h4 id="点运算语法糖"><a href="#点运算语法糖" class="headerlink" title="点运算语法糖"></a>点运算语法糖</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点运算和Swift中的使用类似,对象点属性相当于调用属性的getter方法,对象点方法表示调用此方法.</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算术运算是一些基础运算方式:加减乘除,取余,取模等,还有自增自减运算.</p><pre><code>int a = 10;int b = a++;int c = ++a;print(&quot;a=$a,b=$b,c=$c&quot;);I/flutter (27692): a=12,b=10,c=12</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里说一下,++在前,表示先自增再赋值运算;++在后,表示先赋值运算再自增.</p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系运算符一般用来判断对象之间的关系,比如相等==,不相等!=,大于小于等.</p><pre><code>int a = 10;int b = a++;int c = ++a;print(&quot;a=$a,b=$b,c=$c&quot;);print(&quot; a &gt; c ? ${a &gt; c}&quot;);I/flutter (27692): a &gt; c ? false</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算就是与或非(&amp;&amp;,||,!).</p><pre><code>int a = 10;int b = a++int c = ++a;print(&quot;a=$a,b=$b,c=$c&quot;);print(&quot; a &gt; c ? ${a &gt; c}&quot;);print(&quot;a &gt;= c &amp;&amp; a &gt; b ? ${a &gt;= c &amp;&amp; a &gt; b}&quot;);I/flutter (27692): a=12,b=10,c=12I/flutter (27692): a &gt; c ? falseI/flutter (27692): a &gt;= c &amp;&amp; a &gt; b ? true</code></pre><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位运算符常用来操作对象的Bit进行操作:按位与&amp;,按位或|,按位异或^,按位取反~,向左移&lt;&lt;,向右移&gt;&gt;.</p><pre><code>int d = 8;int e = (d &lt;&lt; 1);print(&quot;e = $e&quot;);I/flutter (27692): e = 16</code></pre><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;条件表达式有三目运算和双目运算,和其他语言一样.</p><pre><code>// 三目表达式int f = a &gt; c ? 13 : 14;print(&quot;f = $f&quot;);// 双目表达式int m = a ?? 18;print(&quot;m = $m&quot;);I/flutter (27692): f = 14I/flutter (27692): m = 12</code></pre><h4 id="类型转换验证运算符"><a href="#类型转换验证运算符" class="headerlink" title="类型转换验证运算符"></a>类型转换验证运算符</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart中可以将一个对象强制转换为另一个对象(这个对象可以是自身,也可以为其他),操作符为as.一般用来强转为自身类的实例,转为其他类型编译期不会报错,但是运行期会报错,抛异常.</p><pre><code>int a = 10;double q = (a as double);print(&quot;q = $q&quot;);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-e405653582cc76f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as error"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型验证运算-is就是判断某个对象是否是某个类的实例,和Swift中的内省方法isClassOf功能类似,如果要取反判断直接在is后面加!也就是is!:</p><pre><code>print(&quot;student is Student ? ${student is Student}&quot;);I/flutter (27692): student is Student ? trueprint(&quot;student is Student ? ${student is! Student}&quot;);</code></pre><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;级联操作表示的是一个对象可以连续操作,这个思想一般可以用来链式编程.</p><pre><code>Person.init(1.8,20)  ..getAge()  ..getHeight();I/flutter (27692): age is:20I/flutter (27692): height is:1.8</code></pre><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流程控制语句目标是控制程序执行的逻辑流程.</p><h4 id="if和esle条件流程控制"><a href="#if和esle条件流程控制" class="headerlink" title="if和esle条件流程控制"></a>if和esle条件流程控制</h4><pre><code>if (&quot;flutter&quot; is String) {  print(&quot;yes&quot;);} else if (&quot;flutter&quot; is int) {  print(&quot;int&quot;);} else {  print(&quot;no&quot;);}</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart中遍历一个集合可以通过for循环或者while以及do while</p><pre><code>// forfor (var i = 0; i &lt; 12; i++) {  print(&quot;i = $i&quot;);}// for inList list_m = [1,2,3,3];for (var value in list_m) {  print(&quot;value = $value&quot;);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do while 和whlie区别在于do先执行一次循环然后再判断是都继续执行,while循环是先判断条件然后执行循环.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行循环的过程中可以通过循环控制语句来终止或者跳过本次循环,分别是break和continue.</p><h4 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Switch语句是多条件判断的特殊情况,这里和Swift语法几乎一样.</p><pre><code>switch (a) {  case 1:    print(1);    break;  case 2:    print(2);    break;  case 3:    print(3);    break;  default:    print(12);}</code></pre><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;断言是验证程序是否满足条件的一种方式,如果不满足设定的条件直接中断运行.</p><pre><code>int a = 10;int b = a++;int c = ++a;// 断言assert(a&gt; c);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为a不大于c,程序抛异常,停止运行.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-fbafd5941c3ac58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="assert"></p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异常即非正常,在执行某段代码时如果程序发生错误,我们能够预知可能发生的错误,然后将错误捕获处理,防止程序终止.Dart中的异常和Objective-C中的几乎一样.</p><pre><code>try {  person.getAge();} catch (e) {  print(&quot;e:$e&quot;);} finally {  print(&quot;finish do&quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 开发 </tag>
            
            <tag> Dart </tag>
            
            <tag> iOS </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter开发-Dart语言基础</title>
      <link href="/2019/06/11/Flutter%E5%BC%80%E5%8F%91-Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/06/11/Flutter%E5%BC%80%E5%8F%91-Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart是一种易于学习,易于扩展,并且可以部署到任何地方的应用编程语言.Dart是面向对象的编程语言,由Google在2011推出.</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h3><p>1)Dart真正实现了”一切皆对象”,即使数值类型,函数方法和null都是对象,上帝类是Object类.<br>2)Dart是强类型语言,类型标识是可选的,Dart会自动推断变量的具体类型.如果要指明某个对象为不确定类型,可以用dynamic(动态性)关键字来修饰变量.<br>3)Dart支持泛型,和Swift类似.<br>4)Dart支持顶级函数(main函数等,也是程序的入口),静态方法,实例方法.支持嵌套函数(函数内部创建函数)等.<br>5)Dart没有public,private等关键字,默认一些变量和方法都是公有的,如果想声明私有变量或者方法,可以用”_(下户线)”开头声明.<br>6)Dart可以使用分号作为语句的结束,也可以不写.<br>7)Dart注释.//和/**/</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的定义用var关键字-类型可以不写"><a href="#变量的定义用var关键字-类型可以不写" class="headerlink" title="变量的定义用var关键字,类型可以不写:"></a>变量的定义用var关键字,类型可以不写:</h4><pre><code>var name = &quot;flutter&quot;;// String类型var age = 20; // int 类型var height = 1.80; // Double 类型</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当给变量赋值的时候,变量的类型已经确定,此时不能给变量赋值其他类型值:</p><pre><code>var name = &quot;flutter&quot;; //Stringname = 12;// 此时报错</code></pre><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/Dart/var%20error.png?raw=true" alt="var error"></p><h4 id="可以使用特定类型来定义变量"><a href="#可以使用特定类型来定义变量" class="headerlink" title="可以使用特定类型来定义变量"></a>可以使用特定类型来定义变量</h4><pre><code>String newName = &quot;my flutter&quot;;int newAge = 21;double newHeighth = 1.85;</code></pre><h4 id="变量的类型如果可变-可以用dynamic或者Obejct关键字来定义变量"><a href="#变量的类型如果可变-可以用dynamic或者Obejct关键字来定义变量" class="headerlink" title="变量的类型如果可变,可以用dynamic或者Obejct关键字来定义变量"></a>变量的类型如果可变,可以用dynamic或者Obejct关键字来定义变量</h4><pre><code>dynamic flu = &quot;Flutter&quot;; //String类型print(&quot;flu的值为:$flu&quot;);flu = 12; //int 类型print(&quot;flu的值为:$flu&quot;);I/flutter (25846): 开始点击countI/flutter (25846): 点击完成count=1I/flutter (25846): flu的值为:FlutterI/flutter (25846): flu的值为:12Object da = &quot;Dart&quot;;print(&quot;da的值为:$da&quot;);da = 2.0;print(&quot;da的值为:$da&quot;);I/flutter (25846): da的值为:DartI/flutter (25846): da的值为:2.0</code></pre><h4 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h4><p>如果声明一个变量而没有给他赋值的话,其默认值是null,null在Flutter中也是一个对象.</p><pre><code>var stuName;print(&quot;stu name:$stuName&quot;);dynamic stuNewName;print(&quot;stu new name:$stuNewName&quot;);I/flutter (25846): stu name:nullI/flutter (25846): stu new name:null</code></pre><h4 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h4><p>class关键字用于创建一个类,如果不指明继承哪个类,默认继承上帝类Object</p><pre><code>class Student extends Object {}</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="final-和-const"><a href="#final-和-const" class="headerlink" title="final 和 const"></a>final 和 const</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个想定义一个常量,即一个变量的值被赋值后一直不会改变,可以通过final和const来声明,final修饰的变量在声明时不赋值,而在对象初始化时赋值;const修饰的变量必须赋值,否则报错.final 类似于Swift或者OC中的只读属性.</p><pre><code>class Student extends Object {  static const constVar; //const 修饰的变量必须赋值  final name;  Student(this.name);}// 使用Student stu_1 = Student(&quot;waitwalker&quot;);print(&quot;stu_1 name:${stu_1.name}&quot;);I/flutter (25846): stu_1 name:waitwalker</code></pre><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/Dart/final%20error.png?raw=true" alt="final error"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const 修饰的变量赋值后就不会报错了,此时如果给stu_1.name重新赋值会报错,final修饰的变量不允许调用setter方法:</p><pre><code>class Student extends Object {  static const constVar = &quot;const 修饰的变量必须赋值&quot;; //const 修饰的变量必须赋值  final name;  Student(this.name);}// 使用Student stu_1 = Student(&quot;waitwalker&quot;);print(&quot;stu_1 name:${stu_1.name}&quot;);stu_1.name = &quot;new&quot;;</code></pre><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/Dart/const%20error.png?raw=true" alt="const error"></p><h3 id="Dart标准库中内置类型"><a href="#Dart标准库中内置类型" class="headerlink" title="Dart标准库中内置类型"></a>Dart标准库中内置类型</h3><h4 id="判断对象的类型"><a href="#判断对象的类型" class="headerlink" title="判断对象的类型"></a>判断对象的类型</h4><p>在上帝类中有个只读属性runtimeType用于获取对象的类型:</p><pre><code>print(&quot;stu_1 type:${stu_1.runtimeType}&quot;);print(&quot;stu_1 type:${stu_1.name.runtimeType}&quot;);I/flutter (25846): stu_1 type:StudentI/flutter (25846): stu_1 type:String</code></pre><h4 id="数值类型num"><a href="#数值类型num" class="headerlink" title="数值类型num"></a>数值类型num</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num是Dart基本数值类型,其是int和doule的父类,Dart只有整型和浮点型两种基本数据类型,其长度依据操作系统自由伸缩:</p><pre><code>abstract class int extends num {}abstract class double extends num {}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到int类在num基本的运算操作基础上增加了一些位运算方法,double增加了一些如取绝对值等方法.</p><h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String是charCodes字符的集合,charCodes默认采用的是UTF-16编码,一个String在定义时可以采用单引号或者双引号将内容包起来.</p><pre><code>abstract class String implements Comparable&lt;String&gt;, Pattern {}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果多行字符串,可以采用三重(单/双)引号,将内容包起来,这个类似于Python和Swift的相关语法.</p><pre><code>String today = &quot;&quot;&quot;Today is very hot.Yes.No.&quot;&quot;&quot;;print(&quot;toady:$today&quot;);I/flutter (26474): toady: Today is very hot.I/flutter (26474): Yes.I/flutter (26474): No.</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String类中还定义了一些截串,获取索引,比较两个字符串,获取长度等一些常规方法.</p><h4 id="布尔类型bool"><a href="#布尔类型bool" class="headerlink" title="布尔类型bool"></a>布尔类型bool</h4><p>bool类型很简单,非零即真:</p><pre><code>bool isiPad = false;print(&quot;is iPad:$isiPad&quot;);I/flutter (26474): is iPad:false</code></pre><h4 id="集合类型List"><a href="#集合类型List" class="headerlink" title="集合类型List"></a>集合类型List</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart中集合类型List和Python中的List可以说一脉相承,List是一个泛型集合,可以存储任何需要的对象类型,其常规的增删改查操作方法和其他语言集合类型相似.</p><pre><code>List list = [&quot;date&quot;,12,45.0,&quot;weather&quot;]; //初始化方式List list_a = List(10); //指定长度初始化list_a.add(&quot;12&quot;); //添加操作list_a.add(12);list_a.removeAt(1); //移除指定索引位置元素list_a.removeLast(); //移除最后一个元素</code></pre><h4 id="字典类型-键值类型-Map"><a href="#字典类型-键值类型-Map" class="headerlink" title="字典类型(键值类型)Map"></a>字典类型(键值类型)Map</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart中的Map类型和其他语言中Map或者Dictionary中相似,在定义的时候可以指定键值得类型.</p><pre><code>Map dic = Map();dic[&quot;name&quot;] = &quot;flutter&quot;;dic[&quot;version&quot;] = &quot;1.2&quot;;Map dic_a = {&quot;name&quot;:&quot;flutter&quot;,&quot;version&quot;:&quot;1.2&quot;};print(&quot;dic:$dic&quot;);print(&quot;dic_a:$dic_a&quot;);I/flutter (26474): dic:{name: flutter, version: 1.2}I/flutter (26474): dic_a:{name: flutter, version: 1.2}</code></pre><h4 id="Runes类型"><a href="#Runes类型" class="headerlink" title="Runes类型"></a>Runes类型</h4><p>Runes类型一般用于编码特殊的Unicode,例如emoji.</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是程序功能的集合.</p><h4 id="方法的常规定义"><a href="#方法的常规定义" class="headerlink" title="方法的常规定义"></a>方法的常规定义</h4><pre><code>返回值类 方法名() {return value;}// 例如String getName() {return name;}Student stu_1 = Student(&quot;waitwalker&quot;);print(&quot;stu_1 name:${stu_1.name}&quot;);String newN = stu_1.getName();print(&quot;newN:$newN&quot;);I/flutter (26474): stu_1 name:waitwalkerI/flutter (26474): newN:waitwalker</code></pre><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart方法的参数可以是变量也可以是一个方法,如果方法参数是一个变量,可以指定变量类型也可以不指定,建议指定.</p><p>方法中也可以设定可选参数,可选参数用[]包起来.</p><pre><code>// 显示名称String showName(String firstName) {  return name + firstName;}Student student = Student(&quot;xiaoming&quot;);String fullName = student.showName(&quot;wang&quot;);print(&quot;full name:$fullName&quot;);I/flutter (26474): full name:xiaomingwang</code></pre><h4 id="方法作为参数"><a href="#方法作为参数" class="headerlink" title="方法作为参数"></a>方法作为参数</h4><p>Dart允许在方法中传递参数,其实传递的是方法的地址:</p><pre><code>int sum(int a, int b) {  print(&quot;sum result:${a + b}&quot;);  return a + b;}int toatl(int a, int b, Function getSum) {  return getSum(a,b);}void result() {int r = toatl(12, 18, sum);print(&quot;result:$r&quot;);}Student student = Student(&quot;xiaoming&quot;);String fullName = student.showName(&quot;zhang&quot;,12);print(&quot;full name:$fullName&quot;);student.result();I/flutter (26474): sum result:30I/flutter (26474): result:30</code></pre><h4 id="方法参数默认值"><a href="#方法参数默认值" class="headerlink" title="方法参数默认值"></a>方法参数默认值</h4><p>在定义方法时,可选参数也可以指定一个默认值:</p><pre><code>// 显示名称String showName(String firstName, [int age = 20]) {return name + firstName + &quot;age is&quot; + age.toString();}Student student = Student(&quot;xiaoming&quot;);String fullName = student.showName(&quot;zhang&quot;,12);print(&quot;full name:$fullName&quot;);I/flutter (26474): full name:xiaomingzhang age is12</code></pre><h4 id="方法中嵌套方法"><a href="#方法中嵌套方法" class="headerlink" title="方法中嵌套方法"></a>方法中嵌套方法</h4><p>Dart语法方法中是可以嵌套方法的:</p><pre><code>void size(int a) {void intervalSize () {print(&quot;size in:$a&quot;);}print(&quot;size out:$a&quot;);}</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dart中匿名函数和Python中的lamada匿名函数一样,不用给方法起名字了,在定义的时候直接用一个变量来接收,引用时直接引用这个变量:</p><pre><code>var lamadaFunc = (String name) =&gt; &quot;${name}&quot;;student.lamadaFunc(&quot;wangxiaoming&quot;);</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包是对匿名函数的一种应用,Dart 其在Function类型,而在Swift中常当作函数参数用于一些异步回调,在Dart定义:</p><pre><code>Function totalNum(int a) {return (int b) =&gt; a + b;}var totalNum = student.totalNum(12);var value = totalNum(3);print(&quot;value:$value&quot;);I/flutter (26474): value:15</code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 开发 </tag>
            
            <tag> Dart </tag>
            
            <tag> iOS </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac Flutter 环境搭建</title>
      <link href="/2019/06/10/Mac-Flutter-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/06/10/Mac-Flutter-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>以下内容是再Mac上搭建Flutter开发环境的过程:</p><h4 id="1-添加环境变量"><a href="#1-添加环境变量" class="headerlink" title="1. 添加环境变量"></a>1. 添加环境变量</h4><p>Mac 一般使用bash作为默认shell<br>Mac系统的环境变量，加载顺序为：<br>/etc/profile<br>/etc/paths<br>~/.bash_profile<br>~/.bash_login<br>~/.profile<br>~/.bashrc</p><p>/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。<br>设置PATH的语法都为：</p><pre><code>export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</code></pre><h4 id="2-全局设置"><a href="#2-全局设置" class="headerlink" title="2. 全局设置"></a>2. 全局设置</h4><p>下面的几个文件设置是全局的，修改时需要root权限<br>1）/etc/paths （全局建议修改这个文件 ）<br>编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径</p><p>2）/etc/profile （建议不修改这个文件 ）<br>全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p><p>3）/etc/bashrc （一般在这个文件中添加系统级环境变量）<br>全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p><h4 id="3-单个用户设置"><a href="#3-单个用户设置" class="headerlink" title="3. 单个用户设置"></a>3. 单个用户设置</h4><p>1）~/.bash_profile （任意一个文件中添加用户级环境变量）<br>（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）</p><p>若bash shell是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量<br>置命令别名alias ll=’ls -la’<br>设置环境变量：</p><pre><code>export PATH=/opt/local/bin:/opt/local/sbin:$PATH</code></pre><p>2）~/.bashrc 同上<br>如果想立刻生效，则可执行下面的语句：<br>$ source 相应的文件<br>一般环境变量更改后，重启后生效。</p><h4 id="4-编辑-bash-profile文件-添加如下环境变量"><a href="#4-编辑-bash-profile文件-添加如下环境变量" class="headerlink" title="4. 编辑~/.bash_profile文件,添加如下环境变量:"></a>4. 编辑~/.bash_profile文件,添加如下环境变量:</h4><pre><code>vi ~/.bash_profile</code></pre><p>保存退出,并使文件生效</p><pre><code>source ~/.bash_profile</code></pre><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/DevelopmentEnvironment/%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png?raw=true" alt="添加环境变量.png"></p><h4 id="5-下载Flutter-SDK"><a href="#5-下载Flutter-SDK" class="headerlink" title="5. 下载Flutter SDK"></a>5. 下载Flutter SDK</h4><p>去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="noopener">转到下载页</a>, 下载完成后解压安装包到你想安装的目录.</p><pre><code>cd ~/development unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</code></pre><h4 id="6-查看Flutter相关依赖是否安装完成-执行-flutter-doctor命令"><a href="#6-查看Flutter相关依赖是否安装完成-执行-flutter-doctor命令" class="headerlink" title="6. 查看Flutter相关依赖是否安装完成,执行 flutter doctor命令:"></a>6. 查看Flutter相关依赖是否安装完成,执行 flutter doctor命令:</h4><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/DevelopmentEnvironment/Flutter%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96.png?raw=true" alt="Flutter相关依赖.png"></p><p>如果有[!] ✗ 标志，表示本行检测不通过，需要做一些设置或者安装一些软件</p><p>解决Downloaded executables cannot execute on host.问题</p><pre><code>rm -rf ~/flutter/bin/cache flutter doctor --verbose</code></pre><h4 id="7-安装设备依赖库"><a href="#7-安装设备依赖库" class="headerlink" title="7. 安装设备依赖库"></a>7. 安装设备依赖库</h4><pre><code>✗ libimobiledevice and ideviceinstaller are not installed. To install with Brew, run:brew updatebrew install --HEAD usbmuxdbrew link usbmuxdbrew install --HEAD libimobiledevicebrew install ideviceinstaller✗ ios-deploy not installed. To install:brew install ios-deploy</code></pre><p>其它问题照着Flutter给的提示解决就可以了.</p><h4 id="8-Android-Studio安装Flutter插件"><a href="#8-Android-Studio安装Flutter插件" class="headerlink" title="8. Android Studio安装Flutter插件"></a>8. Android Studio安装Flutter插件</h4><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/DevelopmentEnvironment/Android%20Studio%E5%AE%89%E8%A3%85Flutter%E6%8F%92%E4%BB%B6.png?raw=true" alt="Android Studio安装Flutter插件.png"></p><h4 id="9-Visual-Studio-Code安装Flutter插件"><a href="#9-Visual-Studio-Code安装Flutter插件" class="headerlink" title="9. Visual Studio Code安装Flutter插件"></a>9. Visual Studio Code安装Flutter插件</h4><p><img src="https://github.com/waitwalker/Resources/blob/master/Flutter/DevelopmentEnvironment/VS%20code%E5%AE%89%E8%A3%85Flutter%E6%8F%92%E4%BB%B6.png?raw=true" alt="VS code安装Flutter插件.png"></p><h4 id="10-创建demo"><a href="#10-创建demo" class="headerlink" title="10. 创建demo"></a>10. 创建demo</h4><p>新建空项目:</p><pre><code>flutter create project_name</code></pre><p>查看所有设备:</p><pre><code>flutter devices</code></pre><p>运行项目:</p><pre><code>flutter run</code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 开发 </tag>
            
            <tag> Dart </tag>
            
            <tag> iOS </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI</title>
      <link href="/2019/06/05/SwiftUI/"/>
      <url>/2019/06/05/SwiftUI/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2019 年 WWDC 大会上，苹果在压轴环节向大众宣布了基于 Swift 语言构建的全新 UI 框架 —— SwiftUI。开发者可通过它快速为所有的 Apple 平台创建美观、动态的应用程序。在介绍过程中，苹果公司软件工程高级副总裁 Craig Federighi 演示了如何将一百行代码简化为大约十几行。<br><img src="https://github.com/waitwalker/Resources/blob/master/SwiftUI/SwiftUI_1.jpg?raw=true" alt="SwiftUI_1"><br><img src="https://github.com/waitwalker/Resources/blob/master/SwiftUI/SwiftUI_2.png?raw=true" alt="SwiftUI_2"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;据官方介绍，SwiftUI 是一个创新且非常方便使用的框架，开发者通过 Swift 语言的强大功能即可为苹果的所有硬件设备构建用户界面 —— 只需使用一套工具和 API。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，SwiftUI 使用了声明式的 Swift 语法，可读性比较高，编写起来也比较容易理解。SwiftUI 可与新的 Xcode 设计工具无缝协作，让代码和设计完美同步，还提供对动态类型、暗黑模式、本地化和可访问性的自动支持。下面简单介绍一下 SwiftUI。</p><h3 id="声明式语法"><a href="#声明式语法" class="headerlink" title="声明式语法"></a>声明式语法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SwiftUI 使用了声明式语法，所以开发者能够十分轻易地描述用户界面应该做什么。例如，编写需要包含文本字段的项目列表时，开发者可以用代码描述每个字段的对齐方式、字体和颜色。代码也比以前更简单，更易于阅读。<br><img src="https://github.com/waitwalker/Resources/blob/master/SwiftUI/SwiftUI_3.jpg?raw=true" alt="SwiftUI_3"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种声明式风格非常适用于像动画这样复杂的元素。通过 SwiftUI，开发者可轻松地将动画添加到几乎任何控件。</p><h3 id="拥有更直观的新设计工具"><a href="#拥有更直观的新设计工具" class="headerlink" title="拥有更直观的新设计工具"></a>拥有更直观的新设计工具</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xcode 11 包含更直观的新设计工具，可让开发者通过拖拽的方式使用 SwiftUI 构建界面，在这过程中可以直接设置控件的相关属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当在设计工具中工作时，所编辑的内容会立刻反映到代码上，如果从模拟器切换到手机，手机也能立马看到预览效果。<br><img src="https://github.com/waitwalker/Resources/blob/master/SwiftUI/SwiftUI_4.png?raw=true" alt="SwiftUI_4"></p><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><iframe src="https://v.youku.com/v_show/id_XNDIxNzE0ODI4NA==.html?spm=a2h3j.8428770.3416059.1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="580" quality="high"> </iframe><h3 id="完整教程请参考"><a href="#完整教程请参考" class="headerlink" title="完整教程请参考:"></a>完整教程请参考:</h3><p><a href="https://juejin.im/post/5cf5f4596fb9a07ede0b2fa1" target="_blank" rel="noopener">https://juejin.im/post/5cf5f4596fb9a07ede0b2fa1</a></p>]]></content>
      
      
      <categories>
          
          <category> WWDC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
            <tag> iOS 13.0 </tag>
            
            <tag> iPadOS 13.0 </tag>
            
            <tag> WWDC </tag>
            
            <tag> Swift UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WWDC 2019</title>
      <link href="/2019/06/05/WWDC-2019/"/>
      <url>/2019/06/05/WWDC-2019/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果在今天的WWDC 2019苹果开发者大会上发布了全新的iOS 13系统。传了很久期待很久的黑暗模式也出现在了全新的iOS 13系统上。黑暗模式为iPhone带来了一种引人注目的全新外观。<br><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_1.jpeg?raw=true" alt="iOS 13.0_1"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全新的黑暗模式为 iPhone 带来了一种引人注目的全新外观，以及在 iOS 上浏览和编辑照片，登录应用程序和网站以及使用全新地图浏览世界的新方法。通过整个系统的优化，iOS 13 更快，App 响应更快，可以改善应用启动，减少应用程序下载大小并使 Face ID 体验更加无缝。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_2.png?raw=true" alt="iOS 13.0_2"></p><h3 id="黑暗模式：iPhone-的戏剧性新面貌"><a href="#黑暗模式：iPhone-的戏剧性新面貌" class="headerlink" title="黑暗模式：iPhone 的戏剧性新面貌"></a>黑暗模式：iPhone 的戏剧性新面貌</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iPhone 采用了黑暗模式（Dark Mode），这是一种新的深色配色方案，适用于全系统和所有原生应用程序，可提供出色的观看体验，尤其是在低光环境下。第三方应用开发者可以使用暗模式集成到自己的应用中，并可以安排在日落时或特定时间自动开启。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_3.jpeg?raw=true" alt="iOS 13.0_3"></p><h3 id="更轻松的浏览和强大的照片编辑工具"><a href="#更轻松的浏览和强大的照片编辑工具" class="headerlink" title="更轻松的浏览和强大的照片编辑工具"></a>更轻松的浏览和强大的照片编辑工具</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用设备上的机器学习， 原生照片 App 会对整个图片库进行智能筛选以突出最佳图像，自动隐藏杂乱和类似的照片，以展示过去的一天，一个月或一年中的重大事件。照片和视频采用智能组织，可以更轻松地浏览、发现和重温最喜爱的记忆，并通过自动播放视频直观地展示给用户。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_4.jpeg?raw=true" alt="iOS 13.0_4"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过更便捷的调整和查看新工具，照片编辑变得更全面和直观。只需轻扫一下，添加的修改效果就可以增加或减少，以创造完美的视觉感官，为摄影师提供更多的创作可能性并控制他们的图像。在 iOS 13 中，大多数照片编辑工具现在也可以用在视频编辑中，你可以在对视频进行旋转，裁剪或应用滤镜了。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_5.jpeg?raw=true" alt="iOS 13.0_5"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 iOS 13，可以在相机应用程序中进行人像调整，以便将光线移近，使眼睛更加有神，使面部特征更加明亮和平滑，或者将光线推得更远，从而营造出微妙、精致的形象。全新的高调单色效果还为人像模式创造了美丽的单色构图。</p><h3 id="快速、轻松和私密的-Apple-登录"><a href="#快速、轻松和私密的-Apple-登录" class="headerlink" title="快速、轻松和私密的 Apple 登录"></a>快速、轻松和私密的 Apple 登录</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果正在推出一种新的，更私密的方式来简单快速地登录应用和网站。用户可以简单地使用他们的 Apple ID 进行身份验证，而无需使用社交帐户或填写表单，验证电子邮件地址或选择密码，苹果会通过唯一的随机 ID 来保护用户的隐私。即使在开发人员选择要求提供姓名和电子邮件地址的情况下，用户也可以选择将其电子邮件地址保密，并共享一个独特的随机电子邮件地址。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_6.jpeg?raw=true" alt="iOS 13.0_6"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 Apple 登录可以让用户轻松通过 Face ID 或 Touch ID 进行身份验证，并且内置双因素身份验证以增加安全性。苹果承诺不会使用 Apple 登录来分析用户以及他们在应用中的活动。</p><h3 id="全新的地图体验"><a href="#全新的地图体验" class="headerlink" title="全新的地图体验"></a>全新的地图体验</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple Maps 可帮助数百万人浏览和探索世界，同时保护用户隐私。在驾驶 400 万英里从头开始重建底图后，苹果正在提供新的地图体验，包括更广泛的道路覆盖范围，更好的行人数据，更精确的地址和更详细的土地覆盖。新地图现已在部分城市和州推出，并将于 2019 年底在美国推广，2020 年将推广到更多国家。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_7.jpeg?raw=true" alt="iOS 13.0_7"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新的底图和高分辨率 3D 摄影的支持下，全新的 Look Around 功能可以为城市提供美丽的街道图像，并实现平滑无缝的过渡。iOS 13 为地图应用带来了额外的新功能，包括轻松分享喜爱的餐厅，旅游目的地或与朋友一起购物的地方的收藏品，以及用于导航到常用目的地（如家庭、公司、健身房或学校）的收藏夹，只需简单点击屏幕就能启用。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_8.jpeg?raw=true" alt="iOS 13.0_8"></p><h3 id="其他补充更新功能"><a href="#其他补充更新功能" class="headerlink" title="其他补充更新功能"></a>其他补充更新功能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提醒功能现已拥有全新的外观，并提供创建和编辑提醒的智能方法，以及更多组织和跟踪提醒的方法。快速工具栏可以更轻松地添加时间、日期、位置和标记，或添加附件。通过与消息进行更深入的集成，可以很容易地在提醒中标记某人，以便在用户向该人发送消息时显示。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_9.png?raw=true" alt="iOS 13.0_9"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息可以自动共享用户的姓名和照片，或自定义的 Memoji 或 Animoji，以便轻松识别消息线程中的人员。Memoji 会自动制作成 iOS 键盘内置的贴纸包，可以在消息，邮件和其他应用中使用。Memoji 还有新发型、头饰、化妆、耳饰和挂饰等新装扮。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_10.jpeg?raw=true" alt="iOS 13.0_10"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Siri 改进了新的，更自然的人声，Siri Shortcuts 现在支持推荐的自动化，为上班或去健身房等事项提供个性化的例程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CarPlay 凭借新的仪表板获得了有史以来最大的更新，可以在一个视图中查看音乐、地图等，新的日历应用以及 Siri 现已支持第三方导航和音频应用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HomePod 可以区分家中任何人的声音，以提供个人请求，包括消息、音乐等。Siri 可以从 iHeartRadio，radio.com 和 TuneIn 访问超过 100,000 个电台，新的睡眠定时器会在一段时间后关闭音乐。Handoff 使用户能够在回家后轻松地将音乐，播客或电话转移到 HomePod 上继续播放。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_11.jpeg?raw=true" alt="iOS 13.0_11"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 AirPods，Siri 可以在收到消息后立即从消息或任何支持 SiriKit 的消息应用程序中读取传入消息。通过简单地将第二对AirPods 靠近 iPhone 或 iPad，就可以轻松地与朋友一起观看电影或分享歌曲。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_12.jpeg?raw=true" alt="iOS 13.0_12"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语音控制提供强大的全新体验，使用户可以完全通过语音操作 iPhone，iPad 或 Mac。语音控制采用最新的 Siri 语音识别技术，可以更准确地进行文本转录和编辑。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_13.jpeg?raw=true" alt="iOS 13.0_13"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notes 具有新的 Gallery View 与共享文件夹，支持新搜索工具和清单选项的更强大协作。滑键输入（QuickPath）可通过连续滑动单词的字母，为 iOS 键盘提供单手打字体验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文本编辑功能得到增强，可以滚动文档，移动光标并更快，更准确地选择文本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件管理（Files）App 引入了与 iCloud Drive 共享文件夹的功能，以及从外部存储设备（如 SD 卡和 USB 闪存驱动器）访问文件的功能。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_14.jpeg?raw=true" alt="iOS 13.0_14"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Health 提供监控听力健康的方法，并提供跟踪、可视化和预测女性生理周期的新方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置服务控件为用户提供了与应用共享位置数据的更多选择，包括新的一次性位置选项以及有关应用何时在后台使用位置的更多信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更快的 Face ID 解锁和性能改进使整个系统响应更灵敏，新的 App 方法将下载包体的大小减少了 50％，使应用更新缩小了 60％ 以上，同时应用启动速度比以往要快两倍。</p><p><img src="https://github.com/waitwalker/Resources/blob/master/iOS13/iOS%2013.0_15.jpeg?raw=true" alt="iOS 13.0_15"></p><p>以下是iPadOS 13.0 和iOS 13.0 Beta1 版本试玩视频:</p><h4 id="iPadOS-13-0"><a href="#iPadOS-13-0" class="headerlink" title="iPadOS 13.0"></a>iPadOS 13.0</h4><iframe src="https://v.youku.com/v_show/id_XNDIxNTM0MTY5Ng==.html?spm=a2h3j.8428770.3416059.1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="580" quality="high"> </iframe><h4 id="iOS-13-0"><a href="#iOS-13-0" class="headerlink" title="iOS 13.0"></a>iOS 13.0</h4><iframe src="https://v.youku.com/v_show/id_XNDIxNTMzODcyOA==.html?spm=a2h3j.8428770.3416059.1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="580" quality="high"> </iframe>]]></content>
      
      
      <categories>
          
          <category> WWDC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS 13.0 </tag>
            
            <tag> iPadOS 13.0 </tag>
            
            <tag> WWDC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完整前后台开源项目--狗圈儿</title>
      <link href="/2019/05/15/%E5%AE%8C%E6%95%B4%E5%89%8D%E5%90%8E%E5%8F%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%8B%97%E5%9C%88%E5%84%BF/"/>
      <url>/2019/05/15/%E5%AE%8C%E6%95%B4%E5%89%8D%E5%90%8E%E5%8F%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%8B%97%E5%9C%88%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<p align="center"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-c27077ff77062e8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pet" title="Pet" width="200"><br></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;狗圈儿是一个宠物社交软件,目的是广纳狗友,深入交流,分享快乐.狗圈儿是一个包含前台和后台的完整项目,从代码编写,图形图标设计,再到部署,调试,上架发布都由本人完成,稀稀拉拉历经几个月完成.前台开发采用的是Swift编写,现在已经适配到最新的SDK版本,如果你的Xcode不是最新的请先升级到最新版本.项目已经打包发布到<a href="https://itunes.apple.com/US/app/id1395622129?mt=8" target="_blank" rel="noopener"><strong>App Store</strong></a>,App主要适配了iPhone端,iPad接口预留了,没有适配.目前<a href="https://itunes.apple.com/US/app/id1395622129?mt=8" target="_blank" rel="noopener"><strong>App Store</strong></a>中版本是1.4.后台Web服务接口用Python语言开发,采用的是Tornado web server.数据库用的MySql和Redis缓存,server和数据库都部署在一台vps上了,资源文件托管在七牛上.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在前台和后台源码全部开源到GitHub上,如果有需要,可以clone下来看一下.由于个人的服务器再朝外,涉及到流量等问题,服务器地址,七牛托管上传文件的token等暂不对外公布,如果想部署服务,在下文中会详细讲一下具体改哪些地方或者私信给我也行.</p><p>前台代码:<a href="https://github.com/waitwalker/Pet" target="_blank" rel="noopener">https://github.com/waitwalker/Pet</a></p><p>后台代码:<a href="https://github.com/waitwalker/PetAPI" target="_blank" rel="noopener">https://github.com/waitwalker/PetAPI</a></p><p><strong>如果对你有帮助,请给我一个赞或星,感谢!</strong></p><p>贴几张图:<br><img src="https://upload-images.jianshu.io/upload_images/1715253-9a0046e4dc959330.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="狗圈儿"></p><h2 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>项目结构基本按照模块来划分.</p><pre><code>.└── PetGroup├── ApplicationLayer│   └── CommentDetail├── CommonConfig│   └── MTTCommonConfig.swift├── Commons # 一些封装组件&amp;扩展等│   ├── BaseClass│   ├── Bridge│   ├── Const│   ├── Core│   ├── Database│   ├── Extension│   ├── Router│   ├── Security│   ├── Sequence│   ├── ThirdFramework│   └── Tools├── Main #入口函数&amp;资源文件│   ├── AppDelegate.swift│   ├── Assets.xcassets│   ├── Base.lproj│   ├── Info.plist│   ├── zh-Hans.lproj│   └── zh-Hant.lproj├── Modules #主要模块│   ├── Circle #首页│   ├── LaunchProgress #启动广告页│   ├── Login&amp;Register #登录注册│   ├── Personal #个人中心│   ├── PetRecognise #鉴宠│   ├── PopularScience│   └── WelcomePage #欢迎引导页├── PetGroup.entitlements└── README.md</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序在启动的时候封装了一个超级管理类MTTSuperiorManager,其主要作用是接收不同的任务类型,然后将任务任务下发给助手实施.MTTAssistantManager是一个基类,其只负责转接超级管理者下发的任务,具体的任务由其子类去实现.MTTAssistantManager就像人体的大脑一样,指挥着MTTArmManager手臂,MTTLegManager等去完成具体的任务.然后将执行的结果回调给命令的发出者.</p><p>下面是一个简单的示例:</p><p>1)程序启动-&gt;给MTTSuperiorManager发一个launchAssistant任务</p><pre><code>MTTSuperiorManager.sharedSuperiorManager.applyAssitant(application: application, assistantType: MTTAssistantType.launchAssistant)</code></pre><p>2)MTTSuperiorManager收到任务后,将任务交给MTTAssistantManager基类</p><pre><code>func applyAssitant(application: UIApplication, assistantType:MTTAssistantType) -&gt; Void {MTTAssistantManager.assistantHandler([&quot;application&quot;: application], assistantType: assistantType)}</code></pre><p>3)MTTAssistantManager基类判断具体任务类型,将任务交给去实施</p><pre><code>static func assistantHandler(_ info: [String:Any]?, assistantType: MTTAssistantType) -&gt; Void {switch assistantType {case .interfaceAssistant:let interfaceAssistant = MTTInterfaceAssistantManager()let application = info![&quot;application&quot;] as! UIApplication//具体实施&amp;回调interfaceAssistant.handlerInterface(application: application)case .launchAssistant:handlerLaunch()case .initializePetRecogniseData:MTTPetRecogniseDataAssistant.initializePetRecogniseData()}}</code></pre><p>4)MTTInterfaceAssistantManager子类实施启动任务</p><pre><code>override func handlerInterface(application: UIApplication) {pSetupStatistic()_ = UMConfigure.deviceIDForIntegration()//MTTPrint(&quot;deviceID:\(deviceID)&quot;)self.setupMainUI()let appDelegate = application.delegate as! AppDelegatelet tabBarController = UITabBarController()tabBarController.viewControllers = makeChildControllers()appDelegate.window?.rootViewController = tabBarControllerappDelegate.window?.makeKeyAndVisible()}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-79ff6b9e385da533.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="狗圈儿任务时序图"></p><p>其它任务类型具体请看源码.</p><h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><p>项目整体大概分为:广告页,欢迎引导,登录注册等模块</p><h4 id="广告页"><a href="#广告页" class="headerlink" title="广告页"></a>广告页</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广告页MTTLauchProgressController,其弹出的方法定义在MTTLaunchInterface接口文件中,然后有首页MTTCircleViewController实现了这个方法,然后弹出广告页,广告页的内容暂时定的为一张静态图片,如果有需要你可以在这里面拓展你自己的广告图片链接.</p><pre><code>extension MTTCircleViewController: MTTLaunchInterface{func iLaunchProgressPage(info: [String : Any]?) {let progressVC = MTTLauchProgressController()self.pushViewController(progressVC)}}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-eaa6e0393d5f933a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广告页"></p><h4 id="欢迎引导"><a href="#欢迎引导" class="headerlink" title="欢迎引导"></a>欢迎引导</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎引导出现在第一次安装启动应用或者版本有变化时.应用启动完毕后,判断是否应该弹出欢迎引导页并通过回调方式告诉调用者是否需要显示欢迎引导页:</p><pre><code>// 注册欢迎引导页,判断是否弹出欢迎引导页MTTWelcomePageManager.handlerWelcomePage(handler: self, appVersion: MTTDeviceInfoManager.currentDeviceManager.appVersion)/// 处理启动页 :是否需要出现启动页////// - Parameters:/// - handler: 处理者/// - appVersion: 版本static func handlerWelcomePage(handler:MTTWelcomePageInterface, appVersion:String) -&gt; Void {let filterStr = &quot;name = &#39;petGroup&#39;&quot;let result = MTTRealm.queryObject(type: MTTPetGroupInfoModel.self, filter: filterStr)// 已经插入数据了if (result?.count)! &gt; Int(0) {let petGroup = result?.first as! MTTPetGroupInfoModelvar isShow:Bool = falseif petGroup.version == appVersion{isShow = falsehandler.iShouldShowWelcomePage(show: isShow)}else {isShow = trueMTTRealm.sharedRealm.beginWrite()petGroup.version = appVersiontry! MTTRealm.sharedRealm.commitWrite()handler.iShouldShowWelcomePage(show: isShow)}} else {MTTRealm.sharedRealm.beginWrite()let petGroupInfo = MTTPetGroupInfoModel()petGroupInfo.name = &quot;petGroup&quot;petGroupInfo.version = appVersionMTTRealm.sharedRealm.add(petGroupInfo)try! MTTRealm.sharedRealm.commitWrite()handler.iShouldShowWelcomePage(show: true)}}</code></pre><p>回调处理:</p><pre><code>extension AppDelegate: MTTWelcomePageInterface{func iShouldShowWelcomePage(show: Bool) {if show {// 第一次 显示欢迎引导MTTTaskCenter.iDispatchTask(registerTo: self, taskType: MTTTaskCenterTaskType.welcomePageTask, info: nil)} else {// 非第一次 注册广告任务 到根控制器MTTSuperiorManager.sharedSuperiorManager.applyAssitant(application: UIApplication.shared, assistantType: MTTAssistantType.interfaceAssistant)}}}</code></pre><h4 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;登录和注册均采用的是手机号注册,方式简单,由于需要一些投入前期没有添加验证码验证.第三方登录目前支持QQ,微博和钉钉.</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-eb993feca589d4ed.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录注册"></p><h4 id="首页心情"><a href="#首页心情" class="headerlink" title="首页心情"></a>首页心情</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首页心情列表实现逻辑,如果用户是第一次启动APP,将根据设备UUID获取心情列表,最多获取10条数据.如果已经注册登录过,可以分页加载列表,每页10条. 之前在上传到App Store中遇到一个问题:需要举报屏蔽功能,因此首页某条心情被举报了,应该屏蔽掉,其实现算法如下:</p><pre><code>// MARK: - 查询被屏蔽的用户private func pSetupBlockUserUid() -&gt; Void {let result = MTTRealm.queryObjects(type: MTTBlockAbuseUserTable.self)if (result?.count)! &gt; 0 {for (_,abuseUser) in (result?.enumerated())! {let abuse = abuseUser as! MTTBlockAbuseUserTableMTTUserInfoManager.sharedUserInfo.blockUserUidArray.insert(abuse.uid)}}}func dDynamicListSuccessCallBack(_ info: [String : Any]?) {let dataSource = info![&quot;dataSource&quot;] as! [MTTCircleModel]let isHaveMoreData = info![&quot;isHaveMoreData&quot;] as! Intif MTTUserInfoManager.sharedUserInfo.blockUserUidArray.count &lt;= 0 {for (_,circelModel) in dataSource.enumerated() {ODataSource.append(circelModel)}} else {var tmpD = dataSourcevar tmpIndexArray:[Int] = []for (index, model) in dataSource.enumerated() {if MTTUserInfoManager.sharedUserInfo.blockUserUidArray.contains(model.uid) {tmpIndexArray.append(index)}}for (i, index) in tmpIndexArray.enumerated() {tmpD.remove(at: index - i)}let tmpDataSource:[MTTCircleModel] = tmpDlet newDataSource = tmpDataSource.sorted { (model_one, model_two) -&gt; Bool inreturn model_one.modelIndex &lt; model_two.modelIndex}for (_,circelModel) in newDataSource.enumerated() {ODataSource.append(circelModel)}}pRemoveHUD()VCircleTableView.reloadData()self.VCircleTableView.mj_footer.endRefreshing()self.VCircleTableView.mj_header.endRefreshing()self.isHaveMoreData = isHaveMoreDataif isHaveMoreData == 0 {self.view.toast(message: &quot;没有更多数据啦&quot;)}}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-2f27e7d632ca4633.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页"></p><h4 id="撰写评论-amp-点赞"><a href="#撰写评论-amp-点赞" class="headerlink" title="撰写评论&amp;点赞"></a>撰写评论&amp;点赞</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-c8a11004c6f12291.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="撰写评论"></p><h4 id="举报-amp-屏蔽"><a href="#举报-amp-屏蔽" class="headerlink" title="举报&amp;屏蔽"></a>举报&amp;屏蔽</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-f9aba3038818752c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="举报屏蔽"></p><h4 id="鉴宠"><a href="#鉴宠" class="headerlink" title="鉴宠"></a>鉴宠</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-c9f5ca3b15ed4177.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="鉴宠"></p><h4 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-a0c21d2350c68bf8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个人中心"></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-92a33893379b444f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推送"></p><h4 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h4><p><img src="https://upload-images.jianshu.io/upload_images/1715253-f9eeeaa579941429.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分享"></p><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局是给控件添加约束,最终转换成计算控件frame,从而实现布局的过程.苹果的SDK可以通过代码实现,也可以通过Interface Builder直接给控件添加约束.也有一些第三方的封装组件,像Masonry,SnapKit等.本项目中一些页面大多采用SnapKit来布局.SnapKit为每个view拓展了一个snp计算属性,继承自ConstraintViewDSL,通过如下构造函数,将待约束的view传给ConstraintViewDSL</p><pre><code>internal init(view: ConstraintView) {self.view = view}</code></pre><p>ConstraintViewDSL内部持有个待约束的存储属性view:</p><pre><code>internal let view: ConstraintView</code></pre><p>然后snp调用其内部的实例方法,给控件添加约束,通过closure回调:</p><pre><code>public func makeConstraints(_ closure: (_ make: ConstraintMaker) -&gt; Void) {ConstraintMaker.makeConstraints(item: self.view, closure: closure)}</code></pre><p>如果需要,可以继续深入继续研究.</p><h4 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RxSwift把程序中的每一个操作都看成一个事件,而事件是从事件源中不断发出的,事件源可以是一个button,一个textField等.每一个事件都涉及到输入和输出,比如当你把点击一个事件输入给一个button时,这个button会给你输出一个touch事件,你只需要监听这个touch事件,对这个事件作出需要的响应就可以了.项目中部分模块采用MVVM架构,将相关事件的输入和输出封装到viewModel里面,view持有viewModel,将事件源输入给viewModel,viewModel依据业务逻辑处理后将事件输出给view去响应.</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加密有对称加密和非对称加密,加密可以理解为将明文经过某种转换或计算使之成为你看不懂的过程.常见的非对称加密方法:RSA,有一把公钥,一把私钥;公钥加密的内容只有私钥能解开,私钥加密的内容只有公钥能解开.对称加密加密方法有:AES,DES等,其使用同一把秘钥key.其加密强度主要取决于key的复杂度.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目在密码那块采用了AES加密,然后将密文传输到服务器,同时持久化在本地用于下次自动登录.第二用到的地方是在上传图片获取七牛token时,用密码密文当做一个验证.这里封装了加解密方法:</p><pre><code>// MARK: - instance method 实例方法// MARK: - class method 类方法/// AES ECB 128 加密////// - Parameter originalString: 原始内容/// - Returns: 加密后内容static func AES_ECB_128_Encode(originalString:String) -&gt; String {let data = originalString.data(using: String.Encoding.utf8)// byte 数组var encrypted:[UInt8] = []do {let aes = try AES(key: key, blockMode: CBC(iv: iv), padding: Padding.pkcs7)encrypted = try aes.encrypt((data?.bytes)!)} catch let error {print(error)}let encoded = Data(encrypted)return encoded.base64EncodedString()}/// AES ECB 128 解密////// - Parameter content: 加密内容/// - Returns: 解密后static func AES_ECB_128_Decode(content:String) -&gt; String {let data = NSData(base64Encoded: content, options: NSData.Base64DecodingOptions.init(rawValue: 0))var encrypted:[UInt8] = []let count = data?.lengthfor i in 0..&lt;count! {var tmp:UInt8 = 0data?.getBytes(&amp;tmp, range: NSRange(location: i,length:1 ))encrypted.append(tmp)}// decode AESvar decrypted: [UInt8] = []do {let aes = try AES(key: key, blockMode: CBC(iv: iv), padding: Padding.pkcs7)decrypted = try aes.decrypt(encrypted)} catch let error {print(error)}// byte 转换成NSDatalet encoded = Data(decrypted)//解密结果从data转成stringlet str = String(data: encoded, encoding: String.Encoding.utf8)return str!}</code></pre><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS上的持久化方案有多种:plist,用户偏好,sqlite,Core Data,还有目前比较流行的Realm.除了Core Data,大都使用过,使用方法都相对简单.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;狗圈儿中在存储设备信息,登录后用户信息,屏蔽用户,鉴宠中的宠物名称等地方建立了对应的表在本地保存相应的信息.</p><pre><code>class MTTLoginInfoTable: Object {@objc dynamic var id:Int = 0 //主键@objc dynamic var deviceToken:String = &quot;&quot; //设备标识@objc dynamic var isNeedAutoLogin:Bool = false //是否需要自动登录@objc dynamic var phone:String = &quot;&quot; //手机@objc dynamic var password:String = &quot;&quot; //密码@objc dynamic var isNormalLogin = true@objc dynamic var header_photo = &quot;&quot;override static func primaryKey() -&gt; String? {return &quot;id&quot;}// 添加索引override static func indexedProperties() -&gt; [String] {return [&quot;phone&quot;]}}/// 屏蔽用户数据表class MTTBlockAbuseUserTable: Object {@objc dynamic var id:String = &quot;&quot; //主键@objc dynamic var uid:String = &quot;&quot;@objc dynamic var blockUids:String = &quot;&quot;override static func primaryKey() -&gt; String? {return &quot;id&quot;}}</code></pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>程序中网络利用Alamofire来请求服务.</p><p>基本用法:</p><p>HTTP - <a href="#HTTP 方法">HTTP 方法</a>, 请求参数编码, HTTP Headers, 认证</p><p>大量数据 - 下载数据到文件, 上传数据到服务器</p><p>工具 - 指标统计, <a href="#cURL 命令输出">cURL 命令输出</a></p><p>高级用法:</p><p>URL 会话 - 会话管理, 会话代理, 请求</p><p>请求路由 - 请求路由, Adapting and Retrying Requests</p><p>模型对象 - 自定义响应序列化器</p><p>网络连接 - 安全性, 网络可用性</p><h4 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图片缓存采用的是Kingfisher. Kingfisher是基于NSURLSession的异步图片下载和缓存框架.其实现原理和SDWebImage有些类似.可以通过源码了解其过程原理.</p><h4 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS远程推送主要是APNs(Apple Push Ontification service),主要利用的是苹果server和每个device建立连接,ANPs收到推送provider的推送任务,然后将推送任务下发到目标device,device将推送消息下发给具体的APP.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目中推送后台主要利用友盟提供的API,用Python实现了一个推送接口,管理员用户(也就是我的手机),会有推送页面,添加完推送参数后直接,调用这个接口,实现推送服务.当然也可以直接在后台封装苹果的推送API,在需要的时候直接调用,不过deviceToken等你需要自己维护.</p><h3 id="资源托管"><a href="#资源托管" class="headerlink" title="资源托管"></a>资源托管</h3><p>七牛</p><h3 id="第三方依赖库"><a href="#第三方依赖库" class="headerlink" title="第三方依赖库"></a>第三方依赖库</h3><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;狗圈儿后台web服务接口用的是Tornado.Tornado 是一个Python web框架和异步网络库，起初由 FriendFeed 开发. 通过使用非阻塞网络I/O， Tornado可以支撑上万级的连接，处理 长连接, WebSockets ，和其他需要与每个用户保持长久连接的应用.后来被Facebook收纳开源.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前部署在购买的Google vps上(之前试过多家的vps,个人觉得谷歌的很稳定,不过价钱也高),这个vps除了跑了一个Tornado服务,之前还用Nginx搭了一个个人站点(<a href="https://waitwalker.cn),后来撤了,迁移到别的地方了.一些资源图片保存在七牛上,七牛给每个人用户提供10G对象存储空间,每月固定万次请求,超过收费了" target="_blank" rel="noopener">https://waitwalker.cn),后来撤了,迁移到别的地方了.一些资源图片保存在七牛上,七牛给每个人用户提供10G对象存储空间,每月固定万次请求,超过收费了</a>.</p><p>后台项目结构:</p><pre><code>.├── Configs│   └── __init__.py├── Handlers│   ├── MTTAESHandler.py│   ├── MTTBaseHandler.py│   ├── MTTChangeAvatarHandler.py│   ├── MTTChangePasswordHandler.py│   ├── MTTChangeUsernameHandler.py│   ├── MTTCommentListHandler.py│   ├── MTTCommentReplyListHandler.py│   ├── MTTDeviceDynamicListHandler.py│   ├── MTTDynamicListHandler.py│   ├── MTTFileUploadHandler.py│   ├── MTTFilterKeywordManager.py│   ├── MTTLoginHandler.py│   ├── MTTPublishCommentHandler.py│   ├── MTTPublishDynamicHandler.py│   ├── MTTPublishReplyHandler.py│   ├── MTTRegisterDeviceHandler.py│   ├── MTTRegisterHandler.py│   ├── MTTReplyListHandler.py│   ├── MTTReportAbuseHandler.py│   ├── MTTUploadTokenHandler.py│   ├── __init__.py│   ├── __pycache__│   └── files├── Libs│   └── __init__.py├── MainServer.py├── Models│   ├── MTTDataBase.py│   ├── __init__.py│   └── __pycache__├── Security│   ├── MTTSecurityManager.py│   ├── __init__.py│   └── __pycache__├── loggers│   ├── pet_error.log│   ├── pet_info.log│   └── tornado_main.log└── urls├── __init__.py├── __pycache__└── urls.py</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入口函数在MainServer.py文件. urls是路由层,匹配请求的接口名称,转发到Handlers处理具体的接口业务.算了一下,大概写了20个左右接口,其中MTTUploadTokenHandler.py模块是处理七牛上传token的接口,这个接口加了redis缓存,10个小时内七牛token不会过期.如果你需要,可以把下面的三个替换成你自己的:</p><pre><code>access_key = &#39;七牛access_key&#39;secret_key = &#39;七牛secret_key&#39;bucket_name = &#39;文件桶名称&#39;</code></pre><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>项目中用的第三方依赖安装文件放在/Configs/requirements.txt中:</p><pre><code>tornado==4.5.1qiniu==7.2.2 #七牛token模块redis==3.0.1PyMySOL==0.7.11bcrypy==3.1.3pycrypto==2.6.1</code></pre><p>如果想部署安装直接执行:pip install -r requirements.txt</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后台项目的数据存储主要是MySql和Redis,共创建了6张表.MySql server也安装在自己vps上了.Redis主要用于做缓存处理了.这里我导出创建相关表的sql脚本,放到项目的Configs下,需要的可以跑一下.</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>部署分为要不要调用上传图片接口:</p><p>1)不涉及资源图片上传:</p><p>后台:</p><p>直接将项目clone下来,安装requirements.txt里面想的相关依赖,运行MainServer.py里面的入口函数.</p><p>前台:</p><p>将/Commons/Const/MTTServerAPIConst.swift文件中的kServerHost改成你自己的server地址,例如:</p><pre><code>let kServerHost:String = &quot;http://192.168.10.63:8000/</code></pre><p>2)涉及到资源图片上传:</p><p>后台:</p><p>在MTTUploadTokenHandler.py模块中,添加自己的相关key,用于获取上传资源token.然后安装requirements.txt里面想的相关依赖,运行MainServer.py里面的入口函数.</p><p>前台:</p><p>将/Commons/Const/MTTServerAPIConst.swift文件中的kServerHost和kQiNiuServer改成你自己的server地址,例如:</p><pre><code>let kServerHost:String = &quot;[http://192.168.10.63:8000/](http://192.168.10.63:8000/)let kQiNiuServer = &quot;http://xx.xxxx.xx/&quot;</code></pre><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.cn/" target="_blank" rel="noopener">https://waitwalker.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《人生》</title>
      <link href="/2019/05/02/%E8%AF%BB%E3%80%8A%E4%BA%BA%E7%94%9F%E3%80%8B/"/>
      <url>/2019/05/02/%E8%AF%BB%E3%80%8A%E4%BA%BA%E7%94%9F%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读完路遥的人生之后，心情有点沉重。人生如戏,戏如人生。当我们旅途不顺时应该怎样调节;当我们面对这一系列的艰难抉择时，我们该怎么办;在一些诱惑面前我们，是否能够把握好自己。人生这条路曲曲折折，走得越长，我们从中学到的东西越多，领悟得越多。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《人生》一书叙述了高加林回到土地又离开土地，再回到土地这样人生的变化过程。他与两个女人之间的事情构成了书的一个发展线索。我个人比较喜欢刘巧珍，她美丽善良、贴心，处处为所爱的人着想。当高加林是一个老师时，她站在旁边默默的关注他，虽然很爱他却不敢表达，觉得自己配不上他。当爱的人被人顶替了教师职位回到家种地时，看着他在山坡上拼命挖地把手弄伤之后，心里很心疼，给他送药水;当加林提着馒头到县城卖时，她在一旁悄悄的观察着他，心里很替他着急，当加林一个馒头都没有卖出去时，她帮他卖……….这些行动都深深的打动了高加林，于是他俩恋爱了。恋爱中，有一次他俩在草堆中谈话，巧珍对加林说“当我们结婚之后，我要让你像在学校一样，过星期天”，还有一次她到县城里看着爱人的被子薄，便说要给加林续棉花……….这些我们都可以体会到巧珍对加林无私真挚的爱。对于巧珍，我是十分的佩服，一个女人到底有多大的胸怀才可以这样默默的付出，可以苦自己，却不愿意自己所爱的人受苦，处处为爱的人着想，把最好的东西留给爱的人。也从侧面表现出了农民的那种淳朴,单纯,宽阔的心胸.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于高加林的遭遇有恨也有同情。恨他无情的抛弃了真心真意他好的人，同情他来来去去最后又回到了黄土，落下一个”不好的下场”。他是一个才貌双全、文武皆备的高中毕业生，自信、有抱负、有思想，毕业后当上了民办教师，但是被人不公平的顶替了。他的心里很不平衡，是巧珍慢慢的安抚着他。给予了他无私的爱，让他感受到快乐。但是当他进城工作之后，渐渐的觉得自己与巧珍有差距，开始抛弃在农村的相好。记得那次巧珍到县城看他时，对他说他家里的猪生了十二个猪娃，被老母猪压死一个…….他表现出反感，不耐烦，这预示着这段感情快走到了尽头。加上黄亚萍对他的热烈追求，他更是动摇了。黄亚萍是一个城里的女人，有知识有文化，大胆、开朗活泼，对高加林穷追不舍。她与高加林之间有共同的文学爱好，这拉近了他们之间的距离。在这种情况下，最后高加林无情的丢下了巧珍，投向了那外一个女人的怀抱，我想换做现在的一些人也会这样做的。但是就像我们说的一样，任何事情有得必有失，有人告发了他进城工作是靠关系。他又回到了生他养他的那片黄土地，所有的东西顷刻之间又没有了，原有的爱人早已离开,而淳朴的乡民更多的是去宽慰他,人生无常,更需抬起眼来朝前看。虽然他的内心十分痛苦，世上没有后悔药，一切已来不及。我们不能把这些全怪罪在他自己身上，造成这种结局的也有社会原因。我们面对他这种情景时，也不敢保证不会像他那样做。在现实面前，有好多事情是被逼无奈。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到现在为止，看过路遥的好多作品，对《人生》和《平凡的世界》感触比较深,对所描绘的黄土高原千沟万壑的印象更深。《人生》给了我很多想法和启示，其中有句话特别好“人生的道路虽然漫长，但紧要处常常只有几步，特别是当人年轻的时候。”是啊，人生这条路需要我们好好的走，要记得曾经对我们好的人，不管在什么时候都不能忘了。做事要凭自己的良心，不能被自己所处的环境所变化，保留自己最真实的一面。在面对一系列艰难抉择的时候，好好的想清楚，不要伤害那些深深爱你的人，我们可能会失去一些机会，但是它还有可能会得到，有些人我们一旦错过了就不会再有。<br></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2019/04/30/%E5%A0%86/"/>
      <url>/2019/04/30/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>堆是二叉树的一种,分为最小堆:其根节点恒小于子节点;最大堆:其根节点恒大于子节点.堆总是一颗完全二叉树,除了最底层,其它层都被填满,且最底层尽可能从左往右填入.常见的堆有二叉堆,斐波那契堆等.<br>堆又名优先队列,但并不是队列.之前我们了解队列是满足FIFO的数据结构,而堆是按照元素的优先级来处理元素.通常我们最小堆或者最大堆都是我们给堆设定的优先级.<br>堆的存储结构一般用数组来实现,本文主要实现的最大堆的结构.</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><pre><code>// MARK: - 堆class Heap&lt;T:Comparable&gt; {    // 存储结构    private(set) var elements:[T] = []   // MARK: - 构造    init() {    }}</code></pre><h2 id="节点索引"><a href="#节点索引" class="headerlink" title="节点索引"></a>节点索引</h2><p>因为堆是一颗完全二叉树,其在数组中的存储结构也满足二叉树一些性质,比如一个索引为i的节点其左子树索引为2i + 1,其右子树索引为2i + 2;其父节点的索引为(i - 1) / 2.</p><pre><code>/// 左子树索引    ///    /// - Parameter index: 当前节点索引    /// - Returns: 左子树的索引    func leftChildIndex(index:Int) -&gt; Int {        return 2 * index + 1    }    /// 右子树索引    ///    /// - Parameter index: 当前节点索引    /// - Returns: 右子树的索引    func rightChildIndex(index:Int) -&gt; Int {        return 2 * index + 2    }    /// 父节点索引    ///    /// - Parameter index: 当前节点索引    /// - Returns: 父节点的索引    func parentIndex(index:Int) -&gt; Int {        guard index &gt; 0 else {            return 0        }        return (index - 1) / 2    }</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入逻辑:<br>1)将新元素插入到数组的末尾<br>2)将新元素节点与其父节点进行比较,如果优先级大于父节点(也就是其值大于父节点),则新节点与父节点进行位置更换,继续新节点与父节点进行比较<br>3)递归</p><pre><code>/***        1)将新元素插入到数组的末尾        2)将新元素节点与其父节点进行比较,如果优先级大于父节点(也就是其值大于父节点),则新节点与父节点进行位置更换,继续新节点与父节点进行比较        3)递归     */    /// 插入操作    ///    /// - Parameter element: 待插入的元素    func insert(element:T) -&gt; Void {        elements.append(element)        guard elements.count &gt; 1 else {            return        }        shiftUp(index: elements.count - 1)    }    /// 上滤    ///    /// - Parameter index: 当前索引    func shiftUp(index:Int) -&gt; Void {        let parentIndex = self.parentIndex(index: index)        guard isHigherPriority(firstIndex: index, secondIndex: parentIndex) else {            return        }        swapElement(with: index, and: parentIndex)        // 向上继续比较        shiftUp(index: parentIndex)    }    /// 最大堆判断优先级    ///    /// - Parameters:    ///   - firstIndex: 新元素索引    ///   - secondIndex: 父节点索引    /// - Returns: 新节点是否具有优先级    private func isHigherPriority(firstIndex:Int, secondIndex:Int) -&gt; Bool {        guard firstIndex &lt; elements.count &amp;&amp; secondIndex &lt; elements.count  else {            return false        }        return elements[firstIndex] &gt; elements[secondIndex]    }    /// 交换两个元素    ///    /// - Parameters:    ///   - firstIndex: 第一个元素索引    ///   - secondIndex: 第二个元素索引    private func swapElement(with firstIndex:Int, and secondIndex:Int) -&gt; Void {        guard firstIndex &lt; elements.count &amp;&amp; secondIndex &lt; elements.count else {            return        }        elements.swapAt(firstIndex, secondIndex)    }</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除逻辑:<br>1)删除操作通常将最大堆元素移除,及根节点移除,首先将根节点与最后的元素互换位置<br>2)删除最后的元素(即移到最后的根元素)<br>3)将移动到root位置的新根节点与其子节点进行比较,如果其小于子节点,则与子节点互换位置<br>4)递归</p><pre><code>/// 删除操作    func delete() -&gt; Void {        guard !isEmpty else {            return        }        swapElement(with: 0, and: count - 1)        elements.removeLast()        guard !isEmpty else {            return        }        shiftDown(elememtIndex: 0)    }    /// 下滤    ///    /// - Parameter elememtIndex: 元素索引    func shiftDown(elememtIndex:Int) -&gt; Void {        // 获取当前节点与其子节点的高优先级的节点        var tmpIndex = elememtIndex        let leftIndex = leftChildIndex(index: elememtIndex)        let rightIndex = rightChildIndex(index: elememtIndex)        if leftIndex &lt; count &amp;&amp; isHigherPriority(firstIndex: leftIndex, secondIndex: rightIndex) {            tmpIndex = leftIndex        }        if rightIndex &lt; count &amp;&amp; isHigherPriority(firstIndex: rightIndex, secondIndex: leftIndex) {            tmpIndex = rightIndex        }        if elememtIndex == tmpIndex {            return        }        swapElement(with: elememtIndex, and: tmpIndex)        shiftDown(elememtIndex: tmpIndex)    }</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D</a><br>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 堆 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2019/04/30/AVL%E6%A0%91/"/>
      <url>/2019/04/30/AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="AVL树定义"><a href="#AVL树定义" class="headerlink" title="AVL树定义"></a>AVL树定义</h2><p>AVL树是一个带平衡条件的二叉搜索树.AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis,他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构.其主要满足以下性质:<br>1)左右子树高度差的绝对值不超过1;<br>2)左右子树也是AVL树.<br>之前我们已经了解到一颗具有n个节点二叉搜索树最大深度为n,最小深度为logn.二叉树的深度越小其搜索时间复杂度对应也就越小.一个深度为logn的二叉查找树其搜索算法的时间复杂度为logn.</p><h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>AVL树是带有平衡条件二叉搜索树,其左右子树的高度差绝对值不超过1,这个平衡条件我们称为平衡因子(balance factor).</p><h2 id="AVL树的构造"><a href="#AVL树的构造" class="headerlink" title="AVL树的构造"></a>AVL树的构造</h2><pre><code>var root:BinaryTree&lt;T&gt;?    // MARK: - 构造函数    init() {    }</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code>/// 查找操作    ///    /// - Parameters:    ///   - binaryTreeNode: 根节点    ///   - value: 待查找的值    /// - Returns: 查找到的节点    func find(binaryTreeNode:BinaryTree&lt;T&gt;?, value:T) -&gt; BinaryTree&lt;T&gt;? {        guard let node = binaryTreeNode else { return nil }        if node.value == value {            return node        } else if value &lt; node.value {            return find(binaryTreeNode: node.leftChildNode, value: value)        } else {            return find(binaryTreeNode: node.rightChildNode, value: value)        }    }</code></pre><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>对于一个非平衡的二叉搜索树,我们可以通过旋转的手段让其左右子树高度差不超过1从而达到平衡转变成一个AVL树.其中旋转的次数可能是1次或者多次.</p><h3 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h3><p>左旋转即向左旋转,逆时针旋转.</p><pre><code>/// 左旋转    ///    /// - Parameter binaryTreeNode: 待旋转的节点    /// - Returns: 旋转后的节点    func leftRotate(binaryTreeNode:BinaryTree&lt;T&gt;?) -&gt; BinaryTree&lt;T&gt;? {        guard let pivot = binaryTreeNode?.rightChildNode else { return binaryTreeNode }        binaryTreeNode?.rightChildNode = pivot.rightChildNode        pivot.leftChildNode = binaryTreeNode        binaryTreeNode?.height = max((binaryTreeNode?.leftHeight)!, (binaryTreeNode?.rightHeight)!) + 1        pivot.height = max(pivot.leftHeight, pivot.rightHeight) + 1        return pivot    }</code></pre><h3 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h3><p>右旋转即向右旋转,顺时针旋转.</p><pre><code>/// 右旋转    ///    /// - Parameter binaryTreeNode: 待旋转的节点    /// - Returns: 旋转后的节点    func rightRotate(binaryTreeNode:BinaryTree&lt;T&gt;?) -&gt; BinaryTree&lt;T&gt;? {        guard let pivot = binaryTreeNode?.rightChildNode else { return binaryTreeNode }        binaryTreeNode?.leftChildNode = pivot.rightChildNode        pivot.rightChildNode = binaryTreeNode        binaryTreeNode?.height = max((binaryTreeNode?.leftHeight)!, (binaryTreeNode?.rightHeight)!) + 1        pivot.height = max(pivot.leftHeight, pivot.rightHeight) + 1        return pivot    }</code></pre><h3 id="左右旋转"><a href="#左右旋转" class="headerlink" title="左右旋转"></a>左右旋转</h3><pre><code>/// 左右旋转    ///    /// - Parameter binaryTreeNode: 待旋转的节点    /// - Returns: 选择后的节点    func leftRightRotate(binaryTreeNode:BinaryTree&lt;T&gt;?) -&gt; BinaryTree&lt;T&gt;? {        guard let leftChild = binaryTreeNode?.leftChildNode else { return binaryTreeNode }        binaryTreeNode?.leftChildNode = leftRotate(binaryTreeNode: leftChild)        return rightRotate(binaryTreeNode: binaryTreeNode)    }</code></pre><h3 id="右左旋转"><a href="#右左旋转" class="headerlink" title="右左旋转"></a>右左旋转</h3><pre><code>/// 右左旋转    ///    /// - Parameter binaryTreeNode: 待旋转的节点    /// - Returns: 旋转后的节点    func rightLeftRotate(binaryTreeNode:BinaryTree&lt;T&gt;?) -&gt; BinaryTree&lt;T&gt;? {        guard let rightChild = binaryTreeNode?.rightChildNode else { return binaryTreeNode }        binaryTreeNode?.rightChildNode = rightRotate(binaryTreeNode: rightChild)        return leftRotate(binaryTreeNode: binaryTreeNode)    }</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code>/// 插入操作    ///    /// - Parameter value: 待插入的值    func insert(value:T) -&gt; Void {        root = insert(binaryTreeNode: root, value: value)    }    private func insert(binaryTreeNode:BinaryTree&lt;T&gt;?, value:T) -&gt; BinaryTree&lt;T&gt;? {        guard let node = binaryTreeNode else { return BinaryTree(value: value) }        if value &lt; node.value {            node.leftChildNode = insert(binaryTreeNode: node.leftChildNode, value: value)        } else {            node.rightChildNode = insert(binaryTreeNode: node.rightChildNode, value: value)        }        let balanceNode = balance(binaryTreeNode: node)        balanceNode.height = max(balanceNode.leftHeight, balanceNode.rightHeight) + 1        return balanceNode    }</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>/// 删除操作    ///    /// - Parameter value: 待删除的值    func delete(value:T) -&gt; Void {        root = delete(binaryTreeNode: root, value: value)    }    func delete(binaryTreeNode:BinaryTree&lt;T&gt;?, value:T) -&gt; BinaryTree&lt;T&gt;? {        guard let node = binaryTreeNode else { return nil }        if node.value == value {            if node.leftChildNode == nil &amp;&amp; node.rightChildNode == nil {                return nil            }            if node.leftChildNode == nil {                return node.rightChildNode            }            if node.rightChildNode == nil {                return node.leftChildNode            }            node.value = (node.rightChildNode?.minNode.value)!            node.rightChildNode = delete(binaryTreeNode: node.rightChildNode, value: node.value)        } else if value &lt; node.value {            node.leftChildNode = delete(binaryTreeNode: node.leftChildNode, value: value)        } else {            node.rightChildNode = delete(binaryTreeNode: node.rightChildNode, value: value)        }        let balanceNode = balance(binaryTreeNode: node)        balanceNode.height = max(balanceNode.leftHeight, balanceNode.rightHeight) + 1        return balanceNode    }</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/AVL%E6%A0%91</a><br>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2019/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉查找树定义"><a href="#二叉查找树定义" class="headerlink" title="二叉查找树定义"></a>二叉查找树定义</h2><p>二叉搜索树也叫二叉查找树(Binary Search Tree)是二叉树的一个类型.二叉搜索树具有以下性质:<br>1)若任意节点的左子树不空,则左子树上所有节点的值均小于它根节点的值;<br>2)若任意节点的右子树不空,则右子树上所有节点的值均大于它根节点的值;<br>3)任意节点的左右子树也分别为二叉查找树;<br>4)没有键值相等的节点.<br>二叉查找树相比去其他数据结构的优势在于查找,插入的时间复杂度较低,为O(logn).二叉查找树是基础数据结构,长用于构建更为抽象的数据结构,如集合,关联数组等.搜索,插入,删除的复杂度等于树高,期望O(logn),最坏O(n),虽然二叉查找树的最坏效率是O(n),但它支持动态查询,而且一些改进版的二叉查找树可以使树高为O(logn),从而将最坏效率将至O(logn),如AVL树,红黑树等.<br>二叉查找树的存储结构常用二叉链表来构建.</p><p><img src="http://abc.waitwalker.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="二叉搜索树"></p><h2 id="二叉查找树实现"><a href="#二叉查找树实现" class="headerlink" title="二叉查找树实现"></a>二叉查找树实现</h2><p>这里二叉查找树的存储结构我们用的是上一节定义的二叉树.</p><pre><code>// MARK: - 二叉查找树class BinarySearchTree&lt;T:Comparable&gt; {    private(set) var root:BinaryTree&lt;T&gt;?    // MARK: - 构造函数    init() {    }}</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找逻辑:<br>1)从根节点开始查找,如果待查找的值等于根节点的值,直接返回;<br>2)如果待查找的值小于根节点的值,则在根节点的左子树执行查找;<br>3)如果待查找的值大于根节点的值,则在根节点的右子树执行查找;<br>4)递归执行以上步骤</p><pre><code>/// 查找例程    ///    /// - Parameter value: 待查找的值    /// - Returns: 查找到的值    func find(value:T) -&gt; BinaryTree&lt;T&gt;? {       guard let node = binaryTree else { return nil }        if node.value == value {            return node        } else if value &lt; node.value {            return find(binaryTree: node.leftChildNode, value: value)        } else {            return find(binaryTree: node.rightChildNode, value: value)        }    }</code></pre><p>在我们的示例中,查找128:<br>数组需要对整个列表进行查找,逐个元素比较128是否相等;<br>二叉搜索树则先比较和根元素120比较,128比120大,则在120的右子树查找,然后找到130,128比130小,则在130的左子树找,最终找到.</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入逻辑:<br>1)先创建一个新节点,如果新节点的值与根节点的值相等,则插入到根节点位置;<br>2)如果新节点的值小于等于根节点的值,则将新节点赋值给根节点的左子树;<br>3)如果新节点的值大于根节点的值,则将新节点赋值给根节点的右子树;<br>4)递归执行以上步骤.</p><pre><code>/// 插入例程    ///    /// - Parameter value: 插入的值    /// - Returns: 插入后返回的二叉查找树    func insert(value:T) -&gt; Void {        root = insert(root: root, value: value)    }    private func insert(root binaryTree:BinaryTree&lt;T&gt;?, value:T) -&gt; BinaryTree&lt;T&gt;? {        guard let node = binaryTree else { return BinaryTree(value: value) }        if value &lt;= node.value {            node.leftChildNode = insert(root: node.leftChildNode, value: value)        } else {            node.rightChildNode = insert(root: node.rightChildNode, value: value)        }        return node    }</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除逻辑:<br>1)删除的节点是叶子节点,直接删除;<br>2)删除的节点只有一个儿子,则将其儿子赋值给当前节点<br>3)删除的节点有两个儿子,则需要将此节点替换为左子树最大的子节点或者右子树最小子节点</p><pre><code>func delete(value:T) -&gt; Void {        root = delete(binaryTree: root, value: value)    }    private func delete(binaryTree:BinaryTree&lt;T&gt;?, value:T) -&gt; BinaryTree&lt;T&gt;? {        guard let node = binaryTree else { return nil }        if node.value == value {            // 左右节点都为空            if node.leftChildNode == nil &amp;&amp; node.rightChildNode == nil {                return nil            }            // 左右节点有一个为空            if node.leftChildNode == nil {                return node.rightChildNode            }            if node.rightChildNode == nil {                return node.leftChildNode            }            // 左右节点都不为空            // 将左子树中最小的节点赋值给当前节点            node.value = (node.rightChildNode?.minNode.value)!            // 删除右子树中最小节点            node.rightChildNode = delete(binaryTree: node.rightChildNode, value: node.value)        } else if value &lt; node.value {            node.leftChildNode = delete(binaryTree: node.leftChildNode, value: value)        } else {            node.rightChildNode = delete(binaryTree: node.rightChildNode, value: value)        }        return node    }</code></pre><h2 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h2><p>最小值一直遍历二叉搜索树的左子树,直到左子树为空.</p><pre><code>/// 最小值    ///    /// - Returns: 最小值节点    func min() -&gt; BinaryTree&lt;T&gt;? {        guard let node = root else { return nil }        var tmp = node        while tmp.leftChildNode != nil {            tmp = tmp.leftChildNode!        }        return tmp    }</code></pre><h2 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h2><p>最大值一直遍历二叉搜索树右子树,直到右子树为空</p><pre><code>/// 最大值    ///    /// - Returns: 最大值节点    func max() -&gt; BinaryTree&lt;T&gt;? {        guard let node = root else { return nil }        var tmp = node        while tmp.rightChildNode != nil {            tmp = node.rightChildNode!        }        return tmp    }</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺<br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 5 新增特性 </title>
      <link href="/2019/04/26/Swift-5-%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
      <url>/2019/04/26/Swift-5-%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="ABI稳定"><a href="#ABI稳定" class="headerlink" title="ABI稳定"></a>ABI稳定</h3><p>Swift 社区最近最重大的新闻应该就是 ABI 稳定了.ABI稳定就是binary接口稳定,也就是运行的时候只要是Swift5或者以上的编译器编译出来的binary,就可以跑在任意的Swift 5或以上的runtime上.这样我们就不需要像以往那样在app里面放一个Swift runtime了,Apple会把它集成到iOS和macOS系统里面,这就可以缩减你app的体积,使得你的app在运行时不需要加载自己Swift runtime了,使用系统同一个Swift,所以运行原则上更快,更省运行内存.</p><h3 id="dynamicCallable"><a href="#dynamicCallable" class="headerlink" title="@dynamicCallable"></a>@dynamicCallable</h3><p>@dynamicCallable属性允许你调用命名的类型,使你调用函数更加简单.<br>如果需要新增@dynamicCallable属性,必须实现以下两个方法中的一个或者两个:</p><pre><code>@dynamicCallable struct Person {    func dynamicallyCall(withArguments args:[Int]) -&gt; [Int]{        return args.map{$0 * 2}    }    func dynamicallyCall(withKeywordArguments args: KeyValuePairs&lt;String,String&gt;) -&gt; [Int] {        return [1,2,3]    }}let person = Person()let new = person(1,2,3)print(new)</code></pre><h3 id="Swift标准库"><a href="#Swift标准库" class="headerlink" title="Swift标准库"></a>Swift标准库</h3><p>DictionaryLiteral类型在系统库中被命名为KeyValuePairs<br>Sequence 协议不再具有 SubSequence 关联类型.之前返回 SubSequence 的 Sequence 方法现在返回的是具体的类型.例如,suffix(_:) 现在返回 Array.</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String之前需要转义\和”等,现在可以通过##,把你要写的字符串全部放这里就可以了,如果某个字符串需要转义通过”#()”操作.</p><pre><code>let str = #&quot; &quot;zhang&quot; san &quot;#print(str)let newStr = #&quot; \#(str) 是谁 \ &quot;#print(newStr)log: &quot;zhang&quot; san  &quot;zhang&quot; san  是谁 \</code></pre><p>多行字符:</p><pre><code>let multiLineStr = #&quot;&quot;&quot;                            今天                            明天                            昨天 \#(newStr)                            &quot;&quot;&quot;#        print(multiLineStr)</code></pre><h3 id="isMultiple"><a href="#isMultiple" class="headerlink" title="isMultiple"></a>isMultiple</h3><p>检查一个整数是否是另一个整数的倍数</p><pre><code>let originalNum = 18        if originalNum.isMultiple(of: 2) {            print(#&quot;\#(originalNum)是2的倍数&quot;#)        }</code></pre><h3 id="Swift-包管理器"><a href="#Swift-包管理器" class="headerlink" title="Swift 包管理器"></a>Swift 包管理器</h3><p>现在,在使用 Swift 5 Package.swift 工具版本时,可以声明一些常用的特定于目标的构建设置.新的设置也可以基于平台和构建配置进行条件化。构建设置支持 Swift 和 C 语言定义、C 语言头文件搜索路径、链接库和链接框架.</p><p>现在,在使用 Swift 5 Package.swift 工具版本时,可以为 Apple 平台自定义最低部署目标.如果程序包的任何依赖项指定的最小部署目标大于程序包自身的最低部署目标，就会抛出错误.<br>新的依赖项镜像功能允许顶层包覆盖依赖项 URL.</p>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Swift5 </tag>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msgSend()解读</title>
      <link href="/2019/04/25/msgSend-%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/25/msgSend-%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runtime最重要的两个核心问题:类的组装和消息.之前文章已经对Method,SEL,IMP,Class等有了初步的介绍,IMP就是一个SEL对应方法的实现函数指针.找到这个指针,就可以调用此函数.</p><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend()"></a>objc_msgSend()</h3><p>首先,我们在Student类中添加了一个- (void)name;方法,然后,通过stu实例调用这个方法:</p><pre><code>Student *stu = [[Student alloc]init];[stu name];</code></pre><p>利用clang编译器重写这个文件,这段代码最终被转换成:</p><pre><code>Student *stu = ((Student *(*)(id, SEL))(void *)objc_msgSend)((id)((Student *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Student&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)stu, sel_registerName(&quot;name&quot;));</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objc_msgSend()之前文章并没有提到过,这里这个方法传了两个参数:(id)stu,sel_registerName(“name”);stu是我们的实例的Student对象,sel_registerName(“name”)是根据name这个名字查找对应的SEL.但是并没有Runtime源码库中找到找到objc_msgSend()的实现过程.我们只能想别的办法了.在objc_init()入口函数中,可以看到有个加载+load方法的过程:</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-475a5a4987aebe79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_send.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然我们看不到源码,其objc_msgSend()调用栈中最后走到了lookUpImpOrForward()查找IMP的方法中,因此大可以猜想苹果objc_msgSend()其实就是根据实例对象以及sel查找imp的过程.</p><h3 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward()"></a>lookUpImpOrForward()</h3><pre><code>// MARK: - 获取imp/************************************************************************ lookUpImpOrForward.* The standard IMP lookup.* initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known.* If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use* must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst,bool initialize, bool cache, bool resolver){IMP imp = nil;bool triedResolver = NO;runtimeLock.assertUnlocked();// 首先从缓存中查找,如果找到了imp,直接返回// Optimistic cache lookupif (cache) {imp = cache_getImp(cls, sel);if (imp) return imp;}// runtimeLock is held during isRealized and isInitialized checking// to prevent races against concurrent realization.// runtimeLock is held during method search to make// method-lookup + cache-fill atomic with respect to method addition.// Otherwise, a category could be added but ignored indefinitely because// the cache was re-filled with the old value after the cache flush on// behalf of the category.runtimeLock.lock();checkIsKnownClass(cls);// 如果当前类不存在,先实现clsif (!cls-&gt;isRealized()) {realizeClass(cls);}if (initialize &amp;&amp; !cls-&gt;isInitialized()) {runtimeLock.unlock();_class_initialize (_class_getNonMetaClass(cls, inst));runtimeLock.lock();// If sel == initialize, _class_initialize will send +initialize and// then the messenger will send +initialize again after this// procedure finishes. Of course, if this is not being called// from the messenger then it won&#39;t happen. 2778172}retry:runtimeLock.assertLocked();// 从缓存中尝试查找IMP// Try this class&#39;s cache.imp = cache_getImp(cls, sel);if (imp) goto done;// 从本类的方法列表中尝试查找IMP// Try this class&#39;s method lists.{Method meth = getMethodNoSuper_nolock(cls, sel);if (meth) {log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);imp = meth-&gt;imp;goto done;}}// 从父类的方法列表中尝试查找IMP// Try superclass caches and method lists.{unsigned attempts = unreasonableClassCount();for (Class curClass = cls-&gt;superclass;curClass != nil;curClass = curClass-&gt;superclass){// Halt if there is a cycle in the superclass chain.if (--attempts == 0) {_objc_fatal(&quot;Memory corruption in class list.&quot;);}// Superclass cache.imp = cache_getImp(curClass, sel);if (imp) {if (imp != (IMP)_objc_msgForward_impcache) {// Found the method in a superclass. Cache it in this class.log_and_fill_cache(cls, imp, sel, inst, curClass);goto done;}else {// Found a forward:: entry in a superclass.// Stop searching, but don&#39;t cache yet; call method// resolver for this class first.break;}}// Superclass method list.Method meth = getMethodNoSuper_nolock(curClass, sel);if (meth) {log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);imp = meth-&gt;imp;goto done;}}}// 如果以上过程都没有找到,尝试一次动态方法解析// No implementation found. Try method resolver once.if (resolver &amp;&amp; !triedResolver) {runtimeLock.unlock();_class_resolveMethod(cls, sel, inst);runtimeLock.lock();// Don&#39;t cache the result; we don&#39;t hold the lock so it may have// changed already. Re-do the search from scratch instead.triedResolver = YES;goto retry;}// 如果方法解析也没有IMP,启动消息转发// No implementation found, and method resolver didn&#39;t help.// Use forwarding.imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst);done:runtimeLock.unlock();return imp;}</code></pre><p>查找IMP的过程源码逻辑清晰:</p><p>1)如果存在缓存&amp;&amp;缓存中有imp,直接返回imp;</p><pre><code>// 首先从缓存中查找,如果找到了imp,直接返回// Optimistic cache lookupif (cache) {imp = cache_getImp(cls, sel);if (imp) return imp;}</code></pre><p>2)缓存中没有找到imp,尝试从本类方法列表中获取imp,其先把imp缓存起来,然后返回imp:</p><pre><code>// 从本类的方法列表中尝试查找IMP// Try this class&#39;s method lists.{Method meth = getMethodNoSuper_nolock(cls, sel);if (meth) {// 缓存implog_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);imp = meth-&gt;imp;goto done;}}</code></pre><p>3)如果本类中没有找到imp,则</p><p>3.1)从父类继承链方法缓存中查找imp,找到直接返回imp;</p><p>3.2)如果从分类继承链中没有找到imp,则从父类继承链的方法列表中查找imp,找到后先缓存imp然后返回imp;</p><pre><code>// 从父类的方法列表中尝试查找IMP// Try superclass caches and method lists.{unsigned attempts = unreasonableClassCount();// 沿着继承链查找for (Class curClass = cls-&gt;superclass;curClass != nil;curClass = curClass-&gt;superclass){// Halt if there is a cycle in the superclass chain.if (--attempts == 0) {_objc_fatal(&quot;Memory corruption in class list.&quot;);}// 从父类缓存中查找imp// Superclass cache.imp = cache_getImp(curClass, sel);if (imp) {if (imp != (IMP)_objc_msgForward_impcache) {// Found the method in a superclass. Cache it in this class.log_and_fill_cache(cls, imp, sel, inst, curClass);goto done;}else {// Found a forward:: entry in a superclass.// Stop searching, but don&#39;t cache yet; call method// resolver for this class first.break;}}// 从父类方法列表中查找imp// Superclass method list.Method meth = getMethodNoSuper_nolock(curClass, sel);if (meth) {log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);imp = meth-&gt;imp;goto done;}}}</code></pre><p>4)如果以上尝试都没有找到imp,则尝试一次_class_resolveMethod(动态方法解析),把以上3步再走一遍:</p><pre><code>// 如果以上过程都没有找到,尝试一次动态方法解析// No implementation found. Try method resolver once.if (resolver &amp;&amp; !triedResolver) {runtimeLock.unlock();// 动态方法解析_class_resolveMethod(cls, sel, inst);runtimeLock.lock();// Don&#39;t cache the result; we don&#39;t hold the lock so it may have// changed already. Re-do the search from scratch instead.triedResolver = YES;goto retry;}</code></pre><p>5)如果动态方法解析也没有返回imp,则直接启动消息转发并会缓存转发的imp:</p><pre><code>// 如果方法解析也没有IMP,启动消息转发// No implementation found, and method resolver didn&#39;t help.// Use forwarding.imp = (IMP)_objc_msgForward_impcache;// 缓存impcache_fill(cls, sel, imp, inst);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找imp的过程相对简单,苹果为了提高性能添加了缓存功能.如果没有找到相应的函数实现指针,则会通过动态方法解析和消息转发来给objc_msgSend()提供一些”补救措施”.</p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>在Person类中声明了一个- age()方法,并没有实现,运行一下程序:</p><pre><code>Person *person = [[Person alloc]init];[person age];</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- age方法我们没有添加实现,其调用栈,走到了IMP lookUpImpOrForward()查找imp的动态方法解析中,也就是我们上面提到的第5步:</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-2a5446f48be014cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="resolveMethod"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以得出初步结论,如果我们没有给提个声明的方法添加实现,动态方法解析会被调用.最终程序走到了static void _objc_terminate(void){}函数里面,抛出一个常见的错误:</p><pre><code>2019-04-25 11:49:55.039691+0800 RuntimeDylibTest[6426:102439] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person age]: unrecognized selector sent to instance 0x100e8e5b0&#39;*** First throw call stack:(0 CoreFoundation 0x00007fff44dbc43d __exceptionPreprocess + 2561 libobjc.A.dylib 0x000000010036c64f objc_exception_throw + 472 CoreFoundation 0x00007fff44e39255 -[NSObject(NSObject) __retain_OA] + 03 CoreFoundation 0x00007fff44d5bad0 ___forwarding___ + 14864 CoreFoundation 0x00007fff44d5b478 _CF_forwarding_prep_0 + 1205 RuntimeDylibTest 0x0000000100000c9d main + 3016 libdyld.dylib 0x00007fff71d9c085 start + 17 ??? 0x0000000000000001 0x0 + 1)libc++abi.dylib: terminating with uncaught exception of type NSException</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个错误意思是我们向一个对象(person)发送了一个不能识别的消息.通常这种错误,苹果给我提供了三种补救措施.这就是接下来要讲的内容–消息转发.之前我们讲过一个sel对应一个imp,而这个imp就是函数实现指针,正常的消息发送就是找到了sel对应的imp,而消息转发就是是正常消息调用过程遇到问题了没有找到与之对应的imp而启动转发流程的过程,尝试将调用的sel转发到我们指定的imp的过程.</p><h3 id="动态方法解析resolveMethod"><a href="#动态方法解析resolveMethod" class="headerlink" title="动态方法解析resolveMethod"></a>动态方法解析resolveMethod</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在运行时系统中正常消息发送如果没有找到imp,会默认走一次动态方法解析.在NSObject.h文件中,关于动态方法解析的接口有两个方法:</p><pre><code>// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</code></pre><p>其在NSObject.mm的实现默认返回值是false,即在没有找到sel对应的imp时则会继续执行转发流程直到找不到imp报错,如果我们给没有实现的sel添加了一个imp并且返回true时,则最终方法调用会走我们添加的imp.</p><pre><code>// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel {return NO;}+ (BOOL)resolveInstanceMethod:(SEL)sel {return NO;}</code></pre><p>如果我们自己重写了这个两个方法,并返回true,就可以给未实现的方法添加一个实现imp.</p><pre><code>/**添加一个newAge@param obj obj@param _cmd 当前方法的sel*/void newAge (id obj, SEL _cmd) {NSLog(@&quot;added newAge method:%@&quot;,NSStringFromSelector(_cmd));}/**动态方法解析@param sel 不能识别的sel@return 消息是否处理了*/+ (BOOL)resolveInstanceMethod:(SEL)sel {if (sel == @selector(age)) {class_addMethod([self class], @selector(age), (IMP)newAge, &quot;V@:&quot;);return true;}return [super resolveInstanceMethod:sel];}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行时一些类型编码符合V表示void;@表示id或者obj对象;:表示SEL;_cmd表示当前方法的sel.其他的可以看<a href="[https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果接口文档</a>).</p><p>可以看到调用-age方法时走到我们添加的imp里面了.</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-cda5b5a09dc4439b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="resolve_instance_method"></p><h3 id="快速消息转发-重定向-fast-forwarding"><a href="#快速消息转发-重定向-fast-forwarding" class="headerlink" title="快速消息转发(重定向) fast forwarding"></a>快速消息转发(重定向) fast forwarding</h3><p>当我们没有重写动态方法解析或者没有未实现sel添加imp时,则会启动快速消息转发流程.快速消息转发需要重写系统提供的一个方法:</p><pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);- (id)forwardingTargetForSelector:(SEL)sel {return nil;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实现在NSObject.mm文件中,快速消息转发可以将某个没有实现的sel转发给某个对象obj,让这个对象来处理这个消息.其过程也是消息发送和转发的全过程,如果在obj所在的类中也没有找到sel对应的imp则会报错. 这里我们将-age方法转发给NSObject实例,因为NSObject类中并没有age方法的实现,所以直接报错.</p><pre><code>// MARK: - 快速消息转发- (id)forwardingTargetForSelector:(SEL)aSelector {if (aSelector == @selector(age)) {return [[NSObject alloc]init];}return [super forwardingTargetForSelector:aSelector];}2019-04-25 15:12:53.252362+0800 RuntimeDylibTest[18037:222826] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[NSObject age]: unrecognized selector sent to instance 0x100e622e0&#39;*** First throw call stack:(0 CoreFoundation 0x00007fff44dbc43d __exceptionPreprocess + 2561 libobjc.A.dylib 0x000000010036c64f objc_exception_throw + 472 CoreFoundation 0x00007fff44e39255 -[NSObject(NSObject) __retain_OA] + 03 CoreFoundation 0x00007fff44d5bad0 ___forwarding___ + 14864 CoreFoundation 0x00007fff44d5b478 _CF_forwarding_prep_0 + 1205 RuntimeDylibTest 0x0000000100000d8d main + 2376 libdyld.dylib 0x00007fff71d9c085 start + 17 ??? 0x0000000000000001 0x0 + 1)</code></pre><p>当我们新创建一个NewPerson类,并添加一个- age方法,然后将快速消息转发的方法返回值给NewPerson实例.可以看到消息被正常处理了:</p><pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector {if (aSelector == @selector(age)) {return [[NewPerson alloc]init];}return [super forwardingTargetForSelector:aSelector];}2019-04-25 15:21:34.094385+0800 RuntimeDylibTest[18083:227346] new person age</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-ca32727a2046e96a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NewPerson_age"></p><h3 id="正常消息转发-Normal-forward"><a href="#正常消息转发-Normal-forward" class="headerlink" title="正常消息转发 Normal forward"></a>正常消息转发 Normal forward</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当快速消息转发方法返回值为nil或者self时,将启动下一层级的消息转发流程也就是正常消息转发.正常消息转发可以说是给一个sel补救的最后措施,也是任何不能识别sel的转发中心,通常我们可以在NSObject的分类里面将不能识别的消息汇总在一起,统一处理.这里系统为我们提供了两个必现实现的方法:</p><pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSInvocation是一个消息调用类,它包含了所有OC消息的成分:target,SEL,参数,返回值等.NSInvocation可以将消息转换成一个对象,消息的每一个参数能够直接设定,而当一个NSInvocation对象调度时返回值是可以自己设定的,一个NSInvocation对象能够重复调度不同target,而且他的sel也能设置为另一个方法签名.NSInvocation遵守NSCoding协议，但是仅支持NSPortCoder编码，不支持归档型操作。</p><p>使用步骤</p><p>1)根据方法创建签名对象(NSMethodSignature对象)</p><p>2)根据签名对象创建调用对象(NSInvocation对象)</p><p>3)设置调用对象(NSInvocation对象)的相关信息</p><p>4)调用方法</p><p>5)获取方法返回值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正常消息转发过程中,重写- (NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector;方法返回方法签名就是用于生产NSInvocation对象,然后我们就可以在- (void)forwardInvocation:(NSInvocation </em>)anInvocation;方法中截货具体消息的发送对象target,选择子sel等信息,然后统一处理.</p><pre><code>// MARK: - 正常消息转发- (void)forwardInvocation:(NSInvocation *)anInvocation {SEL sel = anInvocation.selector;if (sel == @selector(age)) {NSLog(@&quot;umimplementation age&quot;);} else {NSLog(@&quot;give user a hint&quot;);}}- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];if (!methodSignature) {methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];}return methodSignature;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-5cd4c03c365cb5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal_forward"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息是Runtime核心的问题之一,消息发送和转发的其实是对imp的查找处理过程,对这些过程了解后应该对实际开发遇到的问题及解决会有较大帮助.</p><h2 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h2><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h2 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h2><p><strong>博客地址:</strong> <a href="https://waitwalker.cn/" target="_blank" rel="noopener">https://waitwalker.cn/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block解读/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/SSIrreplaceable/article/details/53375972" target="_blank" rel="noopener">https://blog.csdn.net/SSIrreplaceable/article/details/53375972</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weak解读</title>
      <link href="/2019/04/24/Weak%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/24/Weak%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>在常规开发中我们经常使用__weak修饰符来修饰一个对象,来解决比如循环引用问题.今天具体来看看weak底层实现原理.</p><p>首先创建一个weak修饰的对象,并查看其调用栈:</p><pre><code>int main(int argc, const char * argv[]) {@autoreleasepool {Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);objc_registerClassPair(newClass);id newObject = [[newClass alloc]init];NSLog(@&quot;%s&quot;,class_getName([newObject class]));NSLog(@&quot;Hello, World!&quot;);Person *person = [[Person alloc]init];Person *p2 = person;[person name];[person name];Class cls = [Person class];// weak__weak id weakP = person;NSLog(@&quot;weakP point address: %p&quot;,&amp;weakP);NSLog(@&quot;person point address: %p&quot;,&amp;person);NSLog(@&quot;weakP address: %p&quot;,weakP);NSLog(@&quot;person address: %p&quot;,person);}return 0;}</code></pre><h3 id="init-weak"><a href="#init-weak" class="headerlink" title="init_weak()"></a>init_weak()</h3><p>其走到了id objc_initWeak(id *location, id newObj){}函数里面:</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-9863a50c8bfc19b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="init_weak.png"></p><p>其内部调用的是:</p><pre><code>template &lt;HaveOld haveOld, HaveNew haveNew,CrashIfDeallocating crashIfDeallocating&gt;static idstoreWeak(id *location, objc_object *newObj){}</code></pre><p>storeWeak有三个模板参数HaveOld,HaveNew,CrashIfDeallocating默认的是</p><pre><code>HaveOld:为true,weak对象已存在,需要清理;HaveNew:为true需要给weak对象分配一个新值;CrashIfDeallocating:为true,storeWeak过程要终止,因为对象正在释放或者newObj的类不支持弱引用.</code></pre><h3 id="storeWeak-函数的内部实现"><a href="#storeWeak-函数的内部实现" class="headerlink" title="storeWeak()函数的内部实现:"></a>storeWeak()函数的内部实现:</h3><pre><code>template &lt;HaveOld haveOld, HaveNew haveNew,CrashIfDeallocating crashIfDeallocating&gt;static idstoreWeak(id *location, objc_object *newObj){assert(haveOld || haveNew);if (!haveNew) assert(newObj == nil);Class previouslyInitializedClass = nil;id oldObj;SideTable *oldTable;SideTable *newTable;// Acquire locks for old and new values.// Order by lock address to prevent lock ordering problems.// Retry if the old value changes underneath us.retry:if (haveOld) {oldObj = *location;oldTable = &amp;SideTables()[oldObj];} else {oldTable = nil;}if (haveNew) {newTable = &amp;SideTables()[newObj];} else {newTable = nil;}SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);if (haveOld &amp;&amp; *location != oldObj) {SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);goto retry;}// Prevent a deadlock between the weak reference machinery// and the +initialize machinery by ensuring that no// weakly-referenced object has an un-+initialized isa.if (haveNew &amp;&amp; newObj) {Class cls = newObj-&gt;getIsa();if (cls != previouslyInitializedClass &amp;&amp;!((objc_class *)cls)-&gt;isInitialized()){SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);_class_initialize(_class_getNonMetaClass(cls, (id)newObj));// If this class is finished with +initialize then we&#39;re good.// If this class is still running +initialize on this thread// (i.e. +initialize called storeWeak on an instance of itself)// then we may proceed but it will appear initializing and// not yet initialized to the check above.// Instead set previouslyInitializedClass to recognize it on retry.previouslyInitializedClass = cls;goto retry;}}// Clean up old value, if any.if (haveOld) {weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);}// Assign new value, if any.if (haveNew) {newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location,crashIfDeallocating);// weak_register_no_lock returns nil if weak store should be rejected// Set is-weakly-referenced bit in refcount table.if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) {newObj-&gt;setWeaklyReferenced_nolock();}// Do not set *location anywhere else. That would introduce a race.*location = (id)newObj;}else {// No new value. The storage is not changed.}SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);return (id)newObj;}</code></pre><h4 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h4><p>首先声明了两个SideTable实例,SideTable我们之前文章已经介绍过了,其内部主要有三个成员变量(spinlock_t,RefcountMap,weak_table_t)和一些锁相关的成员方法:</p><pre><code>// MARK: - sideTable类struct SideTable {spinlock_t slock;//保证原子操作的自旋锁RefcountMap refcnts;//保存引用计数的散列表weak_table_t weak_table;//保存weak引用的全局散列表SideTable() {memset(&amp;weak_table, 0, sizeof(weak_table));}~SideTable() {_objc_fatal(&quot;Do not delete SideTable.&quot;);}void lock() { slock.lock(); }void unlock() { slock.unlock(); }void forceReset() { slock.forceReset(); }// Address-ordered lock discipline for a pair of side tables.template&lt;HaveOld, HaveNew&gt;static void lockTwo(SideTable *lock1, SideTable *lock2);template&lt;HaveOld, HaveNew&gt;static void unlockTwo(SideTable *lock1, SideTable *lock2);};</code></pre><h4 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h4><p>weak_table_t就是一个全局的存取weak引用.其中将对象地址作为key,weak_entry_t结构作为value,存储在weak_table_t中.weak_entry_t中就保存了所有指向该对象的weak指针.</p><pre><code>// MARK: - 全局弱引用表, 对象地址作为key,weak_entry_t结构作为value/*** The global weak references table. Stores object ids as keys,* and weak_entry_t structs as their values.*/struct weak_table_t {weak_entry_t *weak_entries;size_t num_entries;uintptr_t mask;uintptr_t max_hash_displacement;};</code></pre><p>*weak_entries:用于存储引用对象的结合</p><p>num_entries:entry数目</p><p>mask:当前分配容量</p><p>max_hash_displacement:已使用容量</p><h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><pre><code>struct weak_entry_t {DisguisedPtr&lt;objc_object&gt; referent;union {struct {weak_referrer_t *referrers;uintptr_t out_of_line_ness : 2;uintptr_t num_refs : PTR_MINUS_2;uintptr_t mask;uintptr_t max_hash_displacement;};struct {// out_of_line_ness field is low bits of inline_referrers[1]weak_referrer_t inline_referrers[WEAK_INLINE_COUNT];};};bool out_of_line() {return (out_of_line_ness == REFERRERS_OUT_OF_LINE);}weak_entry_t&amp; operator=(const weak_entry_t&amp; other) {memcpy(this, &amp;other, sizeof(other));return *this;}weak_entry_t(objc_object *newReferent, objc_object **newReferrer): referent(newReferent){inline_referrers[0] = newReferrer;for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) {inline_referrers[i] = nil;}}};</code></pre><p>weak_entry_t是存放weak对象和weak指针的地方,其成员变量referent是引用对象.union结构:</p><p>weak_referrer_t *referrers;//存放weak指针</p><p>uintptr_t out_of_line_ness : 2;//标识当前存储是否在默认WEAK_INLINE_COUNT个数之内</p><p>uintptr_t num_refs : PTR_MINUS_2;//引用的个数</p><p>uintptr_t mask;//实际分配容量</p><p>uintptr_t max_hash_displacement;//实际使用容量</p><p>weak_referrer_t inline_referrers[WEAK_INLINE_COUNT];//当引用个数小于WEAK_INLINE_COUNT时,用这个存储weak指针地址.</p><h4 id="oldTable-amp-newTable逻辑"><a href="#oldTable-amp-newTable逻辑" class="headerlink" title="oldTable&amp;newTable逻辑"></a>oldTable&amp;newTable逻辑</h4><h4 id="haveOld"><a href="#haveOld" class="headerlink" title="haveOld"></a>haveOld</h4><pre><code>oldObj = *location;oldTable = &amp;SideTables()[oldObj];</code></pre><p>当存在旧的weak对象的时候,要把*location赋值给旧的对象oldObj,然后通过oldObj的hash值,在SideTableBuf中找到对应的SideTable.其中SideTableBuf的实例化过程:</p><pre><code>// SideTableBuf静态全局变量alignas(StripedMap&lt;SideTable&gt;) static uint8_tSideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];// MARK: - runtime初始化时调用(objc_init)static void SideTableInit() {new (SideTableBuf) StripedMap&lt;SideTable&gt;();}// reinterpret_cast C++里的强制类型转换符static StripedMap&lt;SideTable&gt;&amp; SideTables() {return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);}</code></pre><h4 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h4><p>我们可以看到StripedMap这个类,StripedMap其实是一个C++模板类,初始化时需要指定一个类型.</p><pre><code>template&lt;typename T&gt;class StripedMap {#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATORenum { StripeCount = 8 };#elseenum { StripeCount = 64 };#endifstruct PaddedT {T value alignas(CacheLineSize);};PaddedT array[StripeCount];static unsigned int indexForPointer(const void *p) {uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;}// MARK: - 重写[]操作符,计算hashpublic:T&amp; operator[] (const void *p) {return array[indexForPointer(p)].value;}const T&amp; operator[] (const void *p) const {return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p];}}</code></pre><p>StripedMap是一个泛型类,重写[]运算符,通过传入的对象地址,计算出hash值,然后通过hash值在SideTableBuf中找出对应的SideTable.</p><h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><p>现在我们根据对象的地址找到了对应的SideTable了,然后就可以操作其成员变量weak_table了.</p><p>如果haveOld=ture,需要先清理一下旧的weak对象.</p><pre><code>// 清理旧的obj// Clean up old value, if any.if (haveOld) {weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);}</code></pre><p>具体实现:</p><pre><code>voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id,id *referrer_id){objc_object *referent = (objc_object *)referent_id;objc_object **referrer = (objc_object **)referrer_id;weak_entry_t *entry;if (!referent) return;if ((entry = weak_entry_for_referent(weak_table, referent))) {remove_referrer(entry, referrer);bool empty = true;if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) {empty = false;}else {for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {if (entry-&gt;inline_referrers[i]) {empty = false;break;}}}if (empty) {weak_entry_remove(weak_table, entry);}}// Do not set *referrer = nil. objc_storeWeak() requires that the// value not change.}</code></pre><p>这步主要用于在指针即将消失时,而对象还没有置为nil.主要防止空指针指向对象造成坏内存访问错误.</p><p>首先通过weak_entry_for_referent()函数查找到weak_entry_t:</p><pre><code>// MARK: - 通过对象地址,在weak_entries中找到对应的weak_entry_t/*** Return the weak reference table entry for the given referent.* If there is no entry for referent, return NULL.* Performs a lookup.** @param weak_table* @param referent The object. Must not be nil.** @return The table of weak referrers to this object.*/static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent){assert(referent);weak_entry_t *weak_entries = weak_table-&gt;weak_entries;if (!weak_entries) return nil;// 获取hash值 按位与操作size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;size_t index = begin;size_t hash_displacement = 0;// 遍历weak_table中的weak_entries,比对weak_entries[index].referent对象和referent对象是否相等while (weak_table-&gt;weak_entries[index].referent != referent) {index = (index+1) &amp; weak_table-&gt;mask;if (index == begin) bad_weak_table(weak_table-&gt;weak_entries);hash_displacement++;if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {return nil;}}// 返回weak指针return &amp;weak_table-&gt;weak_entries[index];}</code></pre><h4 id="remove-referrer"><a href="#remove-referrer" class="headerlink" title="remove_referrer"></a>remove_referrer</h4><pre><code>// MARK: - 移除weak指针/*** Remove old_referrer from set of referrers, if it&#39;s present.* Does not remove duplicates, because duplicates should not exist.** @todo this is slow if old_referrer is not present. Is this ever the case?** @param entry The entry holding the referrers.* @param old_referrer The referrer to remove.*/static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer){if (! entry-&gt;out_of_line()) {for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {if (entry-&gt;inline_referrers[i] == old_referrer) {entry-&gt;inline_referrers[i] = nil;return;}}_objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;&quot;at %p. This is probably incorrect use of &quot;&quot;objc_storeWeak() and objc_loadWeak(). &quot;&quot;Break on objc_weak_error to debug.\n&quot;,old_referrer);objc_weak_error();return;}size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);size_t index = begin;size_t hash_displacement = 0;while (entry-&gt;referrers[index] != old_referrer) {index = (index+1) &amp; entry-&gt;mask;if (index == begin) bad_weak_table(entry);hash_displacement++;if (hash_displacement &gt; entry-&gt;max_hash_displacement) {_objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;&quot;at %p. This is probably incorrect use of &quot;&quot;objc_storeWeak() and objc_loadWeak(). &quot;&quot;Break on objc_weak_error to debug.\n&quot;,old_referrer);objc_weak_error();return;}}entry-&gt;referrers[index] = nil;entry-&gt;num_refs--;}</code></pre><p>如果weak指针不存放在out_of_line中,从WEAK_INLINE_COUNT移除;如果存在在out_of_line中,将referrers中weak指针置为nil,并将weak指针数目num_refs减1;</p><p>主要逻辑思路:</p><p>1)根据对象的地址的hash值获取到全局的SideTable</p><p>2)从SideTable的成员变量entries中获取到对象地址对应的entry</p><p>3)将entry的weak置为nil,更新weak指针数量</p><h4 id="haveNew"><a href="#haveNew" class="headerlink" title="haveNew"></a>haveNew</h4><pre><code>newTable = &amp;SideTables()[newObj];</code></pre><p>也是通过hash值在SideTableBuf中找出对应的SideTable.</p><h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><pre><code>// MARK: - 注册一个新的(对象,weak指针)键值对,创建一个新的entry/*** Registers a new (object, weak pointer) pair. Creates a new weak* object entry if it does not exist.** @param weak_table The global weak table.* @param referent The object pointed to by the weak reference.* @param referrer The weak pointer address.*/idweak_register_no_lock(weak_table_t *weak_table, id referent_id,id *referrer_id, bool crashIfDeallocating){objc_object *referent = (objc_object *)referent_id;objc_object **referrer = (objc_object **)referrer_id;if (!referent || referent-&gt;isTaggedPointer()) return referent_id;// ensure that the referenced object is viablebool deallocating;if (!referent-&gt;ISA()-&gt;hasCustomRR()) {deallocating = referent-&gt;rootIsDeallocating();}else {BOOL (*allowsWeakReference)(objc_object *, SEL) =(BOOL(*)(objc_object *, SEL))object_getMethodImplementation((id)referent,SEL_allowsWeakReference);if ((IMP)allowsWeakReference == _objc_msgForward) {return nil;}deallocating =! (*allowsWeakReference)(referent, SEL_allowsWeakReference);}if (deallocating) {if (crashIfDeallocating) {_objc_fatal(&quot;Cannot form weak reference to instance (%p) of &quot;&quot;class %s. It is possible that this object was &quot;&quot;over-released, or is in the process of deallocation.&quot;,(void*)referent, object_getClassName((id)referent));} else {return nil;}}// now remember it and where it is being storedweak_entry_t *entry;// 如果entry已经存在,直接将weak指针存储到entry中if ((entry = weak_entry_for_referent(weak_table, referent))) {append_referrer(entry, referrer);}else {// 如果entry不存在,先创建一个entry,然后把weak指针存到entry中weak_entry_t new_entry(referent, referrer);// weak_table size扩容weak_grow_maybe(weak_table);// 将entry插入到weak_table的entries中weak_entry_insert(weak_table, &amp;new_entry);}// Do not set *referrer. objc_storeWeak() requires that the// value not change.return referent_id;}</code></pre><h4 id="append-referrer"><a href="#append-referrer" class="headerlink" title="append_referrer()"></a>append_referrer()</h4><p>如果entry已经存在,直接将weak指针存储到entry中:</p><pre><code>// MARK: - 将weak指针添加到entry的weak指针集合中/*** Add the given referrer to set of weak pointers in this entry.* Does not perform duplicate checking (b/c weak pointers are never* added to a set twice).** @param entry The entry holding the set of weak pointers.* @param new_referrer The new weak pointer to be added.*/static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){if (! entry-&gt;out_of_line()) {// Try to insert inline.for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {if (entry-&gt;inline_referrers[i] == nil) {entry-&gt;inline_referrers[i] = new_referrer;return;}}// Couldn&#39;t insert inline. Allocate out of line.weak_referrer_t *new_referrers = (weak_referrer_t *)calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));// This constructed table is invalid, but grow_refs_and_insert// will fix it and rehash it.for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {new_referrers[i] = entry-&gt;inline_referrers[i];}entry-&gt;referrers = new_referrers;entry-&gt;num_refs = WEAK_INLINE_COUNT;entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;entry-&gt;mask = WEAK_INLINE_COUNT-1;entry-&gt;max_hash_displacement = 0;}assert(entry-&gt;out_of_line());if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) {return grow_refs_and_insert(entry, new_referrer);}size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);size_t index = begin;size_t hash_displacement = 0;while (entry-&gt;referrers[index] != nil) {hash_displacement++;index = (index+1) &amp; entry-&gt;mask;if (index == begin) bad_weak_table(entry);}if (hash_displacement &gt; entry-&gt;max_hash_displacement) {entry-&gt;max_hash_displacement = hash_displacement;}weak_referrer_t &amp;ref = entry-&gt;referrers[index];ref = new_referrer;entry-&gt;num_refs++;}</code></pre><h4 id="new-entry"><a href="#new-entry" class="headerlink" title="new_entry()"></a>new_entry()</h4><p>如果entry不存在,先创建一个entry,然后把weak指针存到entry中:</p><pre><code>// 如果entry不存在,先创建一个entry,然后把weak指针存到entry中weak_entry_t new_entry(referent, referrer);// weak_table size扩容weak_grow_maybe(weak_table);// 将entry插入到weak_table的entries中weak_entry_insert(weak_table, &amp;new_entry);// MARK: - 将entry插入到weak_table_t的entries中/*** Add new_entry to the object&#39;s table of weak references.* Does not check whether the referent is already in the table.*/static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry){weak_entry_t *weak_entries = weak_table-&gt;weak_entries;assert(weak_entries != nil);size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);size_t index = begin;size_t hash_displacement = 0;while (weak_entries[index].referent != nil) {index = (index+1) &amp; weak_table-&gt;mask;if (index == begin) bad_weak_table(weak_entries);hash_displacement++;}weak_entries[index] = *new_entry;weak_table-&gt;num_entries++;if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {weak_table-&gt;max_hash_displacement = hash_displacement;}}</code></pre><p>主要逻辑思路:</p><p>1)根据对象的地址的hash值获取到全局的SideTable</p><p>2)从SideTable的成员变量entries中获取到对象地址对应的entry</p><p>3)将weak指针存储到entry中,更新weak指针数量</p><h3 id="dealloc-weak"><a href="#dealloc-weak" class="headerlink" title="dealloc weak"></a>dealloc weak</h3><p>我们知道对象被销毁了,会走-dealloc()方法,下面我们来看看一个对象的weak指针效果过程:</p><pre><code>- (void)dealloc;// Replaced by NSZombies- (void)dealloc {_objc_rootDealloc(self);}void_objc_rootDealloc(id obj){assert(obj);obj-&gt;rootDealloc();}</code></pre><p>可以看到dealloc调用的是NSObject.mm文件中的_objc_rootDealloc()方法,这个方法内部调用的是obj的成员方法rootDealloc():</p><pre><code>// MARK: - 销毁对象inline voidobjc_object::rootDealloc(){if (isTaggedPointer()) return; // fixme necessary?// 如果是nonpointer优化的对象并且没有weakly_referenced,没有has_assoc,没有has_cxx_dtor,没有has_sidetable_rc,快速释放对象if (fastpath(isa.nonpointer &amp;&amp;!isa.weakly_referenced &amp;&amp;!isa.has_assoc &amp;&amp;!isa.has_cxx_dtor &amp;&amp;!isa.has_sidetable_rc)){assert(!sidetable_present());free(this);}else {// 否则调用此方法object_dispose((id)this);}}</code></pre><p>如果对象是nonpointer优化的对象并且没有weak指针指向它,没有SideTable存储引用计数等,将快速释放,否则调用object_dispose()销毁对象:</p><pre><code>idobject_dispose(id obj){if (!obj) return nil;objc_destructInstance(obj);free(obj);return nil;}// MARK: - 销毁实例对象/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory.* Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj){if (obj) {// Read all of the flags at once for performance.bool cxx = obj-&gt;hasCxxDtor();bool assoc = obj-&gt;hasAssociatedObjects();// This order is important.if (cxx) object_cxxDestruct(obj);if (assoc) _object_remove_assocations(obj);obj-&gt;clearDeallocating();}return obj;}</code></pre><p>调用栈中有objc_destructInstance()方法内有处理关联对象的方法,其接下来调用的方法是clearDeallocating()方法:</p><pre><code>inline voidobjc_object::clearDeallocating(){if (slowpath(!isa.nonpointer)) {// Slow path for raw pointer isa.sidetable_clearDeallocating();}else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) {// Slow path for non-pointer isa with weak refs and/or side table data.clearDeallocating_slow();}assert(!sidetable_present());}</code></pre><p>如果对象本身又weak指针指向它或者在SideTable中存储了引用计数,则通过clearDeallocating_slow()方法处理:</p><pre><code>// MARK: - 清除weak指针和SideTable中的引用计数// Slow path of clearDeallocating()// for objects with nonpointer isa// that were ever weakly referenced// or whose retain count ever overflowed to the side table.NEVER_INLINE voidobjc_object::clearDeallocating_slow(){assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc));SideTable&amp; table = SideTables()[this];table.lock();if (isa.weakly_referenced) {weak_clear_no_lock(&amp;table.weak_table, (id)this);}if (isa.has_sidetable_rc) {table.refcnts.erase(this);}table.unlock();}</code></pre><h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><p>清除weak指针,首先在SideTable的成员变量entries中找到 dealloced obj对应的entry,遍历entry中的weak指针数组,将所有weak指针置为nil,然后将这个entry从entries中移除:</p><pre><code>/*** Called by dealloc; nils out all weak pointers that point to the* provided object so that they can no longer be used.** @param weak_table* @param referent The object being deallocated.*/voidweak_clear_no_lock(weak_table_t *weak_table, id referent_id){objc_object *referent = (objc_object *)referent_id;weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);if (entry == nil) {/// XXX shouldn&#39;t happen, but does with mismatched CF/objc//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);return;}// zero out referencesweak_referrer_t *referrers;size_t count;if (entry-&gt;out_of_line()) {referrers = entry-&gt;referrers;count = TABLE_SIZE(entry);}else {referrers = entry-&gt;inline_referrers;count = WEAK_INLINE_COUNT;}for (size_t i = 0; i &lt; count; ++i) {objc_object **referrer = referrers[i];if (referrer) {if (*referrer == referent) {*referrer = nil;}else if (*referrer) {_objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;&quot;This is probably incorrect use of &quot;&quot;objc_storeWeak() and objc_loadWeak(). &quot;&quot;Break on objc_weak_error to debug.\n&quot;,referrer, (void*)*referrer, (void*)referent);objc_weak_error();}}}weak_entry_remove(weak_table, entry);}</code></pre><h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><p>擦除SideTable中的存储的对象引用计数</p><pre><code>table.refcnts.erase(this);bool erase(const KeyT &amp;Val) {BucketT *TheBucket;if (!LookupBucketFor(Val, TheBucket))return false; // not in map.TheBucket-&gt;second.~ValueT();TheBucket-&gt;first = getTombstoneKey();decrementNumEntries();incrementNumTombstones();compact();return true;}</code></pre><p>主要逻辑思路:</p><p>1)根据对象的地址的hash值获取到全局的SideTable</p><p>2)从SideTable的成员变量entries中获取到对象地址对应的entry</p><p>3)遍历entry中weak数组将weak指针置为nil</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>weak引用的实现是多个hash表的嵌套.首先根据对象地址hash value找到全局SideTable;然后在SideTable中找到对应的entry对其进行操作.通过查看源码实现过程,思路还是比较清晰.</p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.cn/" target="_blank" rel="noopener">https://waitwalker.cn/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block解读/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> iOS </tag>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autorelease解读</title>
      <link href="/2019/04/23/Autorelease%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/23/Autorelease%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Autorelease翻译过来就是自动释放,什么是自动释放,怎么自动释放,什么时候自动释放.这些是本文的研究重点.自动释放首先要从autoreleasepool说起.</p><h3 id="autoreleasepool是什么"><a href="#autoreleasepool是什么" class="headerlink" title="autoreleasepool是什么?"></a>autoreleasepool是什么?</h3><p>通过clang编译器重写以下我们的Objective-C代码:</p><pre><code>// autoreleasepool    @autoreleasepool {    }</code></pre><p>这里我们定义了一个autoreleasepool对象,查看一下clang编译器重写后的源码:</p><pre><code>/* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;    }// __AtAutoreleasePool声明结构struct __AtAutoreleasePool {  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}  void * atautoreleasepoolobj;};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到通过<strong>AtAutoreleasePool结构构造了一个 </strong>autoreleasepool实例,<strong>AtAutoreleasePool()方法被调用即执行atautoreleasepoolobj = objc_autoreleasePoolPush()方法;析构时,即超出</strong>AtAutoreleasePool的作用域,调用~__AtAutoreleasePool()方法,即即执行的是objc_autoreleasePoolPop(atautoreleasepoolobj)方法.其过程可以细分为以下过程(以objc-loadmethod.mm中调用load方法为例):</p><pre><code>void call_load_methods(void){    static bool loading = NO;    bool more_categories;    loadMethodLock.assertLocked();    // Re-entrant calls do nothing; the outermost call will finish the job.    if (loading) return;    loading = YES;    // push    void *pool = objc_autoreleasePoolPush();    do {        // 1. Repeatedly call class +loads until there aren&#39;t any more        while (loadable_classes_used &gt; 0) {            call_class_loads();        }        // 2. Call category +loads ONCE        more_categories = call_category_loads();        // 3. Run more +loads if there are classes OR more untried categories    } while (loadable_classes_used &gt; 0  ||  more_categories);    // pop    objc_autoreleasePoolPop(pool);    loading = NO;}</code></pre><p>因此我们可以初步总结autoreleasepool的执行过程主要有:<br>1)objc_autoreleasePoolPush()构造;<br>2)autorelease操作;<br>3)objc_autoreleasePoolPop(void <em>ctxt)析构<br>而objc_autoreleasePoolPush()和objc_autoreleasePoolPop(void </em>ctxt)内部分别调用的是:</p><pre><code>void *objc_autoreleasePoolPush(void){    return AutoreleasePoolPage::push();}voidobjc_autoreleasePoolPop(void *ctxt){    AutoreleasePoolPage::pop(ctxt);}</code></pre><p>可以看到分别调用的是AutoreleasePoolPage中的成员方法;AutoreleasePoolPage,在NSObject.mm文件中:</p><pre><code>// MARK: - AutoReleasepool classclass AutoreleasePoolPage{    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is    // pushed and it has never contained any objects. This saves memory    // when the top level (i.e. libdispatch) pushes and pops pools but    // never uses them.#   define EMPTY_POOL_PLACEHOLDER ((id*)1)#   define POOL_BOUNDARY nil    static pthread_key_t const key = AUTORELEASE_POOL_KEY;    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing    static size_t const SIZE =#if PROTECT_AUTORELEASEPOOL        PAGE_MAX_SIZE;  // must be multiple of vm page size#else        PAGE_MAX_SIZE;  // size and alignment, power of 2#endif    static size_t const COUNT = SIZE / sizeof(id);   // 校验完整性    magic_t const magic;    // next指针指向最新添加的autoreleased对象的下一个位置,初始化时指向begin()    id *next;    // 指向当前线程    pthread_t const thread;    // 父节点    AutoreleasePoolPage * const parent;    // 子节点    AutoreleasePoolPage *child;    // 节点深度    uint32_t const depth;    uint32_t hiwat;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看autoreleasepool的源码可以看出,autoreleasepool没有单独的内存结构,它是以 AutoreleasePoolPage为单个节点组成的双向链表来实现的.autoreleasePoolPage中一些成员变量:</p><pre><code>magic:校验autoreleasepoolpage结构完整性;next:指向最新添加的autoreleased对象的下一个位置;thread:指向当前线程;parent:指向父节点,第一个节点parent为nil(相当于表头);child:指向子节点,最后一个节点child为nil(相当于表尾);</code></pre><h3 id="push-方法"><a href="#push-方法" class="headerlink" title="push()方法"></a>push()方法</h3><p>push()方法也就是创建一个autoreleasepoolpage实例的过程:</p><pre><code>// push    static inline void *push()    {        id *dest;        if (DebugPoolAllocation) {            // 每一个autoreleasepool对象开始于一个新的autoreleasepoolpage            // Each autorelease pool starts on a new pool page.            dest = autoreleaseNewPage(POOL_BOUNDARY);        } else {            dest = autoreleaseFast(POOL_BOUNDARY);        }        assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);        return dest;    }</code></pre><p>其逻辑过程:</p><pre><code>// 创建一个page逻辑    static inline id *autoreleaseFast(id obj)    {        AutoreleasePoolPage *page = hotPage();        if (page &amp;&amp; !page-&gt;full()) {            return page-&gt;add(obj);        } else if (page) {            return autoreleaseFullPage(obj, page);        } else {            return autoreleaseNoPage(obj);        }    }</code></pre><p>其中每个page最多存储有4096个bytes:</p><pre><code>#define I386_PGBYTES        4096        /* bytes per 80386 page */#define I386_PGSHIFT        12        /* bitshift for pages */#define    PAGE_SIZE        I386_PGBYTES</code></pre><p>当第一次创建的时候传入的是nil,所以调用autoreleaseNoPage()函数,创建一个新的page:</p><pre><code>static __attribute__((noinline))    id *autoreleaseNoPage(id obj)    {        // &quot;No page&quot; could mean no pool has been pushed        // or an empty placeholder pool has been pushed and has no contents yet        assert(!hotPage());        bool pushExtraBoundary = false;        if (haveEmptyPoolPlaceholder()) {            // We are pushing a second pool over the empty placeholder pool            // or pushing the first object into the empty placeholder pool.            // Before doing that, push a pool boundary on behalf of the pool            // that is currently represented by the empty placeholder.            pushExtraBoundary = true;        }        else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) {            // We are pushing an object with no pool in place,            // and no-pool debugging was requested by environment.            _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;                         &quot;autoreleased with no pool in place - &quot;                         &quot;just leaking - break on &quot;                         &quot;objc_autoreleaseNoPool() to debug&quot;,                         pthread_self(), (void*)obj, object_getClassName(obj));            objc_autoreleaseNoPool(obj);            return nil;        }        else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) {            // We are pushing a pool with no pool in place,            // and alloc-per-pool debugging was not requested.            // Install and return the empty pool placeholder.            return setEmptyPoolPlaceholder();        }        // We are pushing an object or a non-placeholder&#39;d pool.        // Install the first page.        AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);        setHotPage(page);        // Push a boundary on behalf of the previously-placeholder&#39;d pool.        if (pushExtraBoundary) {            page-&gt;add(POOL_BOUNDARY);        }        // Push the requested object or pool.        return page-&gt;add(obj);    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push()方法类似于autoreleasepool的初始化方法,先创建一个autoreleasepoolpage节点,然后想page中添加一个nil对象占位.</p><pre><code>dest = autoreleaseFast(POOL_BOUNDARY);define POOL_BOUNDARY nil</code></pre><h3 id="autorelease-方法"><a href="#autorelease-方法" class="headerlink" title="autorelease()方法"></a>autorelease()方法</h3><p>查看一下NSObject.h提供的autorelease方法接口,其调用栈:</p><pre><code>- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;// Replaced by ObjectAlloc- (id)autorelease {    return ((id)self)-&gt;rootAutorelease();}// MARK: - autorelease 实现// Base autorelease implementation, ignoring overrides.inline idobjc_object::rootAutorelease(){    if (isTaggedPointer()) return (id)this;    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;    return rootAutorelease2();}__attribute__((noinline,used))idobjc_object::rootAutorelease2(){    assert(!isTaggedPointer());    return AutoreleasePoolPage::autorelease((id)this);}</code></pre><p>可以看到autorelease最终调用的是AutoreleasePoolPage中的成员方法autorelease();</p><pre><code>// autorelease    static inline id autorelease(id obj)    {        assert(obj);        assert(!obj-&gt;isTaggedPointer());        id *dest __unused = autoreleaseFast(obj);        assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);        return obj;    }</code></pre><p>AutoreleasePoolPage中的成员方法autorelease()内部调用的是:</p><pre><code>static inline id *autoreleaseFast(id obj)    {        AutoreleasePoolPage *page = hotPage();        if (page &amp;&amp; !page-&gt;full()) {            return page-&gt;add(obj);        } else if (page) {            return autoreleaseFullPage(obj, page);        } else {            return autoreleaseNoPage(obj);        }    }</code></pre><p>其逻辑是:<br>1)先判断当前page存在并且没满,则将released obj 添加到当前page;<br>2)如果当前page已满,则创建一个新的page,并将当前page的child指针指向new page;把released obj 添加到new page中;</p><pre><code>// MARK: - 创建一个new page    static __attribute__((noinline))    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)    {        // The hot page is full.        // Step to the next non-full page, adding a new page if necessary.        // Then add the object to that page.        assert(page == hotPage());        assert(page-&gt;full()  ||  DebugPoolAllocation);        do {            if (page-&gt;child) page = page-&gt;child;            else page = new AutoreleasePoolPage(page);        } while (page-&gt;full());        setHotPage(page);        return page-&gt;add(obj);    }</code></pre><p>3)如果当前page不存在,则直接创建一个new page,并把released obj添加到new page中;没有page意味着autoreleasepool没有进行push操作或者autoreleasepool已经push操作了,但是没有添加任何released的obj或者添加的是nil对象,则创建一个空的autoreleasepool进行占位;</p><pre><code>// autoreleasepool中没有page    static __attribute__((noinline))    id *autoreleaseNoPage(id obj)    {        // &quot;No page&quot; could mean no pool has been pushed        // or an empty placeholder pool has been pushed and has no contents yet        assert(!hotPage());        bool pushExtraBoundary = false;        if (haveEmptyPoolPlaceholder()) {            // We are pushing a second pool over the empty placeholder pool            // or pushing the first object into the empty placeholder pool.            // Before doing that, push a pool boundary on behalf of the pool            // that is currently represented by the empty placeholder.            pushExtraBoundary = true;        }        else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) {//如果没有创建一个autoreleasepool,则直接抛异常            // We are pushing an object with no pool in place,            // and no-pool debugging was requested by environment.            _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;                         &quot;autoreleased with no pool in place - &quot;                         &quot;just leaking - break on &quot;                         &quot;objc_autoreleaseNoPool() to debug&quot;,                         pthread_self(), (void*)obj, object_getClassName(obj));            objc_autoreleaseNoPool(obj);            return nil;        }        else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) {//如果对象为空,并非debug环境,创建一个空的autore占位            // We are pushing a pool with no pool in place,            // and alloc-per-pool debugging was not requested.            // Install and return the empty pool placeholder.            return setEmptyPoolPlaceholder();        }        // We are pushing an object or a non-placeholder&#39;d pool.        // Install the first page.        AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);        setHotPage(page);        // Push a boundary on behalf of the previously-placeholder&#39;d pool.        if (pushExtraBoundary) {            page-&gt;add(POOL_BOUNDARY);        }        // 将released obj添加到page中        // Push the requested object or pool.        return page-&gt;add(obj);    }</code></pre><p>以上三个过程都有执行add()操作,具体看一下add():</p><pre><code>// 向page中添加released操作    id *add(id obj)    {        assert(!full());        unprotect();        // 将next节点赋值给ret        id *ret = next;  // faster than `return next-1` because of aliasing        // next指针增大一个位置        *next++ = obj;        protect();        return ret;    }</code></pre><p>向一个对象发送一条 -autorelease消息,其实就是将这个对象加入到AutoreleasePoolPage中next指针指向的位置,然后next增大一个位置.</p><h3 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop()方法"></a>pop()方法</h3><p>pop操作上面已经提到了是autoreleasepool的析构函数也就是page的销毁函数.</p><pre><code>// pop    static inline void pop(void *token)    {        AutoreleasePoolPage *page;        id *stop;        // 如果当前obj是nil        if (token == (void*)EMPTY_POOL_PLACEHOLDER) {            // Popping the top-level placeholder pool.            if (hotPage()) {                // Pool was used. Pop its contents normally.                // Pool pages remain allocated for re-use as usual.                pop(coldPage()-&gt;begin());            } else {                // Pool was never used. Clear the placeholder.                setHotPage(nil);            }            return;        }        // 根据token获取page        page = pageForPointer(token);        stop = (id *)token;        if (*stop != POOL_BOUNDARY) {            if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) {                // Start of coldest page may correctly not be POOL_BOUNDARY:                // 1. top-level pool is popped, leaving the cold page in place                // 2. an object is autoreleased with no pool            } else {                // Error. For bincompat purposes this is not                // fatal in executables built with old SDKs.                return badPop(token);            }        }        if (PrintPoolHiwat) printHiwat();        // 释放对象 沿着链表向上查找        page-&gt;releaseUntil(stop);        // memory: delete empty children        if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) {            // special case: delete everything during page-per-pool debugging            AutoreleasePoolPage *parent = page-&gt;parent;            page-&gt;kill();            setHotPage(parent);        } else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) {            // special case: delete everything for pop(top)            // when debugging missing autorelease pools            page-&gt;kill();            setHotPage(nil);        }        else if (page-&gt;child) {            // hysteresis: keep one empty child if page is more than half full            if (page-&gt;lessThanHalfFull()) {                page-&gt;child-&gt;kill();            }            else if (page-&gt;child-&gt;child) {                page-&gt;child-&gt;child-&gt;kill();            }        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop()函数有个参数是push()操作的返回值即next指针指向内存地址.然后拿到这个地址遍历链表遍历当前page,然后向page中的obj发送release消息,直到next指向nil:</p><pre><code>// MARK: - 释放obj    void releaseUntil(id *stop)    {        // Not recursive: we don&#39;t want to blow out the stack        // if a thread accumulates a stupendous amount of garbage        // 遍历链表        while (this-&gt;next != stop) {            // Restart from hotPage() every time, in case -release            // autoreleased more objects            AutoreleasePoolPage *page = hotPage();            // fixme I think this `while` can be `if`, but I can&#39;t prove it            // 获取page的父指针            while (page-&gt;empty()) {                page = page-&gt;parent;                setHotPage(page);            }            page-&gt;unprotect();            // 根据next指针缩小一个位置获取obj            id obj = *--page-&gt;next;            memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));            page-&gt;protect();            if (obj != POOL_BOUNDARY) {                // 发送release 消息                objc_release(obj);            }        }        setHotPage(this);#if DEBUG        // we expect any children to be completely empty        for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) {            assert(page-&gt;empty());        }#endif    }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoreleasePoolPage是双链表的一个节点,其内部有可以理解为一个存储released obj地址的堆栈容器,每一个新加入的released obj被添加到这个容器里面,然后有一个next指针指向最后被加入的obj地址的下一个位置.如果当前page SIZE 满了,创建一个新的page. pop()操作就是获取到page中的每一个obj,给他们发送release()消息.</p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.cn/" target="_blank" rel="noopener">https://waitwalker.cn/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block解读/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《Objective-C高级编程：iOS与OS X多线程和内存管理》(Pro multithreading and memory management for iOS and OS X)–译者: 黎 华</p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retain&amp;Release解读</title>
      <link href="/2019/04/22/Retain-Release%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/22/Retain-Release%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS通过引用计数(Reference Counting)机制来管理内存,当一个对象被创建出来时,它的引用计数从0增加到1,当有外部对象对它进行强引用时,也就是当有额外的指针指向它时,它的引用计数会+1,当该对象收到一条release消息时,它的引用计数会-1;当对象的引用计数为0时,对象将被释放,对象指向的内存被回收.</p><h3 id="Retain"><a href="#Retain" class="headerlink" title="Retain"></a>Retain</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用计数的增加和减少的原理是什么样的呢?下面我们从源码中来分析一下.以Person *p1 = [[Person alloc]init]为例;</p><p>在之前文章中我们总结了一个<a href="[https://waitwalker.cn/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/](https://waitwalker.cn/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">对象的初始化过程可以总结为分配内存空间并且初始化isa_t结构的过程</a>),我们再把源码贴出来一下(objc_object.h文件中):</p><pre><code>inline voidobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor){assert(!isTaggedPointer());// 不是tagged pointerif (!nonpointer) {isa.cls = cls;} else {assert(!DisableNonpointerIsa);assert(!cls-&gt;instancesRequireRawIsa());isa_t newisa(0);#if SUPPORT_INDEXED_ISAassert(cls-&gt;classArrayIndex() &gt; 0);newisa.bits = ISA_INDEX_MAGIC_VALUE;// isa.magic is part of ISA_MAGIC_VALUE// isa.nonpointer is part of ISA_MAGIC_VALUEnewisa.has_cxx_dtor = hasCxxDtor;newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#elsenewisa.bits = ISA_MAGIC_VALUE;// isa.magic is part of ISA_MAGIC_VALUE// isa.nonpointer is part of ISA_MAGIC_VALUEnewisa.has_cxx_dtor = hasCxxDtor;newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif// This write must be performed in a single store in some cases// (for example when realizing a class because other threads// may simultaneously try to use the class).// fixme use atomics here to guarantee single-store and to// guarantee memory order w.r.t. the class index table// ...but not too atomic because we don&#39;t want to hurt instantiationisa = newisa;}}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到初始化isa的过程中,并没对保存引用计数的成员变量extra_rc进行操作,我们可以得出一个初步结论,对象在第一次创建的时候,其extra_rc=0;我们知道对象的所有权修饰符默认是strong.其源对象的引用计数的增加也在于有strong指针指向时,即我们示例中的p1强指针,指向了[[Person alloc]init],使[[Person alloc]init]的引用计数从0增加到了1,*p1对象的引用计数此时也就是1了.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前我们查看ivar相关接口的时候已经对objc_storeStrong有了初步了解,我们来看看objc_storeStrong的调用栈:</p><pre><code>// strongvoidobjc_storeStrong(id *location, id obj){id prev = *location;if (obj == prev) {return;}objc_retain(obj);*location = obj;objc_release(prev);}</code></pre><p>看到objc_storeStrong()入口函数内是先调用了objc_retain()新值,然后objc_release()了旧值.</p><p>retain调用:</p><pre><code>// retain__attribute__((aligned(16)))idobjc_retain(id obj){if (!obj) return obj;if (obj-&gt;isTaggedPointer()) return obj;return obj-&gt;retain();}inline idobjc_object::retain(){assert(!isTaggedPointer());if (fastpath(!ISA()-&gt;hasCustomRR())) {return rootRetain();}return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);}ALWAYS_INLINE idobjc_object::rootRetain(){return rootRetain(false, false);}</code></pre><p>最终调用的是ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow){}函数</p><pre><code>// MARK: - rootRetianALWAYS_INLINE idobjc_object::rootRetain(bool tryRetain, bool handleOverflow){if (isTaggedPointer()) return (id)this;bool sideTableLocked = false;bool transcribeToSideTable = false;isa_t oldisa;isa_t newisa;do {transcribeToSideTable = false;// 首先通过LoadExclusive()加载旧的oldisaoldisa = LoadExclusive(&amp;isa.bits);newisa = oldisa;if (slowpath(!newisa.nonpointer)) {ClearExclusive(&amp;isa.bits);if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;else return sidetable_retain();}// don&#39;t check newisa.fast_rr; we already called any RR overridesif (slowpath(tryRetain &amp;&amp; newisa.deallocating)) {ClearExclusive(&amp;isa.bits);if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();return nil;}uintptr_t carry;// 引用计数加1newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++// 判断extra_rc位数能否保存引用计数if (slowpath(carry)) {// extra_rc溢出;handleOverflow=false// newisa.extra_rc++ overflowedif (!handleOverflow) {ClearExclusive(&amp;isa.bits);return rootRetain_overflow(tryRetain);}// 有溢出 将extra_rc置为最大值的一半// Leave half of the retain counts inline and// prepare to copy the other half to the side table.if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();sideTableLocked = true;transcribeToSideTable = true;newisa.extra_rc = RC_HALF;newisa.has_sidetable_rc = true;}} while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));//存储// 有溢出 将另一半的引用计数拷贝到side table里面if (slowpath(transcribeToSideTable)) {// Copy the other half of the retain counts to the side table.sidetable_addExtraRC_nolock(RC_HALF);}if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();// 返回自身return (id)this;}</code></pre><p>其逻辑过程:</p><p>1.1)首先调用LoadExclusive()函数获取旧isa,然后赋值给新的isa实例:newisa;</p><p>1.2)调用addc()函数,将extra_rc++;</p><p>1.3)调用StoreExclusive()更新isa的引用计数,最后返回更新后的isa;这个过程没有处理溢出情况</p><p>2.1)如果if (slowpath(carry)) {}为真,判断handleOverflow是否为false,为false,调用rootRetain_overflow()处理溢出逻辑</p><pre><code>NEVER_INLINE idobjc_object::rootRetain_overflow(bool tryRetain){return rootRetain(tryRetain, true);}</code></pre><p>rootRetain_overflow()内部调用的还是ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)()函数,只是第二个参数handleOverflow传的是true.所以走到:</p><pre><code>// 有溢出 将extra_rc置为最大值的一半// Leave half of the retain counts inline and// prepare to copy the other half to the side table.if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();sideTableLocked = true;transcribeToSideTable = true;newisa.extra_rc = RC_HALF;newisa.has_sidetable_rc = true;</code></pre><p>2.2)将extra_rc值置为最大值的一半,更新has_sidetable_rc标记为true,即sideTable中存储了引用计数.</p><p>2.3)调用StoreExclusive()更新isa的引用计数</p><p>2.4)将将另一半的引用计数拷贝到side table里面</p><pre><code>// 有溢出 将另一半的引用计数拷贝到side table里面if (slowpath(transcribeToSideTable)) {// Copy the other half of the retain counts to the side table.sidetable_addExtraRC_nolock(RC_HALF);}// MARK: - 将一些引用计数保存在side table中// Move some retain counts to the side table from the isa field.// Returns true if the object is now pinned.boolobjc_object::sidetable_addExtraRC_nolock(size_t delta_rc){assert(isa.nonpointer);SideTable&amp; table = SideTables()[this];size_t&amp; refcntStorage = table.refcnts[this];size_t oldRefcnt = refcntStorage;// isa-side bits should not be set hereassert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == 0);assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == 0);if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true;uintptr_t carry;size_t newRefcnt =addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);if (carry) {refcntStorage =SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);return true;}else {refcntStorage = newRefcnt;return false;}}</code></pre><p>之前我们提到过sideTable:</p><pre><code>// MARK: - sideTabelstruct SideTable {spinlock_t slock;RefcountMap refcnts;将另一半的引用计数拷贝到side table里面weak_table_t weak_table;SideTable() {memset(&amp;weak_table, 0, sizeof(weak_table));}~SideTable() {_objc_fatal(&quot;Do not delete SideTable.&quot;);}void lock() { slock.lock(); }void unlock() { slock.unlock(); }void forceReset() { slock.forceReset(); }// Address-ordered lock discipline for a pair of side tables.template&lt;HaveOld, HaveNew&gt;static void lockTwo(SideTable *lock1, SideTable *lock2);template&lt;HaveOld, HaveNew&gt;static void unlockTwo(SideTable *lock1, SideTable *lock2);};</code></pre><p>sideTable有三个成员变量:spinlock_t(自旋锁),RefcountMap(保存引用计数hash表),weak_table_t(保存weak指针hash表);</p><p>2.5)返回对象自身</p><p>以上就是retain的源码实现逻辑,思路还是很清晰.其中alloc/new/copy/mutableCopy会增加引用计数.</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>release可以理解为retain的”逆向操作”,其入口函数:</p><pre><code>// MARK: - release__attribute__((aligned(16)))voidobjc_release(id obj){if (!obj) return;if (obj-&gt;isTaggedPointer()) return;return obj-&gt;release();}// Equivalent to calling [this release], with shortcuts if there is no overrideinline voidobjc_object::release(){assert(!isTaggedPointer());if (fastpath(!ISA()-&gt;hasCustomRR())) {rootRelease();return;}((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_release);}</code></pre><p>可以看到release函数最终调用的是ALWAYS_INLINE bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow){};并且默认是没有引用计数溢出的情况.</p><pre><code>ALWAYS_INLINE boolobjc_object::rootRelease(bool performDealloc, bool handleUnderflow){if (isTaggedPointer()) return false;bool sideTableLocked = false;isa_t oldisa;isa_t newisa;retry:do {// 首先加载旧的isaoldisa = LoadExclusive(&amp;isa.bits);// 将旧的isa赋值给newisanewisa = oldisa;if (slowpath(!newisa.nonpointer)) {ClearExclusive(&amp;isa.bits);if (sideTableLocked) sidetable_unlock();return sidetable_release(performDealloc);}// don&#39;t check newisa.fast_rr; we already called any RR overridesuintptr_t carry;// 将extra_rc减1newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc--// 如果有越界的情况 即extra_rc &lt; 0,走underflowif (slowpath(carry)) {// don&#39;t ClearExclusive()goto underflow;}} while (slowpath(!StoreReleaseExclusive(&amp;isa.bits,oldisa.bits, newisa.bits)));//更新isa的extra_rcif (slowpath(sideTableLocked)) sidetable_unlock();return false;underflow:// newisa.extra_rc-- underflowed: borrow from side table or deallocate// abandon newisa to undo the decrementnewisa = oldisa;// 先判断isa的has_sidetable_rc是否为trueif (slowpath(newisa.has_sidetable_rc)) {if (!handleUnderflow) {ClearExclusive(&amp;isa.bits);// 调用rootRelease_underflow,处理越界情况return rootRelease_underflow(performDealloc);}// Transfer retain count from side table to inline storage.if (!sideTableLocked) {ClearExclusive(&amp;isa.bits);sidetable_lock();sideTableLocked = true;// Need to start over to avoid a race against// the nonpointer -&gt; raw pointer transition.goto retry;}// 从side table中获取引用计数// Try to remove some retain counts from the side table.size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);// To avoid races, has_sidetable_rc must remain set// even if the side table count is now zero.if (borrowed &gt; 0) {// 如果borrowed(side table)的值大于1,将extra_rc中的引用计数赋值给extra_rc// Side table retain count decreased.// Try to add them to the inline count.newisa.extra_rc = borrowed - 1; // redo the original decrement toobool stored = StoreReleaseExclusive(&amp;isa.bits,oldisa.bits, newisa.bits);if (!stored) {// Inline update failed.// Try it again right now. This prevents livelock on LL/SC// architectures where the side table access itself may have// dropped the reservation.isa_t oldisa2 = LoadExclusive(&amp;isa.bits);isa_t newisa2 = oldisa2;if (newisa2.nonpointer) {uintptr_t overflow;newisa2.bits =addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);if (!overflow) {stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits,newisa2.bits);}}}if (!stored) {// Inline update failed.// Put the retains back in the side table.sidetable_addExtraRC_nolock(borrowed);goto retry;}// Decrement successful after borrowing from side table.// This decrement cannot be the deallocating decrement - the side// table lock and has_sidetable_rc bit ensure that if everyone// else tried to -release while we worked, the last one would block.sidetable_unlock();return false;}else {// 如果side table中值为空,则执行dealloc// Side table is empty after all. Fall-through to the dealloc path.}}// Really deallocate.if (slowpath(newisa.deallocating)) {ClearExclusive(&amp;isa.bits);if (sideTableLocked) sidetable_unlock();return overrelease_error();// does not actually return}newisa.deallocating = true;if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;if (slowpath(sideTableLocked)) sidetable_unlock();__sync_synchronize();if (performDealloc) {((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);}return true;}</code></pre><p>逻辑过程:</p><p>1.1)调用LoadExclusive()函数,获取旧的isa,赋值给新的newisa</p><p>1.2)调用subc()函数,将extra_rc减1,如果carry有越界情况,走到2.1)</p><p>1.3)调用StoreReleaseExclusive()函数,更新返回isa</p><p>2.1)carry有越界,说明side table保存了引用计数,并且has_sidetable_rc=true</p><p>2.2)调用rootRelease_underflow()函数,传入参数handleUnderflow=true</p><p>2.3)调用sidetable_subExtraRC_nolock()获取引用计数,side table的引用计数大于0,将side table中的引用计数减1后赋值给extra_rc;否则走3.1)</p><p>2.4)调用StoreReleaseExclusive()函数,更新返回isa</p><p>3.1)side table中的引用计数为0,则调用dealloc方法</p><pre><code>// Really deallocate.if (slowpath(newisa.deallocating)) {ClearExclusive(&amp;isa.bits);if (sideTableLocked) sidetable_unlock();return overrelease_error();// does not actually return}newisa.deallocating = true;if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;if (slowpath(sideTableLocked)) sidetable_unlock();__sync_synchronize();if (performDealloc) {((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release总结下来就是,先将extra_rc减1,如果extra_rc=0,查看side table中是否有引用计数,有则将side table中值减1后赋值给extra_rc;side table中没有值,说明引用计数为0,调用dealloc函数,整体逻辑思路也是很清晰的.</p><h3 id="RetainCount"><a href="#RetainCount" class="headerlink" title="RetainCount"></a>RetainCount</h3><p>retainCount是获取对象的引用计数.</p><pre><code>// MARK: - 获取对象的引用计数inline uintptr_tobjc_object::rootRetainCount(){if (isTaggedPointer()) return (uintptr_t)this;sidetable_lock();isa_t bits = LoadExclusive(&amp;isa.bits);ClearExclusive(&amp;isa.bits);if (bits.nonpointer) {// 引用计数 = 1 + extra_rcuintptr_t rc = 1 + bits.extra_rc;// 如果side table中有值if (bits.has_sidetable_rc) {// 再加上side table中的引用计数rc += sidetable_getExtraRC_nolock();}sidetable_unlock();return rc;}sidetable_unlock();return sidetable_retainCount();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先LoadExclusive()获取isa,将extra_rc加1赋值给rc,然后判断has_sidetable_rc,side table中是否有引用计数,有的话,再加上side table中的引用计数,然后返回.</p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block解读/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block解读</title>
      <link href="/2019/04/18/Block%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/18/Block%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="Block定义"><a href="#Block定义" class="headerlink" title="Block定义"></a>Block定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看过&lt;&lt;Objective-C高级编程iOS与OS X多线程和内存管理&gt;&gt;这本书的朋友应该知道其对block的定义:Blocks是C语言的扩充功能,带有自动变量(局部变量)的匿名函数.匿名函数就是不带有名称的函数.Block在不同的语言中有不同的命名.Python中叫Lambda,Swift中叫Closure(闭包)等.</p><p>我们知道根据作用域的不同变量大概有:自动变量(局部变量),静态变量(静态局部变量),静态全局变量,全局变量.而静态变量(局部和全局),全局变量其生命周期一般与程序同步,在程序的整个生命周期内,其也会保持在同一内存区域.</p><h3 id="block的声明结构"><a href="#block的声明结构" class="headerlink" title="block的声明结构"></a>block的声明结构</h3><pre><code>// MARK: - blcok声明结构struct Block_layout {void *isa;volatile int32_t flags; // contains ref countint32_t reserved;void (*invoke)(void *, ...);struct Block_descriptor_1 *descriptor;// imported variables};// MARK: - block 附件信息1#define BLOCK_DESCRIPTOR_1 1struct Block_descriptor_1 {uintptr_t reserved;uintptr_t size;};// MARK: - block 附件信息2#define BLOCK_DESCRIPTOR_2 1struct Block_descriptor_2 {// requires BLOCK_HAS_COPY_DISPOSEvoid (*copy)(void *dst, const void *src);void (*dispose)(const void *);};// MARK: - block 附件信息3#define BLOCK_DESCRIPTOR_3 1struct Block_descriptor_3 {// requires BLOCK_HAS_SIGNATUREconst char *signature;const char *layout; // contents depend on BLOCK_HAS_EXTENDED_LAYOUT};struct Block_byref {void *isa;struct Block_byref *forwarding;volatile int32_t flags; // contains ref countuint32_t size;};struct Block_byref_2 {// requires BLOCK_BYREF_HAS_COPY_DISPOSEvoid (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);void (*byref_destroy)(struct Block_byref *);};struct Block_byref_3 {// requires BLOCK_BYREF_LAYOUT_EXTENDEDconst char *layout;};</code></pre><p>只在block_private.h中只找到block相关的声明结构,具体实现没有找到.其实现源码<a href="[http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/](http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/">这里</a>).下面我们看一下block_layout声明结构中的一些成员变量:</p><p>isa:block类型指针</p><p>flags:标志位,用于按bit操作</p><p>reserved:保留变量</p><p>invoke:指向block实现函数的指针</p><p>descriptor:附件信息</p><p>这些具体的结构我们可以通过clang编译器重写Objective-C文件转成.cpp文件查看源码.</p><h3 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h3><p>返回值类型 (^block名称)(形参参数列表) = ^返回值类型(参数列表){</p><p>return 返回值</p><p>}</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-5e36c4a5ffaa68f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Block语法.jpg"></p><h3 id="Block截获自动变量"><a href="#Block截获自动变量" class="headerlink" title="Block截获自动变量"></a>Block截获自动变量</h3><p>带有自动变量的值在block中表现为截获自动变量值.</p><pre><code>int valueOne = 18;int valueTwo = 1;// MARK: - 截获自动变量void(^BlockOne)(void) = ^void(){NSLog(@&quot;valueOne:%d; valueTwo:%d&quot;,valueOne,valueTwo);};// 修改自动变量的值valueOne = 9;// 调用blockBlockOne();</code></pre><p>调用block后我们看到log输出:</p><pre><code>2019-04-17 15:30:28.442314+0800 Block_Layout[6530:443419] valueOne:18; valueTwo:1</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block内部捕获了valueOne和valueTwo两个自动变量,其中valueOne在block调用前进行了修改,而在block在真实调用时,valueOne值并没有跟随修改,因为block表达式截获得是自动变量的瞬间值,保存后就不能改写.所以在调用block时,即使改了block截获的自动变量的值,也不会影响block表达式内截获的值.</p><p>通过clang编译器重写一些文件,获取底层实现源码:</p><pre><code>// block 声明结构struct __block_impl {void *isa;int Flags;int Reserved;void *FuncPtr;};// block声明&amp;实现结构void(*BlockOne)(void) = ((void (*)())&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, valueOne, valueTwo));valueOne = 9;// block调用((void (*)(__block_impl *))((__block_impl *)BlockOne)-&gt;FuncPtr)((__block_impl *)BlockOne);// MARK: - block具体实现结构struct __ViewController__viewDidLoad_block_impl_0 {struct __block_impl impl;struct __ViewController__viewDidLoad_block_desc_0* Desc;int valueOne;int valueTwo;// 同名的构造函数__ViewController__viewDidLoad_block_impl_0(void *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, int _valueOne, int _valueTwo, int flags=0) : valueOne(_valueOne), valueTwo(_valueTwo) {impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;}};// MARK: - block实现结构对应的实现函数static void __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself) {int valueOne = __cself-&gt;valueOne; // bound by copyint valueTwo = __cself-&gt;valueTwo; // bound by copyNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_pg_0qh5fq653wq1l3qz9_3ftg3r0000gn_T_ViewController_75dfcb_mi_0,valueOne,valueTwo);}// MARK: - desc结构static struct __ViewController__viewDidLoad_block_desc_0 {size_t reserved;size_t Block_size;} __ViewController__viewDidLoad_block_desc_0_DATA = { 0, sizeof(struct __ViewController__viewDidLoad_block_impl_0)};</code></pre><p>具体看一下这几个结构:</p><p><strong>__block_impl:block对外暴露的声明结构,内部有四个成员变量.</strong></p><p><strong>_block_impl_0:block内部实现结构,其内部有一个同名的构造函数.</strong></p><p><strong>_block_func_0:block实现结构对应的实现函数,我们对block捕获的一些值都在这里操作,其参数为__cself指向的是Block自身.</strong></p><p><strong>_block_desc_0:desc结构,描述_block_impl_0的size等.</strong></p><p><strong>ViewController</strong>viewDidLoad_block_impl_0()构造函数,将fp函数指针赋值给impl的FuncPtr,将desc赋值给 Desc ,将flags赋值给impl的flags,将Block类型赋值给isa,之前我们已经讲过<a href="[https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/](https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">isa</a>),可以具体查看,到此我们可以确定block的本质其实就是Objective-C对象,这些赋值后完成对impl进行初始化.</p><p><strong>blockOne就是一个_block_impl_0的实例.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以以方法类比:__block_impl是对外的接口,其内部实现是_block_impl_0来实现的.我们可以看到block实现表达式中捕获的直接是valueOne,valueTwo的值.</p><p>如果我们尝试在block内部修改其捕获的自动变量的值,或马上报错:</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-19d3e872cf58524f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="missing__block_error.png"></p><p>告诉我们缺少__block修饰符,下面我们在看一个情况:</p><pre><code>NSMutableArray *array = [[NSMutableArray array]init];// MARK: - 截获自动变量void(^BlockOne)(void) = ^void(){[array addObject:[NSObject new]];};</code></pre><p>这种情况可以正常编译过去,再看一下:</p><p><img src="https://upload-images.jianshu.io/upload_images/1715253-8d9c0ade6fd90dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="missing__block.png"></p><p>同样的错误.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们用<strong>block修饰符修饰一下自动变量,编译正常通过.因此,如果我们需要修改block捕获的自动变量,需要在自动变量前面添加</strong>block修饰符.</p><h3 id="Block捕获静态-全局变量"><a href="#Block捕获静态-全局变量" class="headerlink" title="Block捕获静态/全局变量"></a>Block捕获静态/全局变量</h3><pre><code>// 静态全局变量static int valueTwo = 20;// 全局变量int valueThree = 30;@interface ViewController ()@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *valueString;@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];// 静态局部变量static int valueOne = 10;// MARK: - 截获静态变量,全局变量void(^BlockOne)(void) = ^void(){valueOne = 1;valueTwo = 2;valueThree = 3;NSLog(@&quot;valueOne:%d,valueTwo:%d,valueThree:%d&quot;,valueOne,valueTwo,valueThree);};// 修改自动变量的值valueOne = 9;// 调用blockBlockOne();}@end</code></pre><p>日志输出:</p><pre><code>2019-04-17 16:56:57.112848+0800 MTTRuntime[7888:540053] valueOne:1,valueTwo:2,valueThree:3</code></pre><p>然后我们继续用clang编译转换一下:</p><pre><code>// block 声明和实现结构void(*BlockOne)(void) = ((void (*)())&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, &amp;valueOne));valueOne = 9;// block调用((void (*)(__block_impl *))((__block_impl *)BlockOne)-&gt;FuncPtr)((__block_impl *)BlockOne);struct __ViewController__viewDidLoad_block_impl_0 {struct __block_impl impl;struct __ViewController__viewDidLoad_block_desc_0* Desc;int *valueOne;__ViewController__viewDidLoad_block_impl_0(void *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, int *_valueOne, int flags=0) : valueOne(_valueOne) {impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;}};static void __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself) {int *valueOne = __cself-&gt;valueOne; // bound by copy// 静态局部变量(*valueOne) = 1;// 静态全局变量valueTwo = 2;// 全局变量valueThree = 3;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_pg_0qh5fq653wq1l3qz9_3ftg3r0000gn_T_ViewController_9483ca_mi_0,(*valueOne),valueTwo,valueThree);}static struct __ViewController__viewDidLoad_block_desc_0 {size_t reserved;size_t Block_size;} __ViewController__viewDidLoad_block_desc_0_DATA = { 0, sizeof(struct __ViewController__viewDidLoad_block_impl_0)};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到静态全局变量和全局变量,被block捕获后直接修改的是其值,因为全局变量作用域于全局,在block内部进行修改后其值可以被保存下来.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而静态局部变量访问的是使用指针对其进行访问,在block实现表达式里面传进去的也是&amp;valueOne地址.</p><p>block在捕获全局变量/静态变量时,可以在block实现表达式内部对其进行更改.block捕获静态局部变量的地址并保存,通过操作指针实现值的修改.</p><h3 id="Block捕获-block修饰的自动变量"><a href="#Block捕获-block修饰的自动变量" class="headerlink" title="Block捕获__block修饰的自动变量"></a>Block捕获__block修饰的自动变量</h3><pre><code>- (void)viewDidLoad {[super viewDidLoad];// __block修饰的自动变量__block int valueOne = 10;// MARK: - 截获__block修饰的自动变量void(^BlockOne)(void) = ^void(){valueOne = 1;NSLog(@&quot;valueOne:%d&quot;,valueOne);};// 修改自动变量的值valueOne = 9;// 调用blockBlockOne();}</code></pre><p>控制台输出:</p><pre><code>2019-04-18 08:54:48.274042+0800 MTTRuntime[4012:43868] valueOne:1,valueTwo:20,valueThree:30</code></pre><p>被__block修饰的自动变量,block捕获后能够对其进行更改.clang重写一下,查看源码:</p><pre><code>// __block修饰的成员变量转换__attribute__((__blocks__(byref))) __Block_byref_valueOne_0 valueOne = {(void*)0,(__Block_byref_valueOne_0 *)&amp;valueOne, 0, sizeof(__Block_byref_valueOne_0), 10};// block的声明和实现表达式void(*BlockOne)(void) = ((void (*)())&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, (__Block_byref_valueOne_0 *)&amp;valueOne, 570425344));// 修改valueOne的值(valueOne.__forwarding-&gt;valueOne) = 9;//block调用((void (*)(__block_impl *))((__block_impl *)BlockOne)-&gt;FuncPtr)((__block_impl *)BlockOne);// byref结构struct __Block_byref_valueOne_0 {void *__isa;__Block_byref_valueOne_0 *__forwarding;//指向自己的指针int __flags;int __size;int valueOne;};//block匿名实现结构struct __ViewController__viewDidLoad_block_impl_0 {struct __block_impl impl;struct __ViewController__viewDidLoad_block_desc_0* Desc;__Block_byref_valueOne_0 *valueOne; // by ref__ViewController__viewDidLoad_block_impl_0(void *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, __Block_byref_valueOne_0 *_valueOne, int flags=0) : valueOne(_valueOne-&gt;__forwarding) {impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;}};// block实现函数static void __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself) {__Block_byref_valueOne_0 *valueOne = __cself-&gt;valueOne; // bound by ref(valueOne-&gt;__forwarding-&gt;valueOne) = 1;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_pg_0qh5fq653wq1l3qz9_3ftg3r0000gn_T_ViewController_ea5a30_mi_0,(valueOne-&gt;__forwarding-&gt;valueOne));}// block copystatic void __ViewController__viewDidLoad_block_copy_0(struct __ViewController__viewDidLoad_block_impl_0*dst, struct __ViewController__viewDidLoad_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;valueOne, (void*)src-&gt;valueOne, 8/*BLOCK_FIELD_IS_BYREF*/);}// block disposestatic void __ViewController__viewDidLoad_block_dispose_0(struct __ViewController__viewDidLoad_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;valueOne, 8/*BLOCK_FIELD_IS_BYREF*/);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到,这里多了<strong>Block_byref_valueOne_0结构,我们初始化的自动变量也被转换成了这个结构的实例,自动变量初始化值为10,这个值也出现在</strong>Block_byref_valueOne_0结构的初始化中,并且这个结构持有这个变量,使其成为成员变量.</p><pre><code>// byref结构struct __Block_byref_valueOne_0 {void *__isa;__Block_byref_valueOne_0 *__forwarding;//指向自己的指针int __flags;int __size;int valueOne;};</code></pre><p>我们再来看一下怎么访问这个自动变量的:</p><pre><code>// block实现函数static void __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself) {__Block_byref_valueOne_0 *valueOne = __cself-&gt;valueOne; // bound by ref(valueOne-&gt;__forwarding-&gt;valueOne) = 1;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_pg_0qh5fq653wq1l3qz9_3ftg3r0000gn_T_ViewController_ea5a30_mi_0,(valueOne-&gt;__forwarding-&gt;valueOne));}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是通过((<strong>Block_byref_valueOne_0 *)valueOne-&gt;</strong>forwarding-&gt;valueOne).Block的_block_impl_0结构实例指针持有指向<strong>Block_byref_valueOne_0的指针;而</strong>Block_byref_valueOne_0的成员变量持有指向自身的指针.然后通过<strong>forwarding来访问valueOne.</strong>Block_byref_valueOne_0结构并不在_block_impl_0中,这样做主要是在多个Block中使用__block.</p><h3 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h3><p>_NSConcreteGlobalBlock:定义在全局区,存储于程序数据区</p><p>_NSConcreteStackBlock:存储于栈区,超出作用域被回收</p><p>_NSConcreteMallocBlock:存储于堆区,从栈copy过来</p><h4 id="Block复制到堆上的情况"><a href="#Block复制到堆上的情况" class="headerlink" title="Block复制到堆上的情况:"></a>Block复制到堆上的情况:</h4><p>1)block调用了copy方法;<br></p><p>2)block作为方法返回值;<br></p><p>3)将block赋值给__strong修饰的id类型或赋值给类的block成员变量;<br></p><p>4)方法名中有usingBlock的cocoa框架或者GCD相关api;<br></p><h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果Block中使用附有<strong>strong修饰符的对象类型自动变量,那么Block从栈复制到堆上时,该对象为Block所持有,这样会引起循环引用问题,可以通过</strong>weak修饰符来打破循环引用,这个我们在后面细讲__weak实现原理.</p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="https://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2019/04/16/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/04/16/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树(Binary Tree)是一棵树,其中每个节点都不能有多余两个的儿子.深度为k的二叉树的节点个数,最多为2^k - 1个节点.ni节点深度指的是从根r到ni的一条有效路径的长.深度为k的二叉树的深度指的是从根r到叶子节点一条最长路径的长.这条路径上最多节点个数也就是深度为k的二叉树的节点个数.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树每个节点最多有两个儿子,我们可以用指针直接指向他们,左边的儿子称为左子树,右边的儿子称为右子树.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树的声明有点类似于链表,一个节点有关键字信息加上两个指向其他节点的指针(Left和Right)组成的结构.因此,对于链表的一些操作逻辑也能应用于二叉树上,比如插入操作,需要先创建一个插入的节点,然后插入.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与普通树不同,普通树的节点个数至少为1,二叉树的节点个数可以为0;普通树节点的最大分支度没有限制,而二叉树节点的最大分支度为2;普通树的节点无左右次序之分,而二叉树节点有左右次序之分.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一颗深度为k,具有2^(k + 1) - 1个节点的二叉树称为满二叉树,也称为完全二叉树(Complete Binary Tree).具有n个节点的完全二叉树的深度为log2n + 1.</p><h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树可以用数组或链表来存储,如果二叉树是完全二叉树则能紧密排列起来而不造成空间浪费.如果某个节点的索引为i,则它的左子树节点索引为2i+1,右子树节点索引为2i+2.而它的父亲节点索引为|(i - 1) / 2|.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用数组来存储二叉树节点有利于紧密存储和更好的访问的局部性,然而如果一颗二叉树每个节点只有左二子或者只有右儿子将造成很大的空间浪费.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树使用二叉链表来存储一定程度上能避免空间连续存储造成的浪费,但是由于缺乏父指针,在查找父亲节点的时候需要重新扫描树.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此,二叉树通常用树节点结构来存储.</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历:"></a><strong>深度优先遍历:</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树的深度遍历方法分为先序遍历,中序遍历,后序遍历,L,D,R分别表示左子树,根节点(父亲节点),右子树.</p><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历:"></a>先序遍历:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问节点的顺序是DLR,先根,然后左子树,然后右子树.访问根节点,然后左子树,接着访问左子树,直到最左子树,然后访问左子树对应的右子树,然后递归实现以上步骤.</p><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历:"></a>中序遍历:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问节点的顺序是LDR,先左子树,然后根,然后右子树.先最左子树,然后根节点(父亲节点),然后最左子树对应右子树的最左子树,然后根节点,右子树.</p><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历:"></a>后序遍历:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问节点的顺序是LRD,先左子树,然后右子树,然后根.先最左子树,然后右子树的最左子树,右子树,根.</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历:"></a><strong>广度优先遍历:</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广度优先遍历会先访问离根节点最近的节点,二叉树的广度优先遍历又称为按层次遍历,这个算法实现要借助于队列来实现.</p><h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><h4 id="二叉树的定义实现"><a href="#二叉树的定义实现" class="headerlink" title="二叉树的定义实现"></a>二叉树的定义实现</h4><pre><code>// MARK: - 二叉树的定义class BinaryTree&lt;T&gt; {// 节点valuevar value:T// 左子树var leftChildNode:BinaryTree?// 右子树var rightChildNode:BinaryTree?// MARK: - 构造方法init(value:T) {self.value = value}}</code></pre><h4 id="先序遍历递归实现"><a href="#先序遍历递归实现" class="headerlink" title="先序遍历递归实现"></a>先序遍历递归实现</h4><pre><code>/// 先序遍历:先根节点,然后左子树,然后右子树////// - Parameter binaryTree: 二叉树节点/// - Returns: 二叉树节点总数func traversePreOrder(binaryTree:BinaryTree?) -&gt; Int {guard let binaryTreeNode = binaryTree else {return 0}print(&quot;当前节点值:&quot;,binaryTreeNode.value,separator: &quot;&quot;,terminator: &quot; \n&quot;)let leftNodeCount = binaryTreeNode.traversePreOrder(binaryTree: binaryTreeNode.leftChildNode)let rigthNodeCount = binaryTreeNode.traversePreOrder(binaryTree: binaryTreeNode.rightChildNode)return leftNodeCount + rigthNodeCount + 1}</code></pre><h4 id="中序遍历递归实现"><a href="#中序遍历递归实现" class="headerlink" title="中序遍历递归实现"></a>中序遍历递归实现</h4><pre><code>/// 中序遍历 先左子树,然后根,然后右子树////// - Parameter binaryTree: 二叉树节点func traverseInOrder(binaryTree:BinaryTree?) -&gt; Int {guard let binaryTreeNode = binaryTree else { return 0}let leftNodeCount = binaryTreeNode.traverseInOrder(binaryTree: binaryTreeNode.leftChildNode)print(&quot;当前节点值:&quot;,binaryTreeNode.value,separator: &quot;&quot;,terminator: &quot; \n&quot;)let rigthNodeCount = binaryTreeNode.traverseInOrder(binaryTree: binaryTreeNode.rightChildNode)return leftNodeCount + rigthNodeCount + 1}</code></pre><h4 id="后序遍历递归实现"><a href="#后序遍历递归实现" class="headerlink" title="后序遍历递归实现"></a>后序遍历递归实现</h4><pre><code>/// 后序遍历 先左子树,然后右子树,然后根////// - Parameter binaryTree: 二叉树节点func traversePostOrder(binaryTree:BinaryTree?) -&gt; Int {guard let binaryTreeNode = binaryTree else { return 0 }let leftNodeCount = binaryTreeNode.traversePostOrder(binaryTree: binaryTreeNode.leftChildNode)let rigthNodeCount = binaryTreeNode.traversePostOrder(binaryTree: binaryTreeNode.rightChildNode)print(&quot;当前节点值:&quot;,binaryTreeNode.value,separator: &quot;&quot;,terminator: &quot; \n&quot;)return leftNodeCount + rigthNodeCount + 1}</code></pre><h4 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h4><pre><code>/// 二叉树最大深度////// - Parameter binaryTree: 二叉树节点/// - Returns: 最大深度func maxDepth(binaryTree:BinaryTree?) -&gt; Int {guard let binaryTreeNode = binaryTree else { return 0 }let leftMaxDepth = maxDepth(binaryTree: binaryTreeNode.leftChildNode)let rightMaxDepth = maxDepth(binaryTree: binaryTreeNode.rightChildNode)return max(leftMaxDepth, rightMaxDepth) + 1}</code></pre><h4 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h4><pre><code>/// 二叉树最小深度////// - Parameter binaryTree: 二叉树节点/// - Returns: 最小深度func minDepth(binaryTree:BinaryTree?) -&gt; Int {guard let binaryTreeNode = binaryTree else { return 0 }let leftMinDepth = binaryTreeNode.minDepth(binaryTree: binaryTreeNode.leftChildNode)let rightMinDepth = binaryTreeNode.minDepth(binaryTree: binaryTreeNode.rightChildNode)return min(leftMinDepth, rightMinDepth) + 1}</code></pre><h4 id="先序遍历非递归实现"><a href="#先序遍历非递归实现" class="headerlink" title="先序遍历非递归实现"></a>先序遍历非递归实现</h4><pre><code>/***先根,然后左子树,然后右子树 非递归实现:1)用栈来存储当前节点,判断当前节点是否为空,不为空,将当前节点压栈操作.2)判断当前节点的左子树是否为空,左子树不为空则将当前节点的左子树赋值给当前节点;若为空,则取出栈的元素,将栈顶元素的右子树赋值给当前节点,执行1)3)直到当前节点为空并且栈为空,遍历结束**//// 先序遍历////// - Parameter binaryTree: 二叉树节点/// - Returns: 二叉树节点总数func traversePreOrderNonrecursive(binaryTree:BinaryTree?) -&gt; Int {var treeStack:[BinaryTree] = []var currentNode = binaryTreevar count:Int = 0while !treeStack.isEmpty || currentNode != nil{if currentNode != nil {treeStack.append(currentNode!)currentNode = currentNode?.leftChildNodecount += 1print(currentNode?.value as Any)} else {let lastTreeNode = treeStack.removeLast()currentNode = lastTreeNode.rightChildNode}}return count}</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="[https://github.com/waitwalker/DataStructureAlgorithm](https://github.com/waitwalker/DataStructureAlgorithm">GitHub</a>),测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ivar objc_property_t Protocol解读</title>
      <link href="/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="Ivar声明"><a href="#Ivar声明" class="headerlink" title="Ivar声明"></a>Ivar声明</h3><p>在objc-private.h文件中我们可以看到Ivar的声明结构:</p><pre><code>typedef struct ivar_t *Ivar;</code></pre><p>在objc-runtime-new.h中可以找到ivar_t的完整结构声明:</p><pre><code>// MARK: - 成员变量结构声明struct ivar_t {#if __x86_64__    // *offset was originally 64-bit on some x86_64 platforms.    // We read and write only 32 bits of it.    // Some metadata provides all 64 bits. This is harmless for unsigned    // little-endian values.    // Some code uses all 64 bits. class_addIvar() over-allocates the    // offset for their benefit.#endif    int32_t *offset;    const char *name;//成员变量名称    const char *type;//成员变量类型    // alignment is sometimes -1; use alignment() instead    uint32_t alignment_raw;    uint32_t size;    uint32_t alignment() const {        if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT;        return 1 &lt;&lt; alignment_raw;    }};</code></pre><h3 id="Ivar相关接口"><a href="#Ivar相关接口" class="headerlink" title="Ivar相关接口"></a>Ivar相关接口</h3><p>在runtime.h文件:</p><h4 id="修改一个类的成员变量的值"><a href="#修改一个类的成员变量的值" class="headerlink" title="修改一个类的成员变量的值"></a>修改一个类的成员变量的值</h4><pre><code>// MARK: - 修改一个类的成员变量的值/** * Changes the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to modify. * @param name A C string. Pass the name of the instance variable whose value you wish to modify. * @param value The new value for the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and *  name of the instance variable specified by \e name. * * @note Instance variables with known memory management (such as ARC strong and weak) *  use that memory management. Instance variables with unknown memory management *  are assigned as if they were unsafe_unretained. */OBJC_EXPORT Ivar _Nullableobject_setInstanceVariable(id _Nullable obj, const char * _Nonnull name,                           void * _Nullable value)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)    OBJC_ARC_UNAVAILABLE;</code></pre><p>其实现在objc-class.mm文件中,其内部调用了一个私有函数:</p><pre><code>// 修改一个类的成员变量的值Ivar object_setInstanceVariable(id obj, const char *name, void *value){    return _object_setInstanceVariable(obj, name, value, false);}// 修改一个成员变量的值static ALWAYS_INLINEIvar _object_setInstanceVariable(id obj, const char *name, void *value,                                 bool assumeStrong){    Ivar ivar = nil;    if (obj  &amp;&amp;  name  &amp;&amp;  !obj-&gt;isTaggedPointer()) {        // 首先根据成员变量名称从ivar_list中获取ivar        if ((ivar = _class_getVariable(obj-&gt;ISA(), name))) {            // 更新ivar的value            _object_setIvar(obj, ivar, (id)value, assumeStrong);        }    }    return ivar;}</code></pre><p>首先根据成员变量名称从ivar_list中获取ivar:</p><pre><code>// MARK: - 根据成员变量名称获取成员变量/************************************************************************ _class_getVariable* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar_class_getVariable(Class cls, const char *name){    mutex_locker_t lock(runtimeLock);    for ( ; cls; cls = cls-&gt;superclass) {        ivar_t *ivar = getIvar(cls, name);        if (ivar) {            return ivar;        }    }    return nil;}// MARK: - 根据成员变量名称获取成员变量/************************************************************************ getIvar* Look up an ivar by name.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/static ivar_t *getIvar(Class cls, const char *name){    runtimeLock.assertLocked();    const ivar_list_t *ivars;    assert(cls-&gt;isRealized());    if ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)) {        for (auto&amp; ivar : *ivars) {            if (!ivar.offset) continue;  // anonymous bitfield            // ivar.name may be nil for anonymous bitfields etc.            if (ivar.name  &amp;&amp;  0 == strcmp(name, ivar.name)) {                return &amp;ivar;            }        }    }    return nil;}</code></pre><p>获取到成员变量后,更新ivar的value:</p><pre><code>// MARK: - 更新ivar的值static ALWAYS_INLINEvoid _object_setIvar(id obj, Ivar ivar, id value, bool assumeStrong){    if (!obj  ||  !ivar  ||  obj-&gt;isTaggedPointer()) return;    ptrdiff_t offset;    objc_ivar_memory_management_t memoryManagement;    _class_lookUpIvar(obj-&gt;ISA(), ivar, offset, memoryManagement);    if (memoryManagement == objc_ivar_memoryUnknown) {        if (assumeStrong) memoryManagement = objc_ivar_memoryStrong;        else memoryManagement = objc_ivar_memoryUnretained;    }    id *location = (id *)((char *)obj + offset);    switch (memoryManagement) {    case objc_ivar_memoryWeak:       objc_storeWeak(location, value); break;    case objc_ivar_memoryStrong:     objc_storeStrong(location, value); break;    case objc_ivar_memoryUnretained: *location = value; break;    case objc_ivar_memoryUnknown:    _objc_fatal(&quot;impossible&quot;);    }}</code></pre><p>更新值的规则主要根据ivar的内存管理语义:</p><pre><code>/*  &quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars  &quot;Strong&quot; includes ARC __strong ivars  &quot;Weak&quot; includes ARC and new MRC __weak ivars  &quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars*/typedef enum {    objc_ivar_memoryUnknown,     // unknown / unknown    objc_ivar_memoryStrong,      // direct access / objc_storeStrong    objc_ivar_memoryWeak,        // objc_loadWeak[Retained] / objc_storeWeak    objc_ivar_memoryUnretained   // direct access / direct access} objc_ivar_memory_management_t;</code></pre><p>strong修饰的直接调用objc_storeStrong,weak调用objc_storeWeak,unretained修饰的直接赋值.这个在以后内存管理中细说.</p><h4 id="修改一个strong修饰的ivar的值"><a href="#修改一个strong修饰的ivar的值" class="headerlink" title="修改一个strong修饰的ivar的值"></a>修改一个strong修饰的ivar的值</h4><pre><code>// MARK: - 修改一个strong修饰的ivar的值/** * Changes the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to modify. * @param name A C string. Pass the name of the instance variable whose value you wish to modify. * @param value The new value for the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and *  name of the instance variable specified by \e name. * * @note Instance variables with known memory management (such as ARC strong and weak) *  use that memory management. Instance variables with unknown memory management *  are assigned as if they were strong. */OBJC_EXPORT Ivar _Nullableobject_setInstanceVariableWithStrongDefault(id _Nullable obj,                                            const char * _Nonnull name,                                            void * _Nullable value)    OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0)    OBJC_ARC_UNAVAILABLE;</code></pre><p>其过程与上一个类似.</p><h4 id="获取一个类的实例的成员变量-的值"><a href="#获取一个类的实例的成员变量-的值" class="headerlink" title="获取一个类的实例的成员变量(的值)"></a>获取一个类的实例的成员变量(的值)</h4><pre><code>// MARK: - 获取一个类的实例的成员变量(的值)/** * Obtains the value of an instance variable of a class instance. * * @param obj A pointer to an instance of a class. Pass the object containing *  the instance variable whose value you wish to obtain. * @param name A C string. Pass the name of the instance variable whose value you wish to obtain. * @param outValue On return, contains a pointer to the value of the instance variable. * * @return A pointer to the \c Ivar data structure that defines the type and name of *  the instance variable specified by \e name. */OBJC_EXPORT Ivar _Nullableobject_getInstanceVariable(id _Nullable obj, const char * _Nonnull name,                           void * _Nullable * _Nullable outValue)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)    OBJC_ARC_UNAVAILABLE;// 获取实例的成员变量Ivar object_getInstanceVariable(id obj, const char *name, void **value){    if (obj  &amp;&amp;  name  &amp;&amp;  !obj-&gt;isTaggedPointer()) {        Ivar ivar;        if ((ivar = class_getInstanceVariable(obj-&gt;ISA(), name))) {            if (value) *value = (void *)object_getIvar(obj, ivar);            return ivar;        }    }    if (value) *value = nil;    return nil;}</code></pre><h4 id="获取一个类所有成员变量的size"><a href="#获取一个类所有成员变量的size" class="headerlink" title="获取一个类所有成员变量的size"></a>获取一个类所有成员变量的size</h4><pre><code>// MARK: - 获取一个类所有成员变量的size/** * Returns the size of instances of a class. * * @param cls A class object. * * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil. */OBJC_EXPORT size_tclass_getInstanceSize(Class _Nullable cls)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类所有成员变量的sizesize_t class_getInstanceSize(Class cls){    if (!cls) return 0;    return cls-&gt;alignedInstanceSize();}// Class&#39;s ivar size rounded up to a pointer-size boundary.    uint32_t alignedInstanceSize() {        return word_align(unalignedInstanceSize());    } // May be unaligned depending on class&#39;s ivars.    uint32_t unalignedInstanceSize() {        assert(isRealized());        // 返回一个类中所有成员变量的size        return data()-&gt;ro-&gt;instanceSize;    }</code></pre><p>这里也印证了我们之前文章所说的一个类的成员变量在编译后内存布局已经固定了,其获取大小是从data()-&gt;ro-&gt;instanceSize来.</p><h4 id="根据成员变量名称获取某个类中的成员变量-objc-getInstanceVariable中调用的就是此函数"><a href="#根据成员变量名称获取某个类中的成员变量-objc-getInstanceVariable中调用的就是此函数" class="headerlink" title="根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)"></a>根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)</h4><pre><code>// MARK: - 根据成员变量名称获取某个类中的成员变量(objc_getInstanceVariable中调用的就是此函数)/** * Returns the \c Ivar for a specified instance variable of a given class. * * @param cls The class whose instance variable you wish to obtain. * @param name The name of the instance variable definition to obtain. * * @return A pointer to an \c Ivar data structure containing information about *  the instance variable specified by \e name. */OBJC_EXPORT Ivar _Nullableclass_getInstanceVariable(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// MARK: - 根据名称获取一个类中的成员变量/************************************************************************ class_getInstanceVariable.  Return the named instance variable.**********************************************************************/Ivar class_getInstanceVariable(Class cls, const char *name){    if (!cls  ||  !name) return nil;    return _class_getVariable(cls, name);}</code></pre><h4 id="通过名称获取类成员变量"><a href="#通过名称获取类成员变量" class="headerlink" title="通过名称获取类成员变量"></a>通过名称获取类成员变量</h4><pre><code>// MARK: - 通过名称获取类成员变量/** * Returns the Ivar for a specified class variable of a given class. * * @param cls The class definition whose class variable you wish to obtain. * @param name The name of the class variable definition to obtain. * * @return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name. */OBJC_EXPORT Ivar _Nullableclass_getClassVariable(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取类中的类成员变量/************************************************************************ class_getClassVariable.  Return the named class variable.**********************************************************************/Ivar class_getClassVariable(Class cls, const char *name){    if (!cls) return nil;    return class_getInstanceVariable(cls-&gt;ISA(), name);}</code></pre><h4 id="获取一个类的所有成员变量"><a href="#获取一个类的所有成员变量" class="headerlink" title="获取一个类的所有成员变量"></a>获取一个类的所有成员变量</h4><pre><code>// MARK: - 获取一个类的所有成员变量/** * Describes the instance variables declared by a class. * * @param cls The class to inspect. * @param outCount On return, contains the length of the returned array. *  If outCount is NULL, the length is not returned. * * @return An array of pointers of type Ivar describing the instance variables declared by the class. *  Any instance variables declared by superclasses are not included. The array contains *outCount *  pointers followed by a NULL terminator. You must free the array with free(). * *  If the class declares no instance variables, or cls is Nil, NULL is returned and *outCount is 0. */OBJC_EXPORT Ivar _Nonnull * _Nullableclass_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类的所有成员变量/************************************************************************ class_copyIvarList* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar *class_copyIvarList(Class cls, unsigned int *outCount){    const ivar_list_t *ivars;    Ivar *result = nil;    unsigned int count = 0;    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    if ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)  &amp;&amp;  ivars-&gt;count) {        result = (Ivar *)malloc((ivars-&gt;count+1) * sizeof(Ivar));        for (auto&amp; ivar : *ivars) {            if (!ivar.offset) continue;  // anonymous bitfield            result[count++] = &amp;ivar;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return result;}</code></pre><p>其获取主要来自:cls-&gt;data()-&gt;ro-&gt;ivars.</p><h4 id="给一个类添加成员变量-必须在调用objc-allocateClassPair之后在objc-registerClassPair之前"><a href="#给一个类添加成员变量-必须在调用objc-allocateClassPair之后在objc-registerClassPair之前" class="headerlink" title="给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前"></a>给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前</h4><pre><code>// MARK: - 给一个类添加成员变量:必须在调用objc_allocateClassPair之后在objc_registerClassPair之前/** * Adds a new instance variable to a class. * * @return YES if the instance variable was added successfully, otherwise NO *         (for example, the class already contains an instance variable with that name). * * @note This function may only be called after objc_allocateClassPair and before objc_registerClassPair. *       Adding an instance variable to an existing class is not supported. * @note The class must not be a metaclass. Adding an instance variable to a metaclass is not supported. * @note The instance variable&#39;s minimum alignment in bytes is 1&lt;&lt;align. The minimum alignment of an instance *       variable depends on the ivar&#39;s type and the machine architecture. *       For variables of any pointer type, pass log2(sizeof(pointer_type)). */OBJC_EXPORT BOOLclass_addIvar(Class _Nullable cls, const char * _Nonnull name, size_t size,              uint8_t alignment, const char * _Nullable types)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 给一个类添加成员变量/************************************************************************ class_addIvar* Adds an ivar to a class.* Locking: acquires runtimeLock**********************************************************************/BOOLclass_addIvar(Class cls, const char *name, size_t size,              uint8_t alignment, const char *type){    if (!cls) return NO;    if (!type) type = &quot;&quot;;    if (name  &amp;&amp;  0 == strcmp(name, &quot;&quot;)) name = nil;    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    // No class variables    if (cls-&gt;isMetaClass()) {        return NO;    }    // Can only add ivars to in-construction classes.    if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) {        return NO;    }    // Check for existing ivar with this name, unless it&#39;s anonymous.    // Check for too-big ivar.    // fixme check for superclass ivar too?    if ((name  &amp;&amp;  getIvar(cls, name))  ||  size &gt; UINT32_MAX) {        return NO;    }    class_ro_t *ro_w = make_ro_writeable(cls-&gt;data());    // fixme allocate less memory here    ivar_list_t *oldlist, *newlist;    if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) {        size_t oldsize = oldlist-&gt;byteSize();        newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1);        memcpy(newlist, oldlist, oldsize);        free(oldlist);    } else {        newlist = (ivar_list_t *)calloc(sizeof(ivar_list_t), 1);        newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t);    }    uint32_t offset = cls-&gt;unalignedInstanceSize();    uint32_t alignMask = (1&lt;&lt;alignment)-1;    offset = (offset + alignMask) &amp; ~alignMask;    ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++);#if __x86_64__    // Deliberately over-allocate the ivar offset variable.    // Use calloc() to clear all 64 bits. See the note in struct ivar_t.    ivar.offset = (int32_t *)(int64_t *)calloc(sizeof(int64_t), 1);#else    ivar.offset = (int32_t *)malloc(sizeof(int32_t));#endif    *ivar.offset = offset;    ivar.name = name ? strdupIfMutable(name) : nil;    ivar.type = strdupIfMutable(type);    ivar.alignment_raw = alignment;    ivar.size = (uint32_t)size;    ro_w-&gt;ivars = newlist;    cls-&gt;setInstanceSize((uint32_t)(offset + size));    // Ivar layout updated in registerClass.    return YES;}</code></pre><h4 id="获取成员变量名称"><a href="#获取成员变量名称" class="headerlink" title="获取成员变量名称"></a>获取成员变量名称</h4><pre><code>// MARK: - 获取成员变量名称/* Working with Instance Variables *//** * Returns the name of an instance variable. * * @param v The instance variable you want to enquire about. * * @return A C string containing the instance variable&#39;s name. */OBJC_EXPORT const char * _Nullableivar_getName(Ivar _Nonnull v)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取成员变量名称/************************************************************************ ivar_getName* fixme* Locking: none**********************************************************************/const char *ivar_getName(Ivar ivar){    if (!ivar) return nil;    return ivar-&gt;name;}</code></pre><h4 id="获取成员变量类型"><a href="#获取成员变量类型" class="headerlink" title="获取成员变量类型"></a>获取成员变量类型</h4><pre><code>// MARK: - 获取成员变量类型/** * Returns the type string of an instance variable. * * @param v The instance variable you want to enquire about. * * @return A C string containing the instance variable&#39;s type encoding. * * @note For possible values, see Objective-C Runtime Programming Guide &gt; Type Encodings. */OBJC_EXPORT const char * _Nullableivar_getTypeEncoding(Ivar _Nonnull v)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取成员变量名称/************************************************************************ ivar_getTypeEncoding* fixme* Locking: none**********************************************************************/const char *ivar_getTypeEncoding(Ivar ivar){    if (!ivar) return nil;    return ivar-&gt;type;}</code></pre><h3 id="property声明"><a href="#property声明" class="headerlink" title="property声明"></a>property声明</h3><pre><code>/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;</code></pre><p>完整声明在objc-runtime-new.h文件中:</p><pre><code>// MARK: - 属性声明struct property_t {    const char *name;    const char *attributes;};</code></pre><h4 id="根据名称获取一个类的属性"><a href="#根据名称获取一个类的属性" class="headerlink" title="根据名称获取一个类的属性"></a>根据名称获取一个类的属性</h4><pre><code>// MARK: - 根据名称获取一个类的属性/** * Returns a property with a given name of a given class. * * @param cls The class you want to inspect. * @param name The name of the property you want to inspect. * * @return A pointer of type \c objc_property_t describing the property, or *  \c NULL if the class does not declare a property with that name, *  or \c NULL if \e cls is \c Nil. */OBJC_EXPORT objc_property_t _Nullableclass_getProperty(Class _Nullable cls, const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 根据名称获取一个类中的属性/************************************************************************ class_getProperty* fixme* Locking: read-locks runtimeLock**********************************************************************/objc_property_t class_getProperty(Class cls, const char *name){    if (!cls  ||  !name) return nil;    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    for ( ; cls; cls = cls-&gt;superclass) {        for (auto&amp; prop : cls-&gt;data()-&gt;properties) {            if (0 == strcmp(name, prop.name)) {                return (objc_property_t)&amp;prop;            }        }    }    return nil;}</code></pre><p>先判断cls有没有实现,然后可以看到其获取时从可变class_rw_t的成员变量properties中获得:cls-&gt;data()-&gt;properties.</p><h4 id="获取一个类的属性列表"><a href="#获取一个类的属性列表" class="headerlink" title="获取一个类的属性列表"></a>获取一个类的属性列表</h4><pre><code>// MARK: - 获取一个类的属性列表/** * Describes the properties declared by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. *  If \e outCount is \c NULL, the length is not returned. * * @return An array of pointers of type \c objc_property_t describing the properties *  declared by the class. Any properties declared by superclasses are not included. *  The array contains \c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free(). * *  If \e cls declares no properties, or \e cls is \c Nil, returns \c NULL and \c *outCount is \c 0. */OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取一个类的属性列表/************************************************************************ class_copyPropertyList. Returns a heap block containing the* properties declared in the class, or nil if the class* declares no properties. Caller must free the block.* Does not copy any superclass&#39;s properties.* Locking: read-locks runtimeLock**********************************************************************/objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount){    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    checkIsKnownClass(cls);    assert(cls-&gt;isRealized());    // 先获取rw    auto rw = cls-&gt;data();    property_t **result = nil;    unsigned int count = rw-&gt;properties.count();    if (count &gt; 0) {        result = (property_t **)malloc((count + 1) * sizeof(property_t *));        count = 0;        for (auto&amp; prop : rw-&gt;properties) {            result[count++] = &amp;prop;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return (objc_property_t *)result;}</code></pre><h4 id="给一个类添加属性"><a href="#给一个类添加属性" class="headerlink" title="给一个类添加属性"></a>给一个类添加属性</h4><pre><code>// MARK: - 给一个类添加属性/** * Adds a property to a class. * * @param cls The class to modify. * @param name The name of the property. * @param attributes An array of property attributes. * @param attributeCount The number of attributes in \e attributes. * * @return \c YES if the property was added successfully, otherwise \c NO *  (for example, the class already has that property). */OBJC_EXPORT BOOLclass_addProperty(Class _Nullable cls, const char * _Nonnull name,                  const objc_property_attribute_t * _Nullable attributes,                  unsigned int attributeCount)    OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0);// 给一个类添加属性BOOLclass_addProperty(Class cls, const char *name,                  const objc_property_attribute_t *attrs, unsigned int n){    return _class_addProperty(cls, name, attrs, n, NO);}// 给一个类添加属性/************************************************************************ class_addProperty* Adds a property to a class.* Locking: acquires runtimeLock**********************************************************************/static bool_class_addProperty(Class cls, const char *name,                   const objc_property_attribute_t *attrs, unsigned int count,                   bool replace){    if (!cls) return NO;    if (!name) return NO;    property_t *prop = class_getProperty(cls, name);    if (prop  &amp;&amp;  !replace) {        // already exists, refuse to replace        return NO;    }    else if (prop) {        // replace existing        mutex_locker_t lock(runtimeLock);        try_free(prop-&gt;attributes);        prop-&gt;attributes = copyPropertyAttributeString(attrs, count);        return YES;    }    else {        mutex_locker_t lock(runtimeLock);        assert(cls-&gt;isRealized());        property_list_t *proplist = (property_list_t *)            malloc(sizeof(*proplist));        proplist-&gt;count = 1;        proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first);        proplist-&gt;first.name = strdupIfMutable(name);        proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count);        cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1);        return YES;    }}</code></pre><p>其操作的还是class_rw_t中的成员变量properties;侧面印证class_rw_t是可变的.</p><h4 id="更新某个属性值"><a href="#更新某个属性值" class="headerlink" title="更新某个属性值"></a>更新某个属性值</h4><pre><code>// MARK: - 更新某个属性值/** * Replace a property of a class. * * @param cls The class to modify. * @param name The name of the property. * @param attributes An array of property attributes. * @param attributeCount The number of attributes in \e attributes. */OBJC_EXPORT voidclass_replaceProperty(Class _Nullable cls, const char * _Nonnull name,                      const objc_property_attribute_t * _Nullable attributes,                      unsigned int attributeCount)    OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0);// 更新某个属性voidclass_replaceProperty(Class cls, const char *name,                      const objc_property_attribute_t *attrs, unsigned int n){    _class_addProperty(cls, name, attrs, n, YES);}</code></pre><h4 id="获取属性名称"><a href="#获取属性名称" class="headerlink" title="获取属性名称"></a>获取属性名称</h4><pre><code>// MARK: - 获取属性名称/* Working with Properties *//** * Returns the name of a property. * * @param property The property you want to inquire about. * * @return A C string containing the property&#39;s name. */OBJC_EXPORT const char * _Nonnullproperty_getName(objc_property_t _Nonnull property)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取属性名称const char *property_getName(objc_property_t prop){    return prop-&gt;name;}</code></pre><h4 id="获取属性的内存管理语义相关"><a href="#获取属性的内存管理语义相关" class="headerlink" title="获取属性的内存管理语义相关"></a>获取属性的内存管理语义相关</h4><pre><code>// MARK: - 获取属性的内存管理语义相关/** * Returns the attribute string of a property. * * @param property A property. * * @return A C string containing the property&#39;s attributes. * * @note The format of the attribute string is described in Declared Properties in Objective-C Runtime Programming Guide. */OBJC_EXPORT const char * _Nullableproperty_getAttributes(objc_property_t _Nonnull property)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取属性的内存管理语义const char *property_getAttributes(objc_property_t prop){    return prop-&gt;attributes;}</code></pre><p>这个获取的到的就是readwrite,stong,atomic等相关.</p><h3 id="Protocol的声明"><a href="#Protocol的声明" class="headerlink" title="Protocol的声明"></a>Protocol的声明</h3><pre><code>#ifdef __OBJC__@class Protocol;#elsetypedef struct objc_object Protocol;#endif@implementation Protocol#if __OBJC2__// fixme hack - make Protocol a non-lazy class+ (void) load { }#endif- (BOOL) conformsTo: (Protocol *)aProtocolObj{    return protocol_conformsToProtocol(self, aProtocolObj);}- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel{#if !__OBJC2__    return lookup_protocol_method((struct old_protocol *)self, aSel,                                  YES/*required*/, YES/*instance*/,                                  YES/*recursive*/);#else    return method_getDescription(protocol_getMethod((struct protocol_t *)self,                                                     aSel, YES, YES, YES));#endif}- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel{#if !__OBJC2__    return lookup_protocol_method((struct old_protocol *)self, aSel,                                  YES/*required*/, NO/*instance*/,                                  YES/*recursive*/);#else    return method_getDescription(protocol_getMethod((struct protocol_t *)self,                                                    aSel, YES, NO, YES));#endif}- (const char *)name{    return protocol_getName(self);}- (BOOL)isEqual:other{#if __OBJC2__    // check isKindOf:    Class cls;    Class protoClass = objc_getClass(&quot;Protocol&quot;);    for (cls = object_getClass(other); cls; cls = cls-&gt;superclass) {        if (cls == protoClass) break;    }    if (!cls) return NO;    // check equality    return protocol_isEqual(self, other);#else    return [other isKindOf:[Protocol class]] &amp;&amp; [self conformsTo: other] &amp;&amp; [other conformsTo: self];#endif}#if __OBJC2__- (NSUInteger)hash{    return 23;}#else- (unsigned)hash{    return 23;}#endif@end</code></pre><p>在runtime.h文件中我们可以看到Protocol被定义为一个类继承自上帝类NSObject.这个类并没有对外暴露什么接口.下面我们看一下protocol_t的完整声明:</p><pre><code>// MARK: - 协议的声明结构struct protocol_t : objc_object {    const char *mangledName;    struct protocol_list_t *protocols; //协议列表    method_list_t *instanceMethods;//实例方法列表    method_list_t *classMethods;//类方法列表    method_list_t *optionalInstanceMethods;//可选的实例方法列表    method_list_t *optionalClassMethods;//可选的类方法列表    property_list_t *instanceProperties;//属性列表    uint32_t size;   // sizeof(protocol_t)    uint32_t flags;    // Fields below this point are not always present on disk.    const char **_extendedMethodTypes;    const char *_demangledName;    property_list_t *_classProperties;    const char *demangledName();    const char *nameForLogging() {        return demangledName();    }    bool isFixedUp() const;    void setFixedUp();#   define HAS_FIELD(f) (size &gt;= offsetof(protocol_t, f) + sizeof(f))    bool hasExtendedMethodTypesField() const {        return HAS_FIELD(_extendedMethodTypes);    }    bool hasDemangledNameField() const {        return HAS_FIELD(_demangledName);    }    bool hasClassPropertiesField() const {        return HAS_FIELD(_classProperties);    }#   undef HAS_FIELD    const char **extendedMethodTypes() const {        return hasExtendedMethodTypesField() ? _extendedMethodTypes : nil;    }    property_list_t *classProperties() const {        return hasClassPropertiesField() ? _classProperties : nil;    }};</code></pre><h4 id="给一个类添加协议"><a href="#给一个类添加协议" class="headerlink" title="给一个类添加协议"></a>给一个类添加协议</h4><pre><code>// MARK: - 给一个类添加协议/** * Adds a protocol to a class. * * @param cls The class to modify. * @param protocol The protocol to add to \e cls. * * @return \c YES if the method was added successfully, otherwise \c NO *  (for example, the class already conforms to that protocol). */OBJC_EXPORT BOOLclass_addProtocol(Class _Nullable cls, Protocol * _Nonnull protocol)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 给一个类添加协议/************************************************************************ class_addProtocol* Adds a protocol to a class.* Locking: acquires runtimeLock**********************************************************************/BOOL class_addProtocol(Class cls, Protocol *protocol_gen){    protocol_t *protocol = newprotocol(protocol_gen);    if (!cls) return NO;    if (class_conformsToProtocol(cls, protocol_gen)) return NO;    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    // fixme optimize    protocol_list_t *protolist = (protocol_list_t *)        malloc(sizeof(protocol_list_t) + sizeof(protocol_t *));    protolist-&gt;count = 1;    protolist-&gt;list[0] = (protocol_ref_t)protocol;    // 添加到protocols里面    cls-&gt;data()-&gt;protocols.attachLists(&amp;protolist, 1);    // fixme metaclass?    return YES;}</code></pre><p>其操作的还是class_rw_t中的成员变量protocols;侧面印证class_rw_t是可变的.</p><h4 id="根据名称获取一个协议"><a href="#根据名称获取一个协议" class="headerlink" title="根据名称获取一个协议"></a>根据名称获取一个协议</h4><pre><code>// MARK: - 根据名称获取一个协议/* Working with Protocols *//** * Returns a specified protocol. * * @param name The name of a protocol. * * @return The protocol named \e name, or \c NULL if no protocol named \e name could be found. * * @note This function acquires the runtime lock. */OBJC_EXPORT Protocol * _Nullableobjc_getProtocol(const char * _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议/************************************************************************ objc_getProtocol* Get a protocol by name, or return nil* Locking: read-locks runtimeLock**********************************************************************/Protocol *objc_getProtocol(const char *name){    mutex_locker_t lock(runtimeLock);    return getProtocol(name);}</code></pre><h4 id="获取运行时所有的协议列表"><a href="#获取运行时所有的协议列表" class="headerlink" title="获取运行时所有的协议列表"></a>获取运行时所有的协议列表</h4><pre><code>// MARK: - 获取运行时所有的协议列表/** * Returns an array of all the protocols known to the runtime. * * @param outCount Upon return, contains the number of protocols in the returned array. * * @return A C array of all the protocols known to the runtime. The array contains \c *outCount *  pointers followed by a \c NULL terminator. You must free the list with \c free(). * * @note This function acquires the runtime lock. */OBJC_EXPORT Protocol * __unsafe_unretained _Nonnull * _Nullableobjc_copyProtocolList(unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取运行时所有的协议列表/************************************************************************ objc_copyProtocolList* Returns pointers to all protocols.* Locking: read-locks runtimeLock**********************************************************************/Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount){    mutex_locker_t lock(runtimeLock);    NXMapTable *protocol_map = protocols();    unsigned int count = NXCountMapTable(protocol_map);    if (count == 0) {        if (outCount) *outCount = 0;        return nil;    }    Protocol **result = (Protocol **)malloc((count+1) * sizeof(Protocol*));    unsigned int i = 0;    Protocol *proto;    const char *name;    NXMapState state = NXInitMapState(protocol_map);    while (NXNextMapState(protocol_map, &amp;state,                          (const void **)&amp;name, (const void **)&amp;proto))    {        result[i++] = proto;    }    result[i++] = nil;    assert(i == count+1);    if (outCount) *outCount = count;    return result;}</code></pre><h4 id="获取某个协议中的某个属性"><a href="#获取某个协议中的某个属性" class="headerlink" title="获取某个协议中的某个属性"></a>获取某个协议中的某个属性</h4><pre><code>// MARK: - 获取某个协议中的某个属性/** * Returns the specified property of a given protocol. * * @param proto A protocol. * @param name The name of a property. * @param isRequiredProperty \c YES searches for a required property, \c NO searches for an optional property. * @param isInstanceProperty \c YES searches for an instance property, \c NO searches for a class property. * * @return The property specified by \e name, \e isRequiredProperty, and \e isInstanceProperty for \e proto, *  or \c NULL if none of \e proto&#39;s properties meets the specification. */OBJC_EXPORT objc_property_t _Nullableprotocol_getProperty(Protocol * _Nonnull proto,                     const char * _Nonnull name,                     BOOL isRequiredProperty, BOOL isInstanceProperty)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议中的某个属性objc_property_t protocol_getProperty(Protocol *p, const char *name,                              BOOL isRequiredProperty, BOOL isInstanceProperty){    if (!p  ||  !name) return nil;    mutex_locker_t lock(runtimeLock);    return (objc_property_t)        protocol_getProperty_nolock(newprotocol(p), name,                                    isRequiredProperty, isInstanceProperty);}</code></pre><h4 id="获取协议的属性列表"><a href="#获取协议的属性列表" class="headerlink" title="获取协议的属性列表"></a>获取协议的属性列表</h4><pre><code>// MARK: - 获取协议的属性列表/** * Returns an array of the required instance properties declared by a protocol. * * @note Identical to * \code * protocol_copyPropertyList2(proto, outCount, YES, YES); * \endcode */OBJC_EXPORT objc_property_t _Nonnull * _Nullableprotocol_copyPropertyList(Protocol * _Nonnull proto,                          unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 获取协议属性列表objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount){    return protocol_copyPropertyList2(proto, outCount,                                      YES/*required*/, YES/*instance*/);}// 获取协议属性列表objc_property_t *protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount,                           BOOL isRequiredProperty, BOOL isInstanceProperty){    if (!proto  ||  !isRequiredProperty) {        // Optional properties are not currently supported.        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    property_list_t *plist = isInstanceProperty        ? newprotocol(proto)-&gt;instanceProperties        : newprotocol(proto)-&gt;classProperties();    return (objc_property_t *)copyPropertyList(plist, outCount);}</code></pre><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class解读</title>
      <link href="/2019/04/15/Class%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/15/Class%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>首先我们在runtime.h文件中看到objc_class的结构声明:</p><pre><code>/// 类的声明结构struct objc_class {Class _Nonnull isa OBJC_ISA_AVAILABILITY;//isa 指针#if !__OBJC2__Class _Nullable super_class OBJC2_UNAVAILABLE;//指向父类的指针const char * _Nonnull name OBJC2_UNAVAILABLE;//类名long version OBJC2_UNAVAILABLE;//版本long info OBJC2_UNAVAILABLE;//其它信息long instance_size OBJC2_UNAVAILABLE;//实例变量空间大小struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;//成员变量列表struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;//方法列表struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;//方法缓存列表struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;//协议列表#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>以上是runtime暴露给我们的有关Class的接口,而在objc-runtime-new.h文件中有objc_class结构的完整声明:</p><pre><code>// MARK: - class的完整声明结构struct objc_class : objc_object {// Class ISA;Class superclass;//指向父类指针cache_t cache; // formerly cache pointer and vtable //缓存一些指针和虚表class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // 含有class_rw_t,内部存储方法,属性,遵循的协议等// class_rw_t指针class_rw_t *data() {return bits.data();}// set bitsvoid setData(class_rw_t *newData) {bits.setData(newData);}...下面未列出}</code></pre><p>可以看出,objc_class中有几个比较重要的成员变量和函数:</p><h5 id="superclass"><a href="#superclass" class="headerlink" title="superclass"></a><strong>superclass</strong></h5><p>指向父类的指针</p><h5 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a><strong>cache_t</strong></h5><p>cache里面存的是指针和虚表,为了方法调用时,快速查询,提高效率.其结构声明如下:</p><pre><code>// MARK: - cache_t结构声明struct cache_t {struct bucket_t *_buckets;mask_t _mask;mask_t _occupied;...下面未列出}</code></pre><h6 id="bucket-t"><a href="#bucket-t" class="headerlink" title="bucket_t"></a>bucket_t</h6><pre><code>// MARK: - bucket_t声明结构struct bucket_t {private:// IMP-first is better for arm64e ptrauth and no worse for arm64.// SEL-first is better for armv7* and i386 and x86_64.#if __arm64__MethodCacheIMP _imp;cache_key_t _key;#elsecache_key_t _key;MethodCacheIMP _imp;#endifpublic:inline cache_key_t key() const { return _key; }inline IMP imp() const { return (IMP)_imp; }inline void setKey(cache_key_t newKey) { _key = newKey; }inline void setImp(IMP newImp) { _imp = newImp; }void set(cache_key_t newKey, IMP newImp);};</code></pre><p>这个bucket_t类似于一个hash表,其没一个cache_key_t对应一个imp.其关系如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-2f6f114a344d02ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bucket_t"></p><h5 id="class-data-bits-t结构"><a href="#class-data-bits-t结构" class="headerlink" title="class_data_bits_t结构"></a><strong>class_data_bits_t结构</strong></h5><pre><code>// MARK: - class_data_bits_t声明结构struct class_data_bits_t {class_rw_t* data() {return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}void setData(class_rw_t *newData){assert(!data() || (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));// Set during realization or construction only. No locking needed.// Use a store-release fence because there may be concurrent// readers of data and data&#39;s contents.uintptr_t newBits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;atomic_thread_fence(memory_order_release);bits = newBits;}...其它未列出}</code></pre><p>class_data_bits_t中成员函数 data()函数,返回一个class_rw_t结构指针;</p><h5 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a><strong>class_rw_t</strong></h5><pre><code>// MARK: - class_rw_t结构声明struct class_rw_t {// Be warned that Symbolication knows the layout of this structure.uint32_t flags;uint32_t version;const class_ro_t *ro;method_array_t methods;property_array_t properties;protocol_array_t protocols;Class firstSubclass;Class nextSiblingClass;char *demangledName;#if SUPPORT_INDEXED_ISAuint32_t index;#endifvoid setFlags(uint32_t set){OSAtomicOr32Barrier(set, &amp;flags);}void clearFlags(uint32_t clear){OSAtomicXor32Barrier(clear, &amp;flags);}// set and clear must not overlapvoid changeFlags(uint32_t set, uint32_t clear){assert((set &amp; clear) == 0);uint32_t oldf, newf;do {oldf = flags;newf = (oldf | set) &amp; ~clear;} while (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (volatile int32_t *)&amp;flags));}};</code></pre><p>class_rw_t中的成员变量class_ro_t:</p><h5 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a><strong>class_ro_t</strong></h5><pre><code>// MARK: - class_ro_t结构声明struct class_ro_t {uint32_t flags;uint32_t instanceStart;uint32_t instanceSize;#ifdef __LP64__uint32_t reserved;#endifconst uint8_t * ivarLayout;const char * name;method_list_t * baseMethodList;protocol_list_t * baseProtocols;const ivar_list_t * ivars;const uint8_t * weakIvarLayout;property_list_t *baseProperties;method_list_t *baseMethods() const {return baseMethodList;}};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_ro_t有method_list_t,protocol_list_t,ivar_list_t,property_list_t等成员变量这些成员变量的作用是存储编译后已确定的一些信息.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_rw_t中同样有method_array_t(方法列表),property_array_t(属性列表),protocol_array_t(协议列表),这三者均继承自list_array_tt,list_array_tt可以扩充,内部分别存储的是method_list_t,property_list_t和protocol_list_t;这个三个成员变量主要是方便在运行时为类提供拓展能力.</p><h4 id="编译后class内存布局"><a href="#编译后class内存布局" class="headerlink" title="编译后class内存布局"></a>编译后class内存布局</h4><pre><code>// Person#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface Person : NSObject- (void)name;@endNS_ASSUME_NONNULL_ENDint main(int argc, const char * argv[]) {@autoreleasepool {Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);objc_registerClassPair(newClass);id newObject = [[newClass alloc]init];NSLog(@&quot;%s&quot;,class_getName([newObject class]));NSLog(@&quot;Hello, World!&quot;);Person *person = [Person new];[person name];[person name];Class cls = [Person class];}return 0;}</code></pre><p>我们来看cls这个class在编译后的内存布局,首先我们在main入口函数里面继续初始化一个Class cls = [Person class];然后运行一下获取当前cls的内存地址,然后将断点放过.</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-5d0150be3d085679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Person class address"></p><p>然后在_objc_init()函数(runtime初始化之前)加一个断点:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-11a62e46db779044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_objc_init()"></p><p>用lldb命令调试一下:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-ca7a1d8cedf5f4bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cls memory layout"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上图我们可以看到,name(“Person”)和baseMethodList这两个是有值,其它都为0x0000000000000000空指针,这个也反映出我们在Person中的最初定义:只有一个- (void)name方法,没有协议,成员变量,属性等.</p><p>我们从baseMethodList方法列表中第一个method_t</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-2cdabc19c9ae5403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="name func"></p><p>这个method_t正好对应我们定义的name方法;而baseMethodList里面也就有1个方法:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-562d498710ddaf8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="baseMethodList count"></p><h4 id="类的实现realizeClass"><a href="#类的实现realizeClass" class="headerlink" title="类的实现realizeClass"></a>类的实现realizeClass</h4><p>realizeClass是类初始化函数,类的运行时初始化都要调用此函数.</p><pre><code>// MARK: - 类的初始化/************************************************************************ realizeClass* Performs first-time initialization on class cls,* including allocating its read-write data.* Returns the real class structure for the class.* Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClass(Class cls){runtimeLock.assertLocked();const class_ro_t *ro;class_rw_t *rw;Class supercls;Class metacls;bool isMeta;if (!cls) return nil;if (cls-&gt;isRealized()) return cls;assert(cls == remapClass(cls));// fixme verify class is not in an un-dlopened part of the shared cache?ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) {// This was a future class. rw data is already allocated.rw = cls-&gt;data();ro = cls-&gt;data()-&gt;ro;cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else {// Normal class. Allocate writeable class data.rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw);}isMeta = ro-&gt;flags &amp; RO_META;rw-&gt;version = isMeta ? 7 : 0; // old runtime went up to 6// Choose an index for this class.// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are availablecls-&gt;chooseClassArrayIndex();if (PrintConnecting) {_objc_inform(&quot;CLASS: realizing class &#39;%s&#39;%s %p %p #%u&quot;,cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;,(void*)cls, ro, cls-&gt;classArrayIndex());}// Realize superclass and metaclass, if they aren&#39;t already.// This needs to be done after RW_REALIZED is set above, for root classes.// This needs to be done after class index is chosen, for root metaclasses.supercls = realizeClass(remapClass(cls-&gt;superclass));metacls = realizeClass(remapClass(cls-&gt;ISA()));#if SUPPORT_NONPOINTER_ISA// Disable non-pointer isa for some classes and/or platforms.// Set instancesRequireRawIsa.bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();bool rawIsaIsInherited = false;static bool hackedDispatch = false;if (DisableNonpointerIsa) {// Non-pointer isa disabled by environment or app SDK versioninstancesRequireRawIsa = true;}else if (!hackedDispatch &amp;&amp; !(ro-&gt;flags &amp; RO_META) &amp;&amp;0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)){// hack for libdispatch et al - isa also acts as vtable pointerhackedDispatch = true;instancesRequireRawIsa = true;}else if (supercls &amp;&amp; supercls-&gt;superclass &amp;&amp;supercls-&gt;instancesRequireRawIsa()){// This is also propagated by addSubclass()// but nonpointer isa setup needs it earlier.// Special case: instancesRequireRawIsa does not propagate// from root class to root metaclassinstancesRequireRawIsa = true;rawIsaIsInherited = true;}if (instancesRequireRawIsa) {cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);}// SUPPORT_NONPOINTER_ISA#endif// Update superclass and metaclass in case of remappingcls-&gt;superclass = supercls;cls-&gt;initClassIsa(metacls);// Reconcile instance variable offsets / layout.// This may reallocate class_ro_t, updating our ro variable.if (supercls &amp;&amp; !isMeta) reconcileInstanceVariables(cls, supercls, ro);// Set fastInstanceSize if it wasn&#39;t set already.cls-&gt;setInstanceSize(ro-&gt;instanceSize);// Copy some flags from ro to rwif (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) {cls-&gt;setHasCxxDtor();if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) {cls-&gt;setHasCxxCtor();}}// Connect this class to its superclass&#39;s subclass listsif (supercls) {addSubclass(supercls, cls);} else {addRootClass(cls);}// Attach categoriesmethodizeClass(cls);return cls;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们来验证class_ro_t确定时机.还是之前的步骤,先编译一次获取到cls的内存地址.在static Class realizeClass(Class cls){}入口添加一个条件断点,运行:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-4eeb6440a9f42fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition breakpoint"></p><p>然后lldb调试cls:</p><p>访问 class_data_bits_t 指针的内容:(class_data_bits_t) $2755 = (bits = 4294971696)</p><p>获取 class_rw_t:</p><pre><code>(class_rw_t) $2757 = {flags = 128version = 8ro = 0x0000000000000008methods = {list_array_tt&lt;method_t, method_list_t&gt; = {= {list = 0x0000000000000000arrayAndFlag = 0}}}properties = {list_array_tt&lt;property_t, property_list_t&gt; = {= {list = 0x0000000100000f84arrayAndFlag = 4294971268}}}protocols = {list_array_tt&lt;unsigned long, protocol_list_t&gt; = {= {list = 0x0000000100001110arrayAndFlag = 4294971664}}}firstSubclass = nilnextSiblingClass = nildemangledName = 0x0000000000000000 &lt;no value available&gt;}</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1715253-aac44a322f04f552.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class_rw_t"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到class_rw_t中的成员变量ro = 0x0000000000000008在运行前已经有值了.获取一下ro:</p><pre><code>(lldb) p $2757.ro(const class_ro_t *) $2758 = 0x0000000000000008</code></pre><p>由于lldb输出class_ro_t报错:</p><pre><code>(lldb) p *$2758error: Couldn&#39;t apply expression side effects : Couldn&#39;t dematerialize a result variable: couldn&#39;t read its memory</code></pre><p>我们直接单步断点,往下走两步,直接获取ro的值:</p><p><img src="http://upload-images.jianshu.io/upload_images/1715253-db5d8af8cabe5ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class_ro_t"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们发现const指针 class_ro_t已经在编译期把类的相关信息(方法,属性,成员变量,协议)确定了.而类的初始化方法执行之后,编译期的ro赋值给了运行期的rw的成员变量ro了.</p><pre><code>ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) {// This was a future class. rw data is already allocated.rw = cls-&gt;data();ro = cls-&gt;data()-&gt;ro;cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else {// 将ro等信息赋值给class_rw_t// Normal class. Allocate writeable class data.rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw);}</code></pre><p>我们知道class_rw_t中除了class_ro_t成员变量外,还有以下三个成员变量:</p><pre><code>method_array_t methods;property_array_t properties;protocol_array_t protocols;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三个成员变量的赋值操作在static void methodizeClass(Class cls)()函数中,分别遍历ro中的方法,协议,属性列表分别加入到class_rw_t的methods,protocols,properties中.</p><pre><code>// MARK: - 将ro中的方法,属性,协议等列表添加到rw中对应的三个成员变量列表中/************************************************************************ methodizeClass* Fixes up cls&#39;s method list, protocol list, and property list.* Attaches any outstanding categories.* Locking: runtimeLock must be held by the caller**********************************************************************/static void methodizeClass(Class cls){runtimeLock.assertLocked();bool isMeta = cls-&gt;isMetaClass();auto rw = cls-&gt;data();auto ro = rw-&gt;ro;// Methodizing for the first timeif (PrintConnecting) {_objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;,cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);}// 遍历ro中方法将其加入到rw methods中// Install methods and properties that the class implements itself.method_list_t *list = ro-&gt;baseMethods();if (list) {prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));rw-&gt;methods.attachLists(&amp;list, 1);}// 遍历ro中属性列表将其加入到 rw properties中property_list_t *proplist = ro-&gt;baseProperties;if (proplist) {rw-&gt;properties.attachLists(&amp;proplist, 1);}// 遍历ro中协议列表将其加入到 rw protocols中protocol_list_t *protolist = ro-&gt;baseProtocols;if (protolist) {rw-&gt;protocols.attachLists(&amp;protolist, 1);}// Root classes get bonus method implementations if they don&#39;t have// them already. These apply before category replacements.if (cls-&gt;isRootMetaclass()) {// root metaclassaddMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);}// Attach categories.category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);attachCategories(cls, cats, false /*don&#39;t flush caches*/);if (PrintConnecting) {if (cats) {for (uint32_t i = 0; i &lt; cats-&gt;count; i++) {_objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;,isMeta ? &#39;+&#39; : &#39;-&#39;,cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);}}}if (cats) free(cats);#if DEBUG// Debug: sanity-check all SELs; log method list contentsfor (const auto&amp; meth : rw-&gt;methods) {if (PrintConnecting) {_objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;,cls-&gt;nameForLogging(), sel_getName(meth.name));}assert(sel_registerName(sel_getName(meth.name)) == meth.name);}#endif}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译期:通过objc_class-&gt;data()获取class_ro_t,class的method,property,protocol,ivar等已确定被赋值给class_ro_t,class_to_t只读,说明编译期类的内存布局已固定.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行期:通过realizeClass()类初始化函数,给class_rw_t分配空间,将class_ro_t赋值给class_rw_t的成员变量ro.将ro中的方法,协议,属性列表分别加入到class_rw_t的methods,protocols,properties中.class_rw_t提供了运行期这些成员变量的扩展性.</p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/04/14/%E6%A0%91/"/>
      <url>/2019/04/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一棵树(tree)是一些节点的集合.这个集合可以为空集.若这个集合非空,则一个树由称做根(root)的节点r和多个子树T1,T2,…Tn组成,这些子树又可以有多个子树,这就让我们想到定义树一个常规方法就是递归,而每棵子树都与根节点r通过一条有向的边(edge)相连.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一棵子树叫做根r的儿子(child),根r称做每一棵子树的父亲(praent).所有节点组成的树,共有N个节点和N-1条边.没有儿子的节点也可以称做树叶(leaf),具有相同父亲的多个节点之间互称为兄弟(sibling).</p><h4 id="节点的度"><a href="#节点的度" class="headerlink" title="节点的度"></a>节点的度</h4><p>一个节点含有子节点的个数称为节点的度,树的度为树中某个节点的最大度即为树的度.</p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>从节点n1到nk看做是树的一条路径(path),这个路径包括了n1到nk的k个节点以及k-1条边,路径的长度也就是该路径上边的个数.</p><h4 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h4><p>对于任意节点ni的深度指的是从根节点r到节点ni的唯一有效路径的长度.根r的深度为0.</p><h4 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h4><p>对于任意节点ni的高度指的是从n到树叶节点最长路径的长.一棵树的高度指的是根r到树叶最长的路径长.</p><h4 id="节点的层次"><a href="#节点的层次" class="headerlink" title="节点的层次"></a>节点的层次</h4><p>节点的层次指的是节点的层级,根r的层数是1,其儿子节点层次是2.所有子节点层次比父亲节点层次大1.</p><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><p>由多棵树组成的集合称为森林.</p><p><img src="http://abc.waitwalker.cn/tree.jpg" alt="tree"></p><h3 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h3><h4 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h4><pre><code>// MARK: - 树class Tree&lt;T:Equatable&gt; {    // 节点value    var value:T    // 子节点    private(set) var children:[Tree] = []    // 父节点    var parent:Tree?    // MARK: - 构造函数    init(value:T) {        self.value = value    }}</code></pre><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><pre><code>/// 添加节点    ///    /// - Parameter treeNode: 子节点    func addChild(treeNode:Tree) -&gt; Void {        children.append(treeNode)        treeNode.parent = self    }</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快识别隐私政策(Fast OCR Privacy Policy)</title>
      <link href="/2019/04/13/%E5%BF%AB%E8%AF%86%E5%88%AB%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96-Fast-OCR-Privacy-Policy/"/>
      <url>/2019/04/13/%E5%BF%AB%E8%AF%86%E5%88%AB%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96-Fast-OCR-Privacy-Policy/</url>
      
        <content type="html"><![CDATA[<p><strong>我们尊重用户的隐私并对非法窃取用户隐私的行为予以坚决抵制.</strong><br>We respect user privacy and resist those who illegally steal user privacy.</p><p><strong>1.快识别依据强大的云技术识别平台,在识别之前需要您允许网络权限,请知晓.</strong><br>Please know that Fast OCR is based on a powerful cloud technology identification platform, you need to allow network privileges before identification.</p><p><strong>2.识别信息会保存在本地,您有任何操作本地数据的权限.</strong><br>Any information you have will only be saved locally and you have any privileges to manipulate local data.</p><p><strong>3.您在使用App的过程中可能会让您授权访问相册,相机等,请知晓,权限由您操作.</strong><br>In the process of using App, you may authorize access to albums, cameras, etc. Please know that the privileges are operated by you.</p><p><strong>4.使用过程中有任何问题,可以在设置页面点击关注,然后进行相关问题反馈.</strong><br>If you have any problems in the process of using App, you can click on the settings page and follow me, feedback on related issues.</p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快识别隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狗圈儿隐私政策</title>
      <link href="/2019/04/13/%E7%8B%97%E5%9C%88%E5%84%BF%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
      <url>/2019/04/13/%E7%8B%97%E5%9C%88%E5%84%BF%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
      
        <content type="html"><![CDATA[<p>请您仔细阅读以下条款，如果您对本协议的任何条款表示异议，您可以选择不进入狗圈儿。当您注册成功，无论是进入狗圈儿，还是在狗圈儿上发布任何内容，或者是直接或通过各类方式（如站外API引用等）间接使用狗圈儿网服务和数据的行为，都将被视作已无条件接受本声明所涉全部内容。若您对本声明的任何条款有异议，请停止使用狗圈儿网所提供的全部服务。</p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a><strong>使用规则</strong></h3><p>1、用户注册成功后，狗圈儿将给予每个用户一个用户帐号及相应的密码，该用户帐号和密码由用户负责保管；用户应当对以其用户帐号进行的所有活动和事件负法律责任。<br>2、用户须对在狗圈儿的注册信息的真实性、合法性、有效性承担全部责任，用户不得冒充他人；不得利用他人的名义发布任何信息；不得恶意使用注册帐号导致其他用户误认； 任何机构或个人注册和使用的互联网用户账号名称，不得有下列情形：<br>(一）违反宪法或法律法规规定的；<br>（二）危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；<br>（三）损害国家荣誉和利益的，损害公共利益的；<br>（四）煽动民族仇恨、民族歧视，破坏民族团结的；<br>（五）破坏国家宗教政策，宣扬邪教和封建迷信的；<br>（六）散布谣言，扰乱社会秩序，破坏社会稳定的；<br>（七）散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；<br>（八）侮辱或者诽谤他人，侵害他人合法权益的；<br>（九）含有法律、行政法规禁止的其他内容的。</p><h3 id="关于用户名的管理"><a href="#关于用户名的管理" class="headerlink" title="关于用户名的管理"></a><strong>关于用户名的管理</strong></h3><p>请勿以党和国家领导人或其他名人的真实姓名、字、号、艺名、笔名、头衔等注册和使用昵 称（如确为本人，需要提交相关证据并通过审核方可允许使用）；<br>请勿以国家组织机构或其他组织机构的名称等注册和使用昵称（如确为该机构，需要提交相关证据并通过审核方可允许使用）；<br>请勿注册和使用与其他网友相同、相仿的名字或昵称；<br>请勿注册和使用不文明、不健康的ID和昵称；<br>请勿注册和使用易产生歧义、引起他人误解或带有各种奇形怪状符号的ID和昵称。<br>用户以虚假信息骗取账号名称注册，或账号头像、简介等注册信息存在违法和不良信息的，狗圈儿将暂停或注销。<br>用户连续一年没有在狗圈儿上更新动态，狗圈儿有权收回该用户昵称。<br>3、狗圈儿是一个信息分享及传播的平台。用户通过狗圈儿发表的信息为公开的信息，其他第三方均可以通过狗圈儿获取用户发表的信息，用户对任何信息的发表即认可该信息为公开的信息，并单独对此行为承担法律责任；任何用户不愿被其他第三人获知的信息都不应该在狗圈儿上进行发表。<br>4、用户承诺不得以任何方式利用狗圈儿直接或间接从事违反中国法律、以及社会公德的行为，狗圈儿有权对违反上述承诺的内容予以删除。<br>5、狗圈儿用户不得利用狗圈儿服务制作、上载、复制、发布、传播或者转载如下内容：<br>· 反对宪法所确定的基本原则的；<br>· 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；<br>· 损害国家荣誉和利益的；<br>· 煽动民族仇恨、民族歧视，破坏民族团结的；<br>· 破坏国家宗教政策，宣扬邪教和封建迷信的；<br>· 散布谣言，扰乱社会秩序，破坏社会稳定的；<br>· 散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；<br>· 侮辱或者诽谤他人，侵害他人合法权益的；<br>· 含有法律、行政法规禁止的其他内容的信息。<br>6、狗圈儿有权对用户使用狗圈儿的情况进行审查和监督，如用户在使用狗圈儿时违反任何上述规定，狗圈儿或其授权的人有权要求用户改正或直接采取一切必要的措施（包括但不限于更改或删除用户张贴的内容、暂停或终止用户使用狗圈儿的权利）以减轻用户不当行为造成的影响。</p><h3 id="知识产权"><a href="#知识产权" class="headerlink" title="知识产权"></a><strong>知识产权</strong></h3><p>狗圈儿是一个信息获取、分享及传播的平台，我们尊重和鼓励狗圈儿用户创作的内容，认识到保护知识产权对狗圈儿生存与发展的重要性，承诺将保护知识产权作为狗圈儿运营的基本原则之一。<br>1、用户在狗圈儿上发表的全部原创内容，著作权均归用户本人所有。用户可授权第三方以任何方式使用，不需要得到狗圈儿的同意。<br>2、狗圈儿提供的网络服务中包含的标识、版面设计、排版方式、文本、图片、图形等均受著作权、商标权及其它法律保护，未经相关权利人（含狗圈儿及其他原始权利人）同意，上述内容均不得在任何平台被直接或间接发布、使用、出于发布或使用目的的改写或再发行，或被用于其他任何商业目的。<br>3、为了促进其创作内容的分享和传播，用户将其在狗圈儿上发表的全部内容，授予狗圈儿免费的、不可撤销的、非独家使用许可，狗圈儿有权将该内容用于狗圈儿各种形态的产品和服务上，包括但不限于网站以及发表的应用或其他互联网产品。<br>第三方若出于非商业目的，将用户在狗圈儿上发表的内容转载在狗圈儿之外的地方，应当在作品的正文开头的显著位置注明原作者姓名（或原作者在狗圈儿上使用的帐号名称），给出原始链接，注明「发表于狗圈儿」，并不得对作品进行修改演绎。若需要对作品进行修改，或用于商业目的，第三方应当联系用户获得单独授权，按照用户规定的方式使用该内容。<br>4、狗圈儿为用户提供「保留所有权利，禁止转载」的选项。除非获得原作者的单独授权，并邮件通知狗圈儿（邮箱：<a href="mailto:waitwalker@163.com" target="_blank" rel="noopener">waitwalker@163.com</a>），任何第三方不得转载标注了「禁止转载」的内容，否则均视为侵权。<br>5、在狗圈儿上传或发表的内容，用户应保证其为著作权人或已取得合法授权，并且该内容不会侵犯任何第三方的合法权益。如果第三方提出关于著作权的异议，狗圈儿有权根据实际情况删除相关的内容有权追究用户的法律责任，给狗圈儿或任何第三方造成损失的，用户应负责全额赔偿。<br>6、如果任何第三方侵犯了狗圈儿用户相关的权利，用户同意授权狗圈儿或其指定的代理人代表狗圈儿自身或用户对该第三方提出警告、投诉、发起行政执法、诉讼、进行上诉，或谈判和解，并且用户同意在狗圈儿认为必要的情况下参与共同维权。<br>7、狗圈儿有权但无义务对用户发布的内容进行审核，有权根据相关证据结合《侵权责任法》、《信息网络传播权保护条例》等法律法规及狗圈儿指导原则对侵权信息进行处理。</p><h3 id="个人隐私"><a href="#个人隐私" class="headerlink" title="个人隐私"></a><strong>个人隐私</strong></h3><p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><ol><li>适用范围<br>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息，留存的个人身份信息主要包括但不限于个人用户服务账号及密码、拍照/摄像等。如您拒绝提供将无法使用我们的产品或服务。<br>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您访问应用服务器和手机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；<br>(c)为确保本APP正常运转，我们会在您的移动设备上存储名为 Cookie的小数据文件。Cookie通常包含标识符、站点名称以及一些号码和字符。借助于Cookie能够存储您的偏好等数据。我们不会将Cookie用于本政策所述目的之外的任何用途。您可根据自己的偏好管理或删除Cookie。您可以清除本设备上保存的所有Cookie，大部分网络浏览器都设有阻止Cookie的功能。但如果您这么做，则需要在每一次使用本APP时更改用户设置<br>(d) 如果我们需要将信息用于本政策未载明的其它用途时，会事先征求您的同意。</li><li>信息使用及信息披露<br>(a)本应用不会向任何无关第三方及其所使用的SDK等提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。<br>(b) 本应用亦不允许任何第三方及其所使用的SDK等以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。<br>(c) 为向您提供服务及改善服务质量，在遵守国家法律法规及监管政策的前提下，我们可能将收集到的您的个人信息用于以下目的：<br>(1)为您提供服务, 经您事先同意，向第三方披露,例如设备一些崩溃信息的收集等以改善服务质量；<br>(2) 与公共安全、公共卫生、重大公共利益有关的；<br>(3) 与犯罪侦查、起诉、审判和判决执行等有关的；<br>(4) 出于维护个人信息主体或其他个人的生命、财产等重大合法权益但又很难得到本人同意的；<br>(5) 所收集的个人信息是个人信息主体自行向社会公众公开的；<br>(6) 从合法公开披露的信息中收集的您的个人信息的，如合法的新闻报道、政府信息公开等渠道；<br>(7) 根据您的要求签订和履行合同所必需的；<br>(8) 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障；<br>(9) 法律法规及监管政策规定的其他情形。</li><li>信息存储和交换<br>本应用收集的有关您的信息和资料将保存在本应用及（或）其应用关联的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</li><li>信息安全<br>本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。<br>5.本隐私政策的更改<br>(a)如果决定更改隐私政策，我们会在本政策中、网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。<br>(b)我们保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，我们会通过及时通过各种形式发布告知。<br>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</li></ol><h3 id="侵权举报"><a href="#侵权举报" class="headerlink" title="侵权举报"></a><strong>侵权举报</strong></h3><p>1、处理原则<br>狗圈儿高度重视自由表达和企业正当权利的平衡。依照法律规定删除违法信息是狗圈儿的法定义务，狗圈儿亦未与任何中介机构合作开展此项业务。<br>2、受理范围<br>受理狗圈儿内侵犯企业或个人合法权益的侵权举报，包括但不限于涉及个人隐私、造谣与诽谤、商业侵权。<br>涉及个人隐私：发布内容中直接涉及身份信息，如个人姓名、家庭住址、身份证号码、工作单位、私人电话等详细个人隐私；<br>造谣、诽谤：发布内容中指名道姓（包括自然人和企业）的直接谩骂、侮辱、虚构中伤、恶意诽谤等；<br>商业侵权：泄露企业商业机密及其他根据保密协议不能公开讨论的内容。<br>3、举报条件<br>如果个人或单位发现狗圈儿上存在侵犯自身合法权益的内容，请与狗圈儿取得联系（邮箱：<a href="mailto:waitwalker@163.com" target="_blank" rel="noopener">waitwalker@163.com</a>）。为了保证问题能够及时有效地处理，请务必提交真实有效、完整清晰的材料，否则不予受理。请使用以下格式（包括各条款的序号）：<br>A、权利人对涉嫌侵权内容拥有商标权、著作权和/或其他依法可以行使权利的权属证明；如果举报人非权利人，请举报人提供代表企业进行举报的书面授权证明。<br>B、充分、明确地描述侵犯了权利人合法权益的内容，提供涉嫌侵权内容在狗圈儿上的具体页面地址，指明涉嫌侵权内容中的哪些内容侵犯了上述列明的权利人的合法权益；<br>C、权利人具体的联络信息，包括姓名、身份证或护照复印件（对自然人）、单位登记证明复印件（对单位）、通信地址、电话号码、传真和电子邮件；<br>D、在侵权举报中加入如下关于举报内容真实性的声明：<br>· 我本人为所举报内容的合法权利人；<br>· 我举报的发布在狗圈儿中的内容侵犯了本人相应的合法权益；<br>· 如果本侵权举报内容不完全属实，本人将承担由此产生的一切法律责任。<br>4、处理流程<br>出于网络社区的监督属性，并非所有申请都必须受理。狗圈儿自收到举报邮件七个工作日内处理完毕并给出回复。处理期间，不提供任何电话、邮件及其他方式的查询服务。<br>出现狗圈儿已经删除或处理的内容，但是百度、谷歌等搜索引擎依然可以搜索到的现象，是因为百度、谷歌等搜索引擎自带缓存，此类问题狗圈儿无权也无法处理，因此相关申请不予受理。<br>此为狗圈儿唯一的官方的侵权投诉渠道，暂不提供其他方式处理此业务。用户在狗圈儿中的商业行为引发的法律纠纷，由交易双方自行处理，与狗圈儿无关。<br>服务终止及暂停<br>任何引起其他用户反感的行为，包括但不限于利用狗圈儿平台发布广告或是垃圾信息，利用简信骚扰其他用户等，网站可随时行使暂停、收回、删除帐号的权利。</p><p>1、用户在狗圈儿发表的内容仅表明其个人的立场和观点，并不代表狗圈儿的立场或观点。作为内容的发表者，需自行对所发表内容负责，因所发表内容引发的一切纠纷，由该内容的发表者承担全部法律及连带责任。狗圈儿不承担任何法律及连带责任。<br>2、狗圈儿不保证网络服务一定能满足用户的要求，也不保证网络服务不会中断，对网络服务的及时性、安全性、准确性也都不作保证。<br>3、对于因不可抗力或狗圈儿不能控制的原因造成的网络服务中断或其它缺陷，狗圈儿不承担任何责任，但将尽力减少因此而给用户造成的损失和影响。</p><h3 id="协议修改"><a href="#协议修改" class="headerlink" title="协议修改"></a><strong>协议修改</strong></h3><p>1、根据互联网的发展和有关法律、法规及规范性文件的变化，或者因业务发展需要，狗圈儿有权对本协议的条款作出修改或变更，一旦本协议的内容发生变动，狗圈儿将会直接在狗圈儿网站上公布修改之后的协议内容，该公布行为视为狗圈儿已经通知用户修改内容。狗圈儿也可采用电子邮件或私信的传送方式，提示用户协议条款的修改、服务变更、或其它重要事项。<br>2、如果不同意狗圈儿对本协议相关条款所做的修改，用户有权并应当停止使用狗圈儿。如果用户继续使用狗圈儿，则视为用户接受狗圈儿对本协议相关条款所做的修改。</p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 狗圈儿隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bedrock Privacy Policy</title>
      <link href="/2019/04/13/Bedrock-Privacy-Policy/"/>
      <url>/2019/04/13/Bedrock-Privacy-Policy/</url>
      
        <content type="html"><![CDATA[<p><font size="3"><strong>1.我们尊重用户的隐私并对非法窃取用户隐私的行为予以坚决抵制.</strong></font></p><p><font size="3">We respect user privacy and resist those who illegally steal user privacy.</font><br><br></p><p><font size="3"><strong>2.Bedrock 仅收集用户数据以便高效运营，以及为您提供最佳的产品体验。 您的节点信息只会保存在本地,Bedrock 不会收集更不会上传这些信息.</strong></font></p><p><font size="3">Bedrock only collects user data to operate effectively and provide you the best experiences with our products.</font><br><br></p><p><font size="3"><strong>3.您的个人隐私和网络访问数据仅会存储在本地,从基础做起,我们会一步一步来完善功能,将来您可以把个人信息存到iCloud.</strong></font></p><p><font size="3">Your personal data and network request data will only be stored locally. Getting down to basics,we will improve our functions step by step. In the future, the function will be perfected, and you may save your personal information to iCloud.</font><br></p>]]></content>
      
      
      <categories>
          
          <category> 隐私政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bedrock隐私政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method解读</title>
      <link href="/2019/04/12/Method%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/12/Method%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道iOS程序的入口函数在main.其实mian只是苹果给我们的”直观能够感受”的入口,在执行main之前,编译器已经帮我们做了相当多的事情.具体可以参考objc-os.h文件.Objective-C的Runtime库也是在main之前创建好的.我们关注sel_init()</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL:"></a>SEL:</h3><pre><code>/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void){    static bool initialized = false;    if (initialized) return;    initialized = true;    // fixme defer initialization until an objc-using image is found?    environ_init();    tls_init();    static_init();    lock_init();    exception_init();    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);}</code></pre><p>接口我们可以到sel_init()调用栈:</p><pre><code>_|   _objc_init()  _|   _dyld_objc_notify_register    _|    map_images_nolock()       _|   sel_init()</code></pre><p>在map_images_nolock()方法中我们看到在sel_init()下面有arr_init():</p><pre><code>void arr_init(void){    AutoreleasePoolPage::init();    SideTableInit();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数就是我们熟悉的AutoreleasePoolPage的初始化和全局SideTable的初始化,这个以后再分析.这里我们看一下sel_init()所做的工作:</p><pre><code>/************************************************************************ sel_init* Initialize selector tables and register selectors used internally.**********************************************************************/void sel_init(size_t selrefCount){    // save this value for later    SelrefCount = selrefCount;#if SUPPORT_PREOPT    builtins = preoptimizedSelectors();    if (PrintPreopt  &amp;&amp;  builtins) {        uint32_t occupied = builtins-&gt;occupied;        uint32_t capacity = builtins-&gt;capacity;        _objc_inform(&quot;PREOPTIMIZATION: using selopt at %p&quot;, builtins);        _objc_inform(&quot;PREOPTIMIZATION: %u selectors&quot;, occupied);        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%u%%) hash table occupancy&quot;,                     occupied, capacity,                     (unsigned)(occupied/(double)capacity*100));        }#endif    // Register selectors used by libobjc#define s(x) SEL_##x = sel_registerNameNoLock(#x, NO)#define t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO)    mutex_locker_t lock(selLock);    s(load);    s(initialize);    t(resolveInstanceMethod:, resolveInstanceMethod);    t(resolveClassMethod:, resolveClassMethod);    t(.cxx_construct, cxx_construct);    t(.cxx_destruct, cxx_destruct);    s(retain);    s(release);    s(autorelease);    s(retainCount);    s(alloc);    t(allocWithZone:, allocWithZone);    s(dealloc);    s(copy);    s(new);    t(forwardInvocation:, forwardInvocation);    t(_tryRetain, tryRetain);    t(_isDeallocating, isDeallocating);    s(retainWeakReference);    s(allowsWeakReference);#undef s#undef t}</code></pre><p>我们可以看到一些常见系统内置方法分别调用__sel_registerName()这个方法:</p><pre><code>static SEL __sel_registerName(const char *name, bool shouldLock, bool copy){    SEL result = 0;    if (shouldLock) selLock.assertUnlocked();    else selLock.assertLocked();    if (!name) return (SEL)0;    result = search_builtins(name);    if (result) return result;    conditional_mutex_locker_t lock(selLock, shouldLock);    if (namedSelectors) {        result = (SEL)NXMapGet(namedSelectors, name);    }    if (result) return result;    // No match. Insert.    if (!namedSelectors) {        namedSelectors = NXCreateMapTable(NXStrValueMapPrototype,                                          (unsigned)SelrefCount);    }    if (!result) {        // 初始化sel_alloc        result = sel_alloc(name, copy);        // 将selector 插入到NXMapTable 表中        // fixme choose a better container (hash not map for starters)        NXMapInsert(namedSelectors, sel_getName(result), result);    }    return result;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这方法的作用是将selector注册到NXMapTable表中,如果selector不存在则调用selector初始化方法,然后将selector作为selector作为key,selector作为value存到NXMapTable哈希表中:</p><pre><code>static SEL sel_alloc(const char *name, bool copy){    selLock.assertLocked();    return (SEL)(copy ? strdupIfMutable(name) : name);}</code></pre><p>在objc.h文件中我们可以看到SEL的声明:</p><pre><code>/// An opaque type that represents a method selector.typedef struct objc_selector *SEL;</code></pre><p>至此我们可以理解了,SEL就是一个表示方法的selector指针,映射方法的名字.</p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP:"></a>IMP:</h3><pre><code>/// A pointer to the function of a method implementation.#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ );#elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);#endif</code></pre><p>从定义来看,IMP是一个指向实现函数的<strong>指针</strong>.IMP也是实现函数的入口,其和SEL的关系等以后将消息发送在细说.</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method:"></a>Method:</h3><p>method的声明结构:</p><pre><code>typedef struct method_t *Method;</code></pre><p>继续查看method_t的定义:</p><pre><code>struct method_t {    SEL name;    const char *types;    MethodListIMP imp;    struct SortBySELAddress :        public std::binary_function&lt;const method_t&amp;,                                    const method_t&amp;, bool&gt;    {        bool operator() (const method_t&amp; lhs,                         const method_t&amp; rhs)        { return lhs.name &lt; rhs.name; }    };};</code></pre><p>method_t中有两个我们熟悉的成员变量:SEL和MethodListIMP,看一下MethodListIMP:</p><pre><code>#if __has_feature(ptrauth_calls)// Method lists use process-independent signature for compatibility.// Method caches use process-dependent signature for extra protection.//   (fixme not yet __ptrauth(...) because of `stp` inline asm in objc-cache.mm)using MethodListIMP = IMP __ptrauth_objc_method_list_imp;using MethodCacheIMP =    StorageSignedFunctionPointer&lt;IMP, ptrauth_key_process_dependent_code&gt;;#elseusing MethodListIMP = IMP;using MethodCacheIMP = IMP;#endif</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodListIMP其实就是IMP,method可以理解为SEL(方法名称)和IMP(方法实现)相互对应的集合体.正常的情况一个SEL对应一个IMP,而SEL和IMP的绑定到运行时才确定的.</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是NSObject.h和runtime.h文件为我们提供的有关SEL,IMP和Method相关的接口及说明:</p><h4 id="runtime-h文件"><a href="#runtime-h文件" class="headerlink" title="runtime.h文件:"></a>runtime.h文件:</h4><h5 id="根据SEL获取实例Method指针"><a href="#根据SEL获取实例Method指针" class="headerlink" title="根据SEL获取实例Method指针"></a>根据SEL获取实例Method指针</h5><pre><code>// 获取Method声明OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// 获取Method实现/************************************************************************ class_getInstanceMethod.  Return the instance method for the* specified class and selector.**********************************************************************/Method class_getInstanceMethod(Class cls, SEL sel){    if (!cls  ||  !sel) return nil;    // This deliberately avoids +initialize because it historically did so.    // This implementation is a bit weird because it&#39;s the only place that    // wants a Method instead of an IMP.#warning fixme build and search caches    // Search method lists, try method resolver, etc.    lookUpImpOrNil(cls, sel, nil,                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);#warning fixme build and search caches    return _class_getMethod(cls, sel);}</code></pre><p>这里面调用了_class_getMethod()私有函数:</p><pre><code>/************************************************************************ _class_getMethod* fixme* Locking: read-locks runtimeLock**********************************************************************/static Method _class_getMethod(Class cls, SEL sel){    mutex_locker_t lock(runtimeLock);    return getMethod_nolock(cls, sel);}/************************************************************************ getMethod_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *getMethod_nolock(Class cls, SEL sel){    method_t *m = nil;    runtimeLock.assertLocked();    // fixme nil cls?    // fixme nil sel?    assert(cls-&gt;isRealized());    while (cls  &amp;&amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {        cls = cls-&gt;superclass;    }    return m;}</code></pre><p>这个函数内部调用的是getMethodNoSuper_nolock():</p><pre><code>static method_t *getMethodNoSuper_nolock(Class cls, SEL sel){    runtimeLock.assertLocked();    assert(cls-&gt;isRealized());    // fixme nil cls?    // fixme nil sel?    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),              end = cls-&gt;data()-&gt;methods.endLists();         mlists != end;         ++mlists)    {        method_t *m = search_method_list(*mlists, sel);        if (m) return m;    }    return nil;}</code></pre><p>查找方法的过程是先从本class的方法列表中查看是否存在,不存再在看父类递归这个过程( cls = cls-&gt;superclass).这个我们在以后讲消息发送,转发时在细看.</p><h5 id="根据SEL获取类Method指针"><a href="#根据SEL获取类Method指针" class="headerlink" title="根据SEL获取类Method指针"></a>根据SEL获取类Method指针</h5><pre><code>OBJC_EXPORT Method _Nullableclass_getClassMethod(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</code></pre><p>类对象的方法列表存放在元类中,所以获取类方法要去元类中查找,其在获取的时候参数已经指明元类:</p><pre><code>/************************************************************************ class_getClassMethod.  Return the class method for the specified* class and selector.**********************************************************************/Method class_getClassMethod(Class cls, SEL sel){    if (!cls  ||  !sel) return nil;    //这里cls获取的是元类    return class_getInstanceMethod(cls-&gt;getMeta(), sel);}</code></pre><h5 id="返回一个函数的实现指针"><a href="#返回一个函数的实现指针" class="headerlink" title="返回一个函数的实现指针:"></a>返回一个函数的实现指针:</h5><pre><code>OBJC_EXPORT IMP _Nullableclass_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</code></pre><p>其实现过程:</p><pre><code>IMP class_getMethodImplementation(Class cls, SEL sel){    IMP imp;    if (!cls  ||  !sel) return nil;    imp = lookUpImpOrNil(cls, sel, nil,                         YES/*initialize*/, YES/*cache*/, YES/*resolver*/);    // Translate forwarding function to C-callable external version    if (!imp) {        return _objc_msgForward;    }    return imp;}</code></pre><p>其内部我们可以看到两个主要的调用函数:lookUpImpOrNil()和_objc_msgForward.前面函数是获取SEL对应的IMP,其实现过程如下:</p><pre><code>/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst,                   bool initialize, bool cache, bool resolver){    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);    if (imp == _objc_msgForward_impcache) return nil;    else return imp;}// MARK: - 获取imp,先从缓存中查找imp,如果存在直接返回imp./************************************************************************ lookUpImpOrForward.* The standard IMP lookup.* initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known.*   If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use*   must be converted to _objc_msgForward or _objc_msgForward_stret.*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst,                       bool initialize, bool cache, bool resolver){    IMP imp = nil;    bool triedResolver = NO;    runtimeLock.assertUnlocked();    // Optimistic cache lookup    if (cache) {        imp = cache_getImp(cls, sel);        if (imp) return imp;    }    // runtimeLock is held during isRealized and isInitialized checking    // to prevent races against concurrent realization.    // runtimeLock is held during method search to make    // method-lookup + cache-fill atomic with respect to method addition.    // Otherwise, a category could be added but ignored indefinitely because    // the cache was re-filled with the old value after the cache flush on    // behalf of the category.    runtimeLock.lock();    checkIsKnownClass(cls);    if (!cls-&gt;isRealized()) {        realizeClass(cls);    }    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {        runtimeLock.unlock();        _class_initialize (_class_getNonMetaClass(cls, inst));        runtimeLock.lock();        // If sel == initialize, _class_initialize will send +initialize and        // then the messenger will send +initialize again after this        // procedure finishes. Of course, if this is not being called        // from the messenger then it won&#39;t happen. 2778172    } retry:    runtimeLock.assertLocked();    // 从缓存中尝试查找IMP    // Try this class&#39;s cache.    imp = cache_getImp(cls, sel);    if (imp) goto done;    // 从本类的方法列表中尝试查找IMP    // Try this class&#39;s method lists.    {        Method meth = getMethodNoSuper_nolock(cls, sel);        if (meth) {            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);            imp = meth-&gt;imp;            goto done;        }    }    // 从父类的方法列表中尝试查找IMP    // Try superclass caches and method lists.    {        unsigned attempts = unreasonableClassCount();        for (Class curClass = cls-&gt;superclass;             curClass != nil;             curClass = curClass-&gt;superclass)        {            // Halt if there is a cycle in the superclass chain.            if (--attempts == 0) {                _objc_fatal(&quot;Memory corruption in class list.&quot;);            }            // Superclass cache.            imp = cache_getImp(curClass, sel);            if (imp) {                if (imp != (IMP)_objc_msgForward_impcache) {                    // Found the method in a superclass. Cache it in this class.                    log_and_fill_cache(cls, imp, sel, inst, curClass);                    goto done;                }                else {                    // Found a forward:: entry in a superclass.                    // Stop searching, but don&#39;t cache yet; call method                    // resolver for this class first.                    break;                }            }            // Superclass method list.            Method meth = getMethodNoSuper_nolock(curClass, sel);            if (meth) {                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);                imp = meth-&gt;imp;                goto done;            }        }    }    // 如果以上过程都没有找到,尝试一次动态方法解析    // No implementation found. Try method resolver once.    if (resolver  &amp;&amp;  !triedResolver) {        runtimeLock.unlock();        _class_resolveMethod(cls, sel, inst);        runtimeLock.lock();        // Don&#39;t cache the result; we don&#39;t hold the lock so it may have        // changed already. Re-do the search from scratch instead.        triedResolver = YES;        goto retry;    }    // 如果方法解析也没有IMP,启动消息转发    // No implementation found, and method resolver didn&#39;t help.    // Use forwarding.    imp = (IMP)_objc_msgForward_impcache;    cache_fill(cls, sel, imp, inst); done:    runtimeLock.unlock();    return imp;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据SEL在缓存中如果没有找到IMP,则在本类的Method获取找IMP,如果没有找到去父类中查找.以上过程都没有找到IMP的话,启动一次方法解析,方法解析也没有IMP的话就启动消息转发.</p><h5 id="一个对象是否响应某个方法"><a href="#一个对象是否响应某个方法" class="headerlink" title="一个对象是否响应某个方法"></a>一个对象是否响应某个方法</h5><pre><code>// MARK: - 一个实例对象是否响应某个方法/** * Returns a Boolean value that indicates whether instances of a class respond to a particular selector. * * @param cls The class you want to inspect. * @param sel A selector. * * @return \c YES if instances of the class respond to the selector, otherwise \c NO. * * @note You should usually use \c NSObject&#39;s \c respondsToSelector: or \c instancesRespondToSelector: *  methods instead of this function. */OBJC_EXPORT BOOLclass_respondsToSelector(Class _Nullable cls, SEL _Nonnull sel)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 是否响应某个方法BOOL class_respondsToSelector(Class cls, SEL sel){    return class_respondsToSelector_inst(cls, sel, nil);}// MARK: - 是否响应某个方法,其内部是通过获取IMP是否存在来判断// inst is an instance of cls or a subclass thereof, or nil if none is known.// Non-nil inst is faster in some cases. See lookUpImpOrForward() for details.bool class_respondsToSelector_inst(Class cls, SEL sel, id inst){    IMP imp;    if (!sel  ||  !cls) return NO;    // Avoids +initialize because it historically did so.    // We&#39;re not returning a callable IMP anyway.    imp = lookUpImpOrNil(cls, sel, inst,                         NO/*initialize*/, YES/*cache*/, YES/*resolver*/);    return bool(imp);}</code></pre><p>其最终还是痛SEL是否有对应IMP来判断对象能否响应某个方法.</p><h5 id="获取一个类的方法列表"><a href="#获取一个类的方法列表" class="headerlink" title="获取一个类的方法列表"></a>获取一个类的方法列表</h5><pre><code>// MARK: - 获取一个类的方法列表/** * Describes the instance methods implemented by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. *  If outCount is NULL, the length is not returned. * * @return An array of pointers of type Method describing the instance methods *  implemented by the class—any instance methods implemented by superclasses are not included. *  The array contains *outCount pointers followed by a NULL terminator. You must free the array with free(). * *  If cls implements no instance methods, or cls is Nil, returns NULL and *outCount is 0. * * @note To get the class methods of a class, use \c class_copyMethodList(object_getClass(cls), &amp;count). * @note To get the implementations of methods that may be implemented by superclasses, *  use \c class_getInstanceMethod or \c class_getClassMethod. */OBJC_EXPORT Method _Nonnull * _Nullableclass_copyMethodList(Class _Nullable cls, unsigned int * _Nullable outCount)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个类所有实现的方法列表/************************************************************************ class_copyMethodList* fixme* Locking: read-locks runtimeLock**********************************************************************/Method *class_copyMethodList(Class cls, unsigned int *outCount){    unsigned int count = 0;    Method *result = nil;    if (!cls) {        if (outCount) *outCount = 0;        return nil;    }    mutex_locker_t lock(runtimeLock);    assert(cls-&gt;isRealized());    count = cls-&gt;data()-&gt;methods.count();    if (count &gt; 0) {        result = (Method *)malloc((count + 1) * sizeof(Method));        count = 0;        for (auto&amp; meth : cls-&gt;data()-&gt;methods) {            result[count++] = &amp;meth;        }        result[count] = nil;    }    if (outCount) *outCount = count;    return result;}</code></pre><h5 id="获取一个方法名称"><a href="#获取一个方法名称" class="headerlink" title="获取一个方法名称"></a>获取一个方法名称</h5><pre><code>// MARK: - 获取一个方法名称/** * Returns the name of a method. * * @param m The method to inspect. * * @return A pointer of type SEL. * * @note To get the method name as a C string, call \c sel_getName(method_getName(method)). */OBJC_EXPORT SEL _Nonnullmethod_getName(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法名称/************************************************************************ method_getName* Returns this method&#39;s selector.* The method must not be nil.* The method must already have been fixed-up.* Locking: none**********************************************************************/SELmethod_getName(Method m){    if (!m) return nil;    assert(m-&gt;name == sel_registerName(sel_getName(m-&gt;name)));    return m-&gt;name;}</code></pre><p>获取一个方法名字最终还是通过sel_registerName()来获取,也是我们最开始的部分sel_init()提到.</p><h5 id="获取一个方法的IMP"><a href="#获取一个方法的IMP" class="headerlink" title="获取一个方法的IMP"></a>获取一个方法的IMP</h5><pre><code>// MARK: - 获取一个方法的实现/** * Returns the implementation of a method. * * @param m The method to inspect. * * @return A function pointer of type IMP. */OBJC_EXPORT IMP _Nonnullmethod_getImplementation(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的IMPIMPmethod_getImplementation(Method m){    return m ? m-&gt;imp : nil;}</code></pre><p>通过直接Method中的imp成员变量</p><h5 id="获取一个方法的参数和返回值类型"><a href="#获取一个方法的参数和返回值类型" class="headerlink" title="获取一个方法的参数和返回值类型"></a>获取一个方法的参数和返回值类型</h5><pre><code>// MARK: - 获取一个方法的参数和返回值类型/** * Returns a string describing a method&#39;s parameter and return types. * * @param m The method to inspect. * * @return A C string. The string may be \c NULL. */OBJC_EXPORT const char * _Nullablemethod_getTypeEncoding(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的参数和返回值类型/************************************************************************ method_getTypeEncoding* Returns this method&#39;s old-style type encoding string.* The method must not be nil.* Locking: none**********************************************************************/const char *method_getTypeEncoding(Method m){    if (!m) return nil;    return m-&gt;types;}</code></pre><h5 id="获取一个方法的参数数量"><a href="#获取一个方法的参数数量" class="headerlink" title="获取一个方法的参数数量"></a>获取一个方法的参数数量</h5><pre><code>// MARK: - 获取一个方法参数数量/** * Returns the number of arguments accepted by a method. * * @param m A pointer to a \c Method data structure. Pass the method in question. * * @return An integer containing the number of arguments accepted by the given method. */OBJC_EXPORT unsigned intmethod_getNumberOfArguments(Method _Nonnull m)    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取一个方法的参数数量/************************************************************************ method_getNumberOfArguments.**********************************************************************/unsigned int method_getNumberOfArguments(Method m){    if (!m) return 0;    return encoding_getNumberOfArguments(method_getTypeEncoding(m));}</code></pre><h5 id="获取一个方法的返回值类型"><a href="#获取一个方法的返回值类型" class="headerlink" title="获取一个方法的返回值类型"></a>获取一个方法的返回值类型</h5><pre><code>// MARK: - 获取一个方法的返回值类型/** * Returns a string describing a method&#39;s return type. * * @param m The method to inspect. * * @return A C string describing the return type. You must free the string with \c free(). */OBJC_EXPORT char * _Nonnullmethod_copyReturnType(Method _Nonnull m)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法的返回值类型char * method_copyReturnType(Method m){    return encoding_copyReturnType(method_getTypeEncoding(m));}</code></pre><h5 id="获取方法某个参数的类型"><a href="#获取方法某个参数的类型" class="headerlink" title="获取方法某个参数的类型"></a>获取方法某个参数的类型</h5><pre><code>// MARK: - 获取方法某个参数的类型/** * Returns a string describing a single parameter type of a method. * * @param m The method to inspect. * @param index The index of the parameter to inspect. * * @return A C string describing the type of the parameter at index \e index, or \c NULL *  if method has no parameter index \e index. You must free the string with \c free(). */OBJC_EXPORT char * _Nullablemethod_copyArgumentType(Method _Nonnull m, unsigned int index)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法某个参数类型char * method_copyArgumentType(Method m, unsigned int index){    return encoding_copyArgumentType(method_getTypeEncoding(m), index);}</code></pre><h5 id="获取方法返回值类型"><a href="#获取方法返回值类型" class="headerlink" title="获取方法返回值类型"></a>获取方法返回值类型</h5><pre><code>// MARK: - 获取方法返回值类型/** * Returns by reference a string describing a method&#39;s return type. * * @param m The method you want to inquire about. * @param dst The reference string to store the description. * @param dst_len The maximum number of characters that can be stored in \e dst. * * @note The method&#39;s return type string is copied to \e dst. *  \e dst is filled as if \c strncpy(dst, parameter_type, dst_len) were called. */OBJC_EXPORT voidmethod_getReturnType(Method _Nonnull m, char * _Nonnull dst, size_t dst_len)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 获取方法返回值类型void method_getReturnType(Method m, char *dst, size_t dst_len){    encoding_getReturnType(method_getTypeEncoding(m), dst, dst_len);}</code></pre><h5 id="更新设置某个方法的IMP"><a href="#更新设置某个方法的IMP" class="headerlink" title="更新设置某个方法的IMP"></a>更新设置某个方法的IMP</h5><pre><code>// MARK: - 更新设置某个方法的IMP/** * Sets the implementation of a method. * * @param m The method for which to set an implementation. * @param imp The implemention to set to this method. * * @return The previous implementation of the method. */OBJC_EXPORT IMP _Nonnullmethod_setImplementation(Method _Nonnull m, IMP _Nonnull imp)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 更新设置某个方法IMPIMPmethod_setImplementation(Method m, IMP imp){    // Don&#39;t know the class - will be slow if RR/AWZ are affected    // fixme build list of classes whose Methods are known externally?    mutex_locker_t lock(runtimeLock);    return _method_setImplementation(Nil, m, imp);}// MARK: - 更新设置某个方法的IMP/************************************************************************ method_setImplementation* Sets this method&#39;s implementation to imp.* The previous implementation is returned.**********************************************************************/static IMP_method_setImplementation(Class cls, method_t *m, IMP imp){    runtimeLock.assertLocked();    if (!m) return nil;    if (!imp) return nil;    IMP old = m-&gt;imp;    m-&gt;imp = imp;    // Cache updates are slow if cls is nil (i.e. unknown)    // RR/AWZ updates are slow if cls is nil (i.e. unknown)    // fixme build list of classes whose Methods are known externally?    flushCaches(cls);    updateCustomRR_AWZ(cls, m);    return old;}</code></pre><p>先找到old imp,然后把old imp 替换成 new imp.</p><h5 id="交换两个方法的实现即交换两个方法的IMP"><a href="#交换两个方法的实现即交换两个方法的IMP" class="headerlink" title="交换两个方法的实现即交换两个方法的IMP"></a>交换两个方法的实现即交换两个方法的IMP</h5><pre><code>// MARK: - 交换两个方法的实现即交换两个方法的IMP/** * Exchanges the implementations of two methods. * * @param m1 Method to exchange with second method. * @param m2 Method to exchange with first method. * * @note This is an atomic version of the following: *  \code *  IMP imp1 = method_getImplementation(m1); *  IMP imp2 = method_getImplementation(m2); *  method_setImplementation(m1, imp2); *  method_setImplementation(m2, imp1); *  \endcode */OBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 交换两个方法的实现即交换两个方法的IMPvoid method_exchangeImplementations(Method m1, Method m2){    if (!m1  ||  !m2) return;    mutex_locker_t lock(runtimeLock);    IMP m1_imp = m1-&gt;imp;    m1-&gt;imp = m2-&gt;imp;    m2-&gt;imp = m1_imp;    // RR/AWZ updates are slow because class is unknown    // Cache updates are slow because class is unknown    // fixme build list of classes whose Methods are known externally?    flushCaches(nil);    updateCustomRR_AWZ(nil, m1);    updateCustomRR_AWZ(nil, m2);}</code></pre><h4 id="NSObject-h文件"><a href="#NSObject-h文件" class="headerlink" title="NSObject.h文件"></a>NSObject.h文件</h4><h5 id="执行某个方法"><a href="#执行某个方法" class="headerlink" title="执行某个方法"></a>执行某个方法</h5><p>执行某个方法,一般用于方法解析中动态添加方法,下面这几个方法功能类似:</p><pre><code>// MARK: - 执行某个方法 一般用于方法解析中动态添加方法- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;// MARK: -  执行某个方法 一般用于方法解析中动态添加方法- (id)performSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL))objc_msgSend)(self, sel);}- (id)performSelector:(SEL)sel withObject:(id)obj {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);}- (id)performSelector:(SEL)sel withObject:(id)obj1 withObject:(id)obj2 {    if (!sel) [self doesNotRecognizeSelector:sel];    return ((id(*)(id, SEL, id, id))objc_msgSend)(self, sel, obj1, obj2);}</code></pre><p>先判断这个方法是否存在doesNotRecognizeSelector(),不存在报错”unrecognized selector sent to instance”.然后调用了message.h中的消息发送函数.</p><h5 id="内省方法-是否响应某个方法"><a href="#内省方法-是否响应某个方法" class="headerlink" title="内省方法:是否响应某个方法"></a>内省方法:是否响应某个方法</h5><pre><code>// MARK: - 内省方法:是否响应某个方法- (BOOL)respondsToSelector:(SEL)aSelector;// MARK: - 是否响应某个方法- (BOOL)respondsToSelector:(SEL)sel {    if (!sel) return NO;    return class_respondsToSelector_inst([self class], sel, self);}// MARK: - 是否响应某个方法,其内部是通过获取IMP是否存在来判断// inst is an instance of cls or a subclass thereof, or nil if none is known.// Non-nil inst is faster in some cases. See lookUpImpOrForward() for details.bool class_respondsToSelector_inst(Class cls, SEL sel, id inst){    IMP imp;    if (!sel  ||  !cls) return NO;    // Avoids +initialize because it historically did so.    // We&#39;re not returning a callable IMP anyway.    imp = lookUpImpOrNil(cls, sel, inst,                         NO/*initialize*/, YES/*cache*/, YES/*resolver*/);    return bool(imp);}</code></pre><h5 id="一个实例对象是否响应某个方法"><a href="#一个实例对象是否响应某个方法" class="headerlink" title="一个实例对象是否响应某个方法"></a>一个实例对象是否响应某个方法</h5><pre><code>// MARK: - 一个对象是否响应某个方法+ (BOOL)instancesRespondToSelector:(SEL)aSelector;// MARK: - 一个对象是否响应某个方法+ (BOOL)instancesRespondToSelector:(SEL)sel {    if (!sel) return NO;    return class_respondsToSelector(self, sel);}</code></pre><h5 id="获取一个SEL对应的IMP"><a href="#获取一个SEL对应的IMP" class="headerlink" title="获取一个SEL对应的IMP"></a>获取一个SEL对应的IMP</h5><pre><code>// MARK: - 获取一个SEL对应的IMP- (IMP)methodForSelector:(SEL)aSelector;// MARK: - 获取一个SEL对应的IMP- (IMP)methodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return object_getMethodImplementation(self, sel);}</code></pre><h5 id="获取一个实例方法SEL对应的IMP"><a href="#获取一个实例方法SEL对应的IMP" class="headerlink" title="获取一个实例方法SEL对应的IMP"></a>获取一个实例方法SEL对应的IMP</h5><pre><code>// MARK: - 获取一个实例方法SEL对应的IMP+ (IMP)instanceMethodForSelector:(SEL)aSelector;// MARK: - 获取一个实例方法SEL对应的IMP+ (IMP)instanceMethodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return class_getMethodImplementation(self, sel);}</code></pre><h5 id="不能响应某个SEL"><a href="#不能响应某个SEL" class="headerlink" title="不能响应某个SEL"></a>不能响应某个SEL</h5><pre><code>// MARK: - 不能响应某个SEL,报错- (void)doesNotRecognizeSelector:(SEL)aSelector;// MARK: - 不能响应某个方法// Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel {    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;,                object_getClassName(self), sel_getName(sel), self);}</code></pre><h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>动态方法解析,一般用来给某个没有实现的方法添加一个实现;返回false时,执行消息转发流程</p><pre><code>// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// MARK: - 动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel {    return NO;}+ (BOOL)resolveInstanceMethod:(SEL)sel {    return NO;}</code></pre><h5 id="消息转发相关"><a href="#消息转发相关" class="headerlink" title="消息转发相关"></a>消息转发相关</h5><pre><code>// MARK: - 消息转发相关- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍了SEL,IMP,Method的定义和实现,以及系统为我们提供的常用API.这里面涉及到到向一个对象发送消息的流程及转发过程,这个会在以后的章节中讲到.<br></p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2019/04/11/%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/11/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>像栈一样,队列(queue)也是表.队列的操作操两端进行,一端插入,一端删除.</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><h4 id="入队-Enqueue-操作"><a href="#入队-Enqueue-操作" class="headerlink" title="入队(Enqueue)操作"></a>入队(Enqueue)操作</h4><p>入队是在队列的末尾插入元素.</p><h4 id="出队-Dequeue-操作"><a href="#出队-Dequeue-操作" class="headerlink" title="出队(Dequeue)操作"></a>出队(Dequeue)操作</h4><p>出队是移除队列的首元素.<br><img src="http://abc.waitwalker.cn/queue.jpg" alt="队列"></p><h3 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h3><p>队列的实现也相对简单,这里我们直接用数组来实现.</p><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><pre><code>// MARK: - 队列struct Queue&lt;T&gt; {    private(set) var elements:[T] = []    // MARK: - 构造函数    init() {    }}</code></pre><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h4><p>入队操作在数组的末尾插入元素</p><pre><code>/// enqueue操作    ///    /// - Parameter element: 入队元素    mutating func enqueue(element:T) -&gt; Void {        elements.append(element)    }</code></pre><h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p>出队操作移除数组的首元素</p><pre><code>/// dequeue操作    mutating func dequeue() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeFirst()    }</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2019/04/11/%E6%A0%88/"/>
      <url>/2019/04/11/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈(stack)是限制插入和删除只能在一端进行的表,该位置称为栈顶(top).对栈的基本操作有Push(压栈)和Pop(出栈).前者相当于插入,后者相当于删除栈顶元素.栈又叫做LIFO(后进先出)表.只有栈顶元素是可访问的<br><img src="http://abc.waitwalker.cn/stack.jpg" alt="stack"></p><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于栈是一个表,因此任何实现表的方法都能实现栈,其中有两个比较常用的实现方法:1)栈的链表实现;2)栈的数组实现</p><h4 id="1-栈的链表实现"><a href="#1-栈的链表实现" class="headerlink" title="1.栈的链表实现"></a>1.栈的链表实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈可以用单链表来实现,在栈顶插入元素来实现Push操作,通过对栈顶元素移除来实现Pop操作.</p><h5 id="1-1-栈的链表定义"><a href="#1-1-栈的链表定义" class="headerlink" title="1.1 栈的链表定义"></a>1.1 栈的链表定义</h5><pre><code>private(set) var nodeList:NodeList&lt;T&gt;?    // 是否为空    var isEmpty:Bool {        get {            return nodeList == nil ? true : false        }    }    // MARK: - 构造方法    init() {    }</code></pre><h5 id="1-2-push-压栈操作"><a href="#1-2-push-压栈操作" class="headerlink" title="1.2 push()压栈操作"></a>1.2 push()压栈操作</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为主要基于单链表来实现,所以压栈操作首先判断链表是否为空,为空先创建一个链表元素并将首元素添加到链表中;如果不为空,获取链表的最后一个节点,将最后一个节点的next指针指向压栈元素节点.</p><pre><code>/// 压栈操作    ///    /// - Parameter element: 压栈元素    func push(element:T) -&gt; Void {        if let node = nodeList {            let nodeLength = node.traverse(with: node)            let newNode = NodeList(val: element)            let lastNode = node.find(with: node, at: nodeLength - 1)            lastNode?.next = newNode        } else {            nodeList = NodeList(val: element)        }    }</code></pre><h5 id="1-3-top栈顶元素"><a href="#1-3-top栈顶元素" class="headerlink" title="1.3 top栈顶元素"></a>1.3 top栈顶元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取栈顶元素也就是获取链表的最后一个节点</p><pre><code>/// 获取栈顶元素    ///    /// - Returns: 栈顶元素    func top() -&gt; T? {        guard let nodeL = nodeList else { return nil }        let nodeLength = nodeL.traverse(with: nodeL)        if nodeLength &gt; 1 {            return nodeL.find(with: nodeL, at: nodeLength - 1)?.value        } else {            return nodeL.value        }    }</code></pre><h5 id="1-4-pop-移除栈顶元素"><a href="#1-4-pop-移除栈顶元素" class="headerlink" title="1.4 pop()移除栈顶元素"></a>1.4 pop()移除栈顶元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop操作判断链表长度是否大于1,大于1移除链表最后一个节点.</p><pre><code>/// 获取栈顶元素    ///    /// - Returns: 栈顶元素    func top() -&gt; T? {        guard let nodeL = nodeList else { return nil }        let nodeLength = nodeL.traverse(with: nodeL)        if nodeLength &gt; 1 {            return nodeL.find(with: nodeL, at: nodeLength - 1)?.value        } else {            return nodeL.value        }    }</code></pre><h4 id="2-栈的数组实现"><a href="#2-栈的数组实现" class="headerlink" title="2.栈的数组实现"></a>2.栈的数组实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组实现栈相对简单,Array已经帮我们实现了相关接口,不用自己去实现.这里不再详述了,直接贴出源码.</p><pre><code>// MARK: - 栈的数组实现struct StackA&lt;T&gt; {    private(set) var elements:[T] = []    /// isEmpty    var isEmpty:Bool{        get {            return elements.count == 0 ? true : false        }    }    /// top    var top:T? {        get {            return elements.count &gt; 0 ? elements.last : nil        }    }    // MARK: - 构造函数    init() {    }    /// push压栈操作    ///    /// - Parameter element: 压栈元素    mutating func push(element:T) -&gt; Void {        elements.append(element)    }    /// pop出栈操作    mutating func pop() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeLast()    }}</code></pre><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_mutating</title>
      <link href="/2019/04/11/Swift-mutating/"/>
      <url>/2019/04/11/Swift-mutating/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在swift中:struct,enum,class都可以定义方法和属性.但是struct和enum是值类型,值类型存储在栈区.class是引用类型,引用类型存在在堆区.</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型:"></a>值类型:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平时我们常用的数据类型Int,Double,String,Array,Set等都是用结构体实现的,即也是值类型.当我们赋值或者复制一个值类型时,Swift编译器会复制一个全新的实例,包括它的所有成员属性,每次复制都会产生一个单独的,没有数据共享的新实例.值类型的复制是深拷贝类型.</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型:"></a>引用类型:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用类型是隐式数据共享,复制一个引用类型时,Swift编译器将会复制实例的一个引用,但不包括实例的属性,当对一个引用类型进行多次复制时,每一份复制将共享一份数据,执行的是浅拷贝.</p><pre><code>struct Student {    var name:String = &quot;&quot;    var age:Int = 18    init(name:String, age:Int) {        self.name = name        self.age = age    }}class Teacher {    var name:String = &quot;&quot;    var age:Int = 18    init(name:String, age:Int) {        self.name = name        self.age = age    }}func printAddress(values:AnyObject...){        for value in values {            print(Unmanaged.passUnretained(value).toOpaque())        }        print(&quot;-----------------------------------------&quot;)    }        let stuA = Student(name: &quot;张三&quot;, age: 18)        let stuB = stuA        printAddress(values: stuA.name as AnyObject)        printAddress(values: stuB.name as AnyObject)        let tchA = Teacher(name: &quot;李四&quot;, age: 28)        let tchB = tchA        printAddress(values: tchA)        printAddress(values: tchB)// log:stuA 和 stuB0x000060000387b660-----------------------------------------0x000060000387c1a0-----------------------------------------tchA 和 tchB0x000060000366bcf0-----------------------------------------0x000060000366bcf0-----------------------------------------</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出stuA完全深拷贝了一份给stuB.</p><h3 id="mutating关键字"><a href="#mutating关键字" class="headerlink" title="mutating关键字"></a>mutating关键字</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。如果要在某个function中修改属性的值就必须要在这个function前使用mutating关键词.</p><pre><code>private(set) var elements:[T] = []    /// isEmpty    var isEmpty:Bool{        get {            return elements.count == 0 ? true : false        }    }    /// top    var top:T? {        get {            return elements.count &gt; 0 ? elements.last : nil        }    }    // MARK: - 构造函数    init() {    }    mutating func push(element:T) -&gt; Void {        elements.append(element)    }    mutating func pop() -&gt; Void {        guard elements.count &gt; 0 else {            return        }        elements.removeLast()    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift开发 </tag>
            
            <tag> mutating </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objc_object解读</title>
      <link href="/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是面向对象的语言.面向对象语言有一句话说:”万物皆对象”,这个”对象”从哪里来呢?下面从Runtime源码实现来进一步查看.</p><h3 id="一-objc-object声明相关"><a href="#一-objc-object声明相关" class="headerlink" title="一. objc_object声明相关"></a>一. objc_object声明相关</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先看runtime.h文件,这个文件相当于Runtime对外部提供的接口文件.包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明.当我们使用Xcode创建一个类的时候一般都是调用的这里.</p><pre><code>/**    Runtime对外提供的接口,包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明 **//* Types */#if !OBJC_TYPES_DEFINED/// 表示一个类中的方法/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// 表示类中的一个成员变量/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// 表示一个分类/// An opaque type that represents a category.typedef struct objc_category *Category;/// 表示一个属性/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;/// 类的声明结构struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>可以看到objc_class的结构声明中有isa指针,这个指针是Class类型,然后我们顺藤摸瓜,继续查找Class的定义来源.然后找到了objc-private.h文件,进入文件后我们看到结构体objc_class和objc_object的不完整声明如下:</p><pre><code>// MARK: - objc_class 和 objc_object 不完整声明struct objc_class;struct objc_object;</code></pre><p>接着是用typedef 将这两个类型取了两个熟悉的名字:Class指针和id指针:</p><pre><code>// MARK: - 将objc_class类型取名为Class指针类型;将objc_object类型取名为id指针类型typedef struct objc_class *Class;typedef struct objc_object *id;</code></pre><p><br><br>往下就是isa的声明union(联合体),isa_t中有两个初始化函数,两个成员变量,cls和bits,还有一个结构体成员.其中在不同的os平台,有不同的声明.</p><pre><code># if __arm64__#   define ISA_MASK        0x0000000ffffffff8ULL#   define ISA_MAGIC_MASK  0x000003f000000001ULL#   define ISA_MAGIC_VALUE 0x000001a000000001ULL#   define ISA_BITFIELD                                                      \      uintptr_t nonpointer        : 1;                                       \      uintptr_t has_assoc         : 1;                                       \      uintptr_t has_cxx_dtor      : 1;                                       \      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \      uintptr_t magic             : 6;                                       \      uintptr_t weakly_referenced : 1;                                       \      uintptr_t deallocating      : 1;                                       \      uintptr_t has_sidetable_rc  : 1;                                       \      uintptr_t extra_rc          : 19#   define RC_ONE   (1ULL&lt;&lt;45)#   define RC_HALF  (1ULL&lt;&lt;18)# elif __x86_64__#   define ISA_MASK        0x00007ffffffffff8ULL#   define ISA_MAGIC_MASK  0x001f800000000001ULL#   define ISA_MAGIC_VALUE 0x001d800000000001ULL#   define ISA_BITFIELD                                                        \      uintptr_t nonpointer        : 1;                                         \      uintptr_t has_assoc         : 1;                                         \      uintptr_t has_cxx_dtor      : 1;                                         \      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \      uintptr_t magic             : 6;                                         \      uintptr_t weakly_referenced : 1;                                         \      uintptr_t deallocating      : 1;                                         \      uintptr_t has_sidetable_rc  : 1;                                         \      uintptr_t extra_rc          : 8#   define RC_ONE   (1ULL&lt;&lt;56)#   define RC_HALF  (1ULL&lt;&lt;7)# else#   error unknown architecture for packed isa# endif// SUPPORT_PACKED_ISA#endif#if SUPPORT_INDEXED_ISA# if  __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)    // armv7k or arm64_32#   define ISA_INDEX_IS_NPI_BIT  0#   define ISA_INDEX_IS_NPI_MASK 0x00000001#   define ISA_INDEX_MASK        0x0001FFFC#   define ISA_INDEX_SHIFT       2#   define ISA_INDEX_BITS        15#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)#   define ISA_INDEX_MAGIC_MASK  0x001E0001#   define ISA_INDEX_MAGIC_VALUE 0x001C0001#   define ISA_BITFIELD                         \      uintptr_t nonpointer        : 1;          \      uintptr_t has_assoc         : 1;          \      uintptr_t indexcls          : 15;         \      uintptr_t magic             : 4;          \      uintptr_t has_cxx_dtor      : 1;          \      uintptr_t weakly_referenced : 1;          \      uintptr_t deallocating      : 1;          \      uintptr_t has_sidetable_rc  : 1;          \      uintptr_t extra_rc          : 7#   define RC_ONE   (1ULL&lt;&lt;25)#   define RC_HALF  (1ULL&lt;&lt;6)</code></pre><p>nonpointer: 标记此isa是否是tagged pointer优化后的isa.占用1bit.值为1说明是优化后的isa.具体参考<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">链接</a>,tagged pointer是对实例对象的优化,默认是true,并且是isClass的判断,这是我看源码的理解,不对请指正<br><br>has_assoc:标记object是否有关联对象,没有,释放更快<br><br>has_cxx_dtor:标记是否有西沟函数,没有,释放更快<br><br>shiftcls:类对象(Class,meta-Class对象)内存地址信息<br><br>magic:标记object是否初始化完成<br><br>weakly_refrenced:标记object是否有weak指针指向它<br><br>deallocating:标记object是否正在释放<br><br>has_sidetable_rc:标记object的extra_rc位数能否存的下object的引用计数,存不下即has_sidetable_rc=1,存在全局的SideTable里面<br><br>extra_rc:存储object的引用计数,存不下,存在全局的SideTable里面<br></p><p><strong>下面是object的完整声明:</strong></p><pre><code>// MARK: - object的完整声明struct objc_object {private:    // 私有成员变量: isa指针    isa_t isa;// 公有函数public:    // 通过这个函数获取不支持tagged pointer的类指针    // ISA() assumes this is NOT a tagged pointer object    Class ISA();    // 通过这个函数获取支持tagged pointer的类指针    // getIsa() allows this to be a tagged pointer object    Class getIsa();    // 以下几个函数是isa的初始化函数    // initIsa()用来初始化一个新的对象的isa    // initIsa() should be used to init the isa of new objects only.    // changeIsa 修改一个对象的isa    // If this object already has an isa, use changeIsa() for correctness.    // initInstanceIsa()用来初始化一个实例对象的isa    // initInstanceIsa(): objects with no custom RR/AWZ    // initClassIsa()用来初始化一个类对象的isa    // initClassIsa(): class objects    // initProtocolIsa()用来初始化一个protocol的isa    // initProtocolIsa(): protocol objects    // initIsa()还用来初始化其它类型对象的isa    // initIsa(): other objects    void initIsa(Class cls /*nonpointer=false*/);    void initClassIsa(Class cls /*nonpointer=maybe*/);    void initProtocolIsa(Class cls /*nonpointer=maybe*/);    void initInstanceIsa(Class cls, bool hasCxxDtor);    // changeIsa() should be used to change the isa of existing objects.    // If this is a new object, use initIsa() for performance.    Class changeIsa(Class newCls);    // tagged pointer 相关    bool hasNonpointerIsa();    bool isTaggedPointer();    bool isBasicTaggedPointer();    bool isExtTaggedPointer();    // 是否是Class    bool isClass();    // 关联对象相关    // object may have associated objects?    bool hasAssociatedObjects();    void setHasAssociatedObjects();    // weak指针相关    // object may be weakly referenced?    bool isWeaklyReferenced();    void setWeaklyReferenced_nolock();    // 对象是否有析构函数    // object may have -.cxx_destruct implementation?    bool hasCxxDtor();    // retain 和 release 操作对象的引用计数 声明函数    // Optimized calls to retain/release methods    id retain();    void release();    id autorelease();    // retain 和 release 操作对象的引用计数 实现函数    // Implementations of retain/release methods    id rootRetain();    bool rootRelease();    id rootAutorelease();    bool rootTryRetain();    bool rootReleaseShouldDealloc();    uintptr_t rootRetainCount();    // 释放销毁对象相关    // Implementation of dealloc methods    bool rootIsDeallocating();    void clearDeallocating();    void rootDealloc();// 私有函数 上面一些公有函数的调用函数private:    void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor);    // Slow paths for inline control    id rootAutorelease2();    bool overrelease_error();#if SUPPORT_NONPOINTER_ISA    // Unified retain count manipulation for nonpointer isa    id rootRetain(bool tryRetain, bool handleOverflow);    bool rootRelease(bool performDealloc, bool handleUnderflow);    id rootRetain_overflow(bool tryRetain);    bool rootRelease_underflow(bool performDealloc);    void clearDeallocating_slow();    // Side table retain count overflow for nonpointer isa    void sidetable_lock();    void sidetable_unlock();    void sidetable_moveExtraRC_nolock(size_t extra_rc, bool isDeallocating, bool weaklyReferenced);    bool sidetable_addExtraRC_nolock(size_t delta_rc);    size_t sidetable_subExtraRC_nolock(size_t delta_rc);    size_t sidetable_getExtraRC_nolock();#endif    // Side-table-only retain count    bool sidetable_isDeallocating();    void sidetable_clearDeallocating();    bool sidetable_isWeaklyReferenced();    void sidetable_setWeaklyReferenced_nolock();    id sidetable_retain();    id sidetable_retain_slow(SideTable&amp; table);    uintptr_t sidetable_release(bool performDealloc = true);    uintptr_t sidetable_release_slow(SideTable&amp; table, bool performDealloc = true);    bool sidetable_tryRetain();    uintptr_t sidetable_retainCount();#if DEBUG    bool sidetable_present();#endif};</code></pre><p>以上就是objc_object的具体声明结构,里面有许多值得深究的问题,也是接下来会继续关注的问题.</p><h3 id="二-实例对象的初始化"><a href="#二-实例对象的初始化" class="headerlink" title="二.实例对象的初始化"></a>二.实例对象的初始化</h3><h4 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1.alloc"></a>1.alloc</h4><p>下面我们来看一个对象的实例化过程:</p><pre><code>Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);</code></pre><p>上面代码时创建一个newClass类,并且用这个新类实例化一个newObject对象.查看一下alloc方法和init方法的调用栈,其中省略了中间过程:</p><pre><code>id _objc_rootAlloc(Class cls)└── static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)    └── id class_createInstance(Class cls, size_t extraBytes)        └── id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct, size_t *outAllocatedSize)            ├── size_t instanceSize(size_t extraBytes)            ├── void    *calloc(size_t, size_t)            └── inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</code></pre><p>其中NSObject.mm中对alloc的实现如下:</p><pre><code>+ (id)alloc {    return _objc_rootAlloc(self);}</code></pre><p>这里面调用了一个私有函数,返回一个id类型(objc_object)如下:</p><pre><code>id_objc_rootAlloc(Class cls){    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);}</code></pre><p>NSObject.mm对callAlloc()实现:</p><pre><code>// Call [cls alloc] or [cls allocWithZone:nil], with appropriate// shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){    if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) {        // No alloc/allocWithZone implementation. Go straight to the allocator.        // fixme store hasCustomAWZ in the non-meta class and        // add it to canAllocFast&#39;s summary        if (fastpath(cls-&gt;canAllocFast())) {            // No ctors, raw isa, etc. Go straight to the metal.            bool dtor = cls-&gt;hasCxxDtor();            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());            if (slowpath(!obj)) return callBadAllocHandler(cls);            obj-&gt;initInstanceIsa(cls, dtor);            return obj;        }        else {            // Has ctor or raw isa or something. Use the slower path.            id obj = class_createInstance(cls, 0);            if (slowpath(!obj)) return callBadAllocHandler(cls);            return obj;        }    }#endif    // No shortcuts available.    if (allocWithZone) return [cls allocWithZone:nil];    return [cls alloc];}</code></pre><p>其中有个class_createInstance()函数,这函数中会调用_class_createInstanceFromZone()函数:</p><pre><code>static __attribute__((always_inline))id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil){    if (!cls) return nil;    assert(cls-&gt;isRealized());    // Read class&#39;s info bits all at once for performance    bool hasCxxCtor = cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size = cls-&gt;instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (!zone  &amp;&amp;  fast) {        obj = (id)calloc(1, size);        if (!obj) return nil;        obj-&gt;initInstanceIsa(cls, hasCxxDtor);    }    else {        if (zone) {            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);        } else {            obj = (id)calloc(1, size);        }        if (!obj) return nil;        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj-&gt;initIsa(cls);    }    if (cxxConstruct &amp;&amp; hasCxxCtor) {        obj = _objc_constructOrFree(obj, cls);    }    return obj;}</code></pre><p>这里面有:1)instanceSize()是给对象分配内存空间:</p><pre><code>size_t instanceSize(size_t extraBytes) {    size_t size = alignedInstanceSize() + extraBytes;    if (size &lt; 16) size = 16;    return size;}uint32_t alignedInstanceSize() {    return word_align(unalignedInstanceSize());}uint32_t unalignedInstanceSize() {    assert(isRealized());    return data()-&gt;ro-&gt;instanceSize;}</code></pre><p>2)initIsa()初始化isa指针</p><pre><code>inline voidobjc_object::initIsa(Class cls){    initIsa(cls, false, false);}inline voidobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor){    assert(!isTaggedPointer());    // 不是tagged pointer    if (!nonpointer) {        isa.cls = cls;    } else {        assert(!DisableNonpointerIsa);        assert(!cls-&gt;instancesRequireRawIsa());        isa_t newisa(0);#if SUPPORT_INDEXED_ISA        assert(cls-&gt;classArrayIndex() &gt; 0);        newisa.bits = ISA_INDEX_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else        newisa.bits = ISA_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif        // This write must be performed in a single store in some cases        // (for example when realizing a class because other threads        // may simultaneously try to use the class).        // fixme use atomics here to guarantee single-store and to        // guarantee memory order w.r.t. the class index table        // ...but not too atomic because we don&#39;t want to hurt instantiation        isa = newisa;    }}</code></pre><h4 id="2-init"><a href="#2-init" class="headerlink" title="2.init"></a>2.init</h4><p>init()函数调用栈很简单,只是调用了_objc_rootInit()私有函数,并返回对象本身</p><pre><code>- (id)init {    return _objc_rootInit(self);}id_objc_rootInit(id obj){    // In practice, it will be hard to rely on this function.    // Many classes do not properly chain -init calls.    return obj;}</code></pre><p><strong>对象的初始化过程可以总结为分配内存空间并且初始化isa_t结构的过程.</strong></p><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="博客地址-amp-相关文章"><a href="#博客地址-amp-相关文章" class="headerlink" title="博客地址&amp;相关文章"></a>博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">https://blog.devtang.com/2014/05/30/understand-tagged-pointer/</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Extension</title>
      <link href="/2019/04/09/Swift-Extension/"/>
      <url>/2019/04/09/Swift-Extension/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift Extension 字面意思就是扩展.有点类似OC中Category,按照官方文档,Extension可以用来:</p><h3 id="1-添加计算型属性"><a href="#1-添加计算型属性" class="headerlink" title="1.添加计算型属性"></a>1.添加计算型属性</h3><p><strong>拓展一下:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算型属性:计算型属性不直接存储值,而是提供一个getter和setter来间接获取和设置属性值</p><pre><code>var name:Stringvar _name:String {set {name = newValue}get {return name}}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储型属性:用来存储一个变量或者常量</p><pre><code>var name:String = &quot;zhangsan&quot;let age:Int = 10</code></pre><pre><code>// MARK: - 扩展计算型属性extension UIView {    var x:CGFloat {        set{            self.frame.origin.x = newValue        }        get{           return self.frame.origin.x        }    }}</code></pre><h3 id="2-添加方法"><a href="#2-添加方法" class="headerlink" title="2.添加方法"></a>2.添加方法</h3><p><strong>扩展实例方法</strong></p><pre><code>// MARK: - 扩展实例方法    func size(height:CGFloat, width:CGFloat) -&gt; CGFloat {        return height * width    }</code></pre><p><strong>添加突变方法 - mutating method:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过extension添加的实例方法同样可以修改(modify)或突变(mutate)该实例本身，如果结构体和枚举定义的方法想要改变自身或自身的属性，那么该实例方法必须被标记为突变(mutating)的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的例子为Int类型添加了一个名为square的突变方法，它的作用是计算原始值的平方:</p><pre><code>extension Int {    mutating func square() {        self = self * self    }}</code></pre><h3 id="3-提供便利构造器"><a href="#3-提供便利构造器" class="headerlink" title="3.提供便利构造器"></a>3.提供便利构造器</h3><pre><code>// MARK: - 便利构造器    convenience init(info:[String:String]) {        self.init()// todo:    }</code></pre><h3 id="4-定义下标subscripts"><a href="#4-定义下标subscripts" class="headerlink" title="4.定义下标subscripts"></a>4.定义下标subscripts</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附属脚本可以定义在class,struct,enum中,可以认为是访问对象,集合或者序列的快捷方式,凌辱我们常用的通过所以访问数组中的值,array[index];通过key访问字典中的value,dict[key]等.</p><pre><code>// MARK: - 官方示例:计算某个整数第某位上的值extension Int {    subscript(digitIndex: Int) -&gt; Int {        var decimalBase = 1        for _ in 0..&lt;digitIndex {            decimalBase *= 10        }        return (self / decimalBase) % 10    }}746381295[0]// returns 5746381295[1]// returns 9746381295[2]// returns 2746381295[8]// returns 7</code></pre><h3 id="5-添加嵌套类型"><a href="#5-添加嵌套类型" class="headerlink" title="5.添加嵌套类型"></a>5.添加嵌套类型</h3><pre><code>extension Int {    enum Kind {        case negative, zero, positive    }    var kind: Kind {        switch self {        case 0:            return .zero        case let x where x &gt; 0:            return .positive        default:            return .negative        }    }}</code></pre><h3 id="6-实现遵守协议的方法"><a href="#6-实现遵守协议的方法" class="headerlink" title="6.实现遵守协议的方法"></a>6.实现遵守协议的方法</h3><pre><code>// MARK: - 实现遵守协议的方法extension UIView:UITableViewDataSource {    public func numberOfSections(in tableView: UITableView) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        &lt;#code#&gt;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Equable</title>
      <link href="/2019/04/09/Swift-Equable/"/>
      <url>/2019/04/09/Swift-Equable/</url>
      
        <content type="html"><![CDATA[<p>一般判断两个对象是否相等方法:<br><br>如果两个对象相等其hashValue一定相等,不能反过来倒推.<br><br>1)如果两个对象的hashValue不相等,则认为这两个对象一定不相等<br><br>2)如果两个对象的hashValue相等,则比较两个对象的指针和两对象的内容是否相等,如果相等,则认为这两个对象是相等的<br><br>Swift中一些数据类型Int,Double,Bool等均已遵守实现Equable协议,所以在使用的时候可以用”==”操作符直接比较两个变量就行.<br></p><p>如果有一些自定义类型需要比较,需要遵守Equable协议,并且重写 public static func == (lhs: Self, rhs: Self) -&gt; Bool方法.<br></p><pre><code>class Person {    var name:String?    var age:Int?    init(name:String,age:Int) {        self.name = name        self.age = age    }}extension Person:Equatable {    static func == (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age    }}let person1 = Person(name: &quot;zhangsan&quot;, age: 18)let person2 = Person(name: &quot;lisi&quot;, age: 20)print(person1==person2) //false</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/04/09/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/09/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="表的简单定义"><a href="#表的简单定义" class="headerlink" title="表的简单定义:"></a>表的简单定义:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将处理一般的形如A1,A2,A3,…An的表,称这个表的大小是N.我们称大小为0的表为空表.表是一种线性的数据结构集合.对于除空表外的任何表,我们称Ai+1是Ai的后继,Ai-1是Ai的前驱.</p><h2 id="表常见的操作"><a href="#表常见的操作" class="headerlink" title="表常见的操作:"></a>表常见的操作:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find返回关键字首次出现的位置例程,Delete删除某个关键字例程,Insert在某个位置插入例程,遍历等</p><h2 id="表的实现方式"><a href="#表的实现方式" class="headerlink" title="表的实现方式:"></a>表的实现方式:</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于表的所有操作都可以通过数组来实现,数组实现表有一定的局限性,数组的大小事先要指定;数组的插入和删除操作会对插入和删除以后的所有元素都要调整,这种时间复杂度最坏为O(n).但是数组的查找和遍历是线性时间复杂度,而查找某个位置上的元素时间复杂度仅为常数时间,这些可以算作数组的优势.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为插入和删除的运行时间以及表的大小还要事先已知,因此对于插入和删除操作比较多的情况,一般不用数组来实现表结构.</p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表由一系列不必在内存中相连的结构组成.每一个结构均含有表元素和指向包含该元素后继元的结构的指针,即next指针.最后一个结构的next指针指向NULL.遍历和查找某个元素链表的时间复杂度为线性时间,我们只要将一个指针传递到该表的第一个元素,然后用一些next指针穿越该表即可.而查找某个位置上的元素其优势不如数组效率高.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除操作可以将待删除结构前驱的next指针指向待删除结构的后继即可.插入操作需要先实例化创建一个结构,然后获取插入位置的结构的前驱,将其next指针指向新创建的结构,然后新创建的结构next指针指向插入位置结构后继.</p><h3 id="3-链表结构类型"><a href="#3-链表结构类型" class="headerlink" title="3.链表结构类型"></a>3.链表结构类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表分为单链表,双链表,循环链表,块链表等.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双链表比单链表多了一个previous指针,指向前驱.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环链表是将首尾连接起来,这种方式在单向和双向链表中皆可实现.要转换一个循环链表,你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点.再来看另一种方法,循环链表可以被视为“无头无尾”.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块状链表本身是一个链表,但是链表储存的并不是一般的数据,而是由这些数据组成的顺序表.每一个块状链表的节点,也就是顺序表,可以被叫做一个块.<br></p><p>[图片上传失败…(image-e79610-1554800955920)])</p><h4 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h4><pre><code>/// 节点元素的值var value:T/// 节点元素的next指针var next:NodeList?/// 链表节点元素的构造函数////// - Parameter val: 值init(val:T) {self.value = val}</code></pre><h4 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历链表用next指针穿越整个表,创建一个临时节点,把当前节点赋值给临时节点.如果当前节点不为nil,将当前节点的next赋值给临时节点.</p><pre><code>/// 遍历链表////// - Parameter nodeList: 链表/// - Returns: 链表长度func traverse(with nodeList:NodeList?) -&gt; Int {var nodeListLength:Int = 0var tmpNode = nodeListwhile tmpNode != nil {nodeListLength += 1tmpNode = tmpNode!.next}return nodeListLength}</code></pre><h4 id="根据给定索引查找对应节点的值"><a href="#根据给定索引查找对应节点的值" class="headerlink" title="根据给定索引查找对应节点的值"></a>根据给定索引查找对应节点的值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找例程还是基于遍历思想,用next指针穿越.如果当前节点不为空,比较当前索引与指定索引事都相等,相等返回当前节点的值;不相等则递增当前索引并且将当前节点的后继赋值给当前节点,直到当前索引与指定索引相等.</p><pre><code>/// 根据指定索引查找某个链表节点的值////// - Parameters:/// - nodeList: 链表/// - index: 要查询的节点/// - Returns: 某个索引节点的值func find(with nodeList:NodeList?, index:Int) -&gt; T? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if currentIndex == index {return tmpNode?.value}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="根据指定值查找某个链表节点的索引"><a href="#根据指定值查找某个链表节点的索引" class="headerlink" title="根据指定值查找某个链表节点的索引"></a>根据指定值查找某个链表节点的索引</h4><pre><code>/// 根据指定值查找某个链表节点的索引////// - Parameters:/// - nodeList: 链表/// - value: 值/// - Returns: 值对应节点的索引func find(with nodeList:NodeList?, value:T?) -&gt; Int? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if tmpNode?.value == value {return currentIndex}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="在指定位置插入新的节点"><a href="#在指定位置插入新的节点" class="headerlink" title="在指定位置插入新的节点"></a>在指定位置插入新的节点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先判断当前链表是否存在,然后获取插入位置的前一个节点previousN,把previousN的后继赋值给插入节点的next指针;把插入节点赋值给previousN的next指针;</p><pre><code>/// 在链表指定位置插入新的节点并返回新的链表////// - Parameters:/// - nodeList: 链表/// - node: 待插入节点/// - index: 插入位置/// - Returns: 新的链表func insert(with nodeList:NodeList?, node:NodeList, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return node }if traverse(with: nodeL) &lt;= index {return node}var previousN:NodeList?if index != 0 {previousN = nodeL.find(with: nodeL, at: index - 1)node.next = previousN!.nextpreviousN!.next = nodereturn nodeL} else {node.next = nodeLreturn node}}</code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除指定位置的节点先要找到当前节点currentN和当前节点的前驱previousN,然后把previousN的next指针指向currentN的后继.</p><pre><code>/// 删除指定位置的节点并返回新的列表////// - Parameters:/// - nodeList: 链表/// - index: 待删除的位置/// - Returns: 删除后的链表func delete(with nodeList:NodeList?, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return nil }if nodeL.traverse(with: nodeL) &lt;= index {return nodeL}if index == 0 {return nodeL.next}let previousN = nodeL.find(with: nodeL, at: index - 1)let currentN = nodeL.find(with: nodeL, at: index)previousN?.next = currentN?.nextreturn nodeL}</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Swift </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime源码编译</title>
      <link href="/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是基于c语言的封装,使C语言具有了面向对象的能力.OC的本质最终还是转换c语言来执行,而这个转换的过程是通过Runtime这个运行时库来完成的.平常我们只需要写面对对象的OC代码,不用太关心一些底层转换原理及过程.但是有些情况.比如需要动态给一个类添加方法,添加成员变量,添加协议,没有实现方法的报错解析定位等,就需要了解这个底层实现来更好的解决实际开发中遇到的问题.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文也是对之前编译查看的Runtime源码的一个复习过程,主要有以下几步:</p><h3 id="一-下载源码及相关依赖"><a href="#一-下载源码及相关依赖" class="headerlink" title="一.下载源码及相关依赖"></a>一.下载源码及相关依赖<br></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果开源网站:<a href="http://opensource.apple.com/" target="_blank" rel="noopener">http://opensource.apple.com/</a>,其为我们提供了Runtime的实现源码objc4,这个objc4有多个版本,版本号越大说明是最新源码.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-131232ef2da1515f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果开源平台"></p><h4 id="1-下载objc4源码"><a href="#1-下载objc4源码" class="headerlink" title="1.下载objc4源码"></a>1.下载objc4源码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先打开苹果开源网站,可以看到苹果针对不同的设备平台有不同的开源项目已经对应的系统版本,找到对应的平台对应的版本点击下载objc4源码,本文依赖的是objc4-750版本.也可以在<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/</a>上面搜索所有开源项目源码的压缩包.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fbed6e632659dcff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc4源码"></p><h4 id="2-下载objc4相关依赖库"><a href="#2-下载objc4相关依赖库" class="headerlink" title="2.下载objc4相关依赖库"></a>2.下载objc4相关依赖库</h4><p>objc4相关依赖库:Libc，dyld，libauto，libclosure，libdispatch，libpthread，xnu.这些依赖库中包含了Runtime源码库中需要的一些文件.</p><h4 id="3-解压缩所有下载的压缩包库"><a href="#3-解压缩所有下载的压缩包库" class="headerlink" title="3.解压缩所有下载的压缩包库."></a>3.解压缩所有下载的压缩包库.</h4><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fabaa6bd03263beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码解压后"></p><h3 id="二-编译-amp-错误解决"><a href="#二-编译-amp-错误解决" class="headerlink" title="二.编译&amp;错误解决"></a>二.编译&amp;错误解决<br></h3><h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境:"></a>1.环境:</h4><p>target platform:<strong>macOS</strong><br><br>macOS:<strong>10.14</strong><br><br>Xcode:<strong>10.1</strong><br></p><h4 id="2-遇到的错误-amp-解决"><a href="#2-遇到的错误-amp-解决" class="headerlink" title="2.遇到的错误&amp;解决"></a>2.遇到的错误&amp;解决</h4><p><strong>1)error: The i386 architecture is deprecated. You should update your ARCHS build setting to remove the i386 architecture. (in target ‘objc’)</strong><br><br>解决:找target对应编译设置(Build Settings)-&gt;CPU架构(Architecture)-&gt;标准(Standard arcgutectures)<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-bebc4c3e29d47f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误1"><br><strong>2)在objc-os.h头文件中报’sys/reason.h’ file not found错误</strong><br><br>解决:工程目录下创建include/sys目录,在编译设置(Build Settings里面搜索,Header Search Paths,然后将include索引添加进去),然后在之前下载的依赖包中搜索reason.h头文件,复制到include/sys目录下<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-149cea545b66f79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误2"><br><strong>3)在objc-os.h头文件中报’mach-o/dyld_priv.h’ file not found错误</strong><br><br>解决:同上一步,创建include/mach-o目录,复制dyld_priv.h头文件到相应目录<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7a009d4875664966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误3"><br><strong>4)在objc-os.h头文件中报’os/lock_private.h’ file not found错误</strong><br><br>解决:这个文件并没有再我们下载的依赖库中,需要去开源官网下载,然后操作同上一步<br><br><strong>5)以下是遇到的类似问题:</strong><br><br>‘os/base_private.h’ file not found;<br><br>‘pthread/tsd_private.h’ file not found;<br><br>‘System/machine/cpu_capabilities.h’ file not found;<br><br>‘os/tsd.h’ file not found;<br><br>‘pthread/spinlock_private.h’ file not found;<br><br>‘System/pthread_machdep.h’ file not found;<br><br>‘CrashReporterClient.h’ file not found;这个需要在编译设置(Build Settings添加宏变量Build Settings-&gt;Preprocessor Macros中加入：LIBC_NO_LIBCRASHREPORTERCLIENT)<br><br>‘Block_private.h’ file not found;<br><br>‘objc-shared-cache.h’ file not found;<br><br>‘isa.h’ file not found;<br><br>‘_simple.h’ file not found;<br><br>在objc-errors.mm文件中报:Use of undeclared identifier ‘CRGetCrashLogMessage’错误;<br><br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7730fb32289af992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误5"><br><strong>6)链接时候错误:</strong><br><br>ld: can’t open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/<br>Developer/SDKs/MacOSX10.14.sdk/AppleInternal/OrderFiles/libobjc.order<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br><br>解决:将Build Settings-&gt;Linking-&gt;Order File改为工程根目录下的libobjc.order，即：$(SRCROOT)/libobjc.order。<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-81be9877600720d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误6"><br><strong>7)编译脚本错误</strong><br><br>xcodebuild: error: SDK “macosx.internal” cannot be located.<br>xcrun: error: unable to find utility “clang++”, not a developer tool or in PATH<br><br>解决:把Target-objc的Build Phases-&gt;Run Script(markgc)里的内容macosx.internal改为macosx，这里猜测macosx.internal为苹果内部的macosx<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fe07a0f8d034da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误7"><br><strong>8)error: no such public header file: ‘/tmp/objc.dst/usr/include/objc/ObjectiveC.apinotes’错误</strong><br><br>解决:把Text-Based InstallAPI Verification Model里的值改为Errors Only<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-0bd60bd7502eb574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误8"></p><h4 id="3-编译成功"><a href="#3-编译成功" class="headerlink" title="3.编译成功"></a>3.编译成功</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决以上错误后,再次编译应该基本Succeeded.<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-d6481492106e77dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功"><br></p><h3 id="三-调试"><a href="#三-调试" class="headerlink" title="三.调试"></a>三.调试<br></h3><h4 id="1-创建调试target"><a href="#1-创建调试target" class="headerlink" title="1.创建调试target"></a>1.创建调试target</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文编译针对的是macOS平台,可以创建一个macOS app或者一个 Command Line Tool 来调试.这里我们就创建一个Command Line Tool target:<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-5b9356137395b41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug target"></p><h4 id="2-编写代码调试"><a href="#2-编写代码调试" class="headerlink" title="2.编写代码调试"></a>2.编写代码调试</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新创建一个class,命名为newClass,打印出class name.可以查看调用栈,确实调用的是我们编译后的Runtime库:</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/message.h&gt;#import &lt;objc/runtime.h&gt;int main(int argc, const char * argv[]) {    @autoreleasepool {        Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);    }    return 0;}</code></pre><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-ff32f2b6e67bfb93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_1"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-41cd2b1e03f16de5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_2"></p><h3 id="四-编译后源码库"><a href="#四-编译后源码库" class="headerlink" title="四.编译后源码库"></a>四.编译后源码库</h3><h3 id="编译后源码库"><a href="#编译后源码库" class="headerlink" title="编译后源码库"></a>编译后源码库</h3><p><strong>编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a>, 如果对你有帮助,请给一个star吧!</strong></p><h3 id="五-博客地址-amp-相关文章"><a href="#五-博客地址-amp-相关文章" class="headerlink" title="五.博客地址&amp;相关文章"></a>五.博客地址&amp;相关文章</h3><p><strong>博客地址:</strong> <a href="https://waitwalker.github.io/">https://waitwalker.github.io/</a></p><p>系列文章:</p><p><a href="https://waitwalker.github.io/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">1. Runtime源码编译</a></p><p><a href="https://waitwalker.github.io/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/">2. objc_object解读</a></p><p><a href="https://waitwalker.github.io/2019/04/12/Method%E8%A7%A3%E8%AF%BB/">3. Method解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Class%E8%A7%A3%E8%AF%BB/">4. Class解读</a></p><p><a href="https://waitwalker.github.io/2019/04/15/Ivar-objc-property-t-Protocol%E8%A7%A3%E8%AF%BB/">5. Ivar objc_property_t Protocol解读</a></p><p><a href="https://waitwalker.github.io/2019/04/18/Block%E8%A7%A3%E8%AF%BB/">6. Block解读</a></p><p><a href="http://waitwalker.cn/2019/04/22/Retain-Release解读/" target="_blank" rel="noopener">7. Retain&amp;Release解读</a></p><p><a href="http://waitwalker.cn/2019/04/23/Autorelease解读/" target="_blank" rel="noopener">8. Autorelease解读</a></p><p><a href="http://waitwalker.cn/2019/04/24/Weak解读/" target="_blank" rel="noopener">9. Weak解读</a></p><p><a href="http://waitwalker.cn/2019/04/25/msgSend-解读/" target="_blank" rel="noopener">10. msgSend()解读</a></p><h3 id="六-参考文献"><a href="#六-参考文献" class="headerlink" title="六.参考文献"></a>六.参考文献</h3><p><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="noopener">https://pewpewthespells.com/blog/buildsettings.html</a><br><br><a href="https://blog.csdn.net/wotors/article/details/52489464" target="_blank" rel="noopener">https://blog.csdn.net/wotors/article/details/52489464</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> iOS </tag>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中Objective-C和Swift混编及第三方框架相互调用</title>
      <link href="/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
      <url>/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将详细介绍一下OC和swift混编问题,其中涉及两大部分:1)oc项目中混编swift的实现; 2)oc或者swift第三库的导入及使用.</p><p>#1 oc项目中混编swift<br>在oc项目中想要使用swift,并且实现相互调用,需要一些基本的设置,桥接文件也是必须得.</p><p>#1. 1 基本设置支持swift<br>在bulid setting中找到 Packaging 下的 define module,将是否定义模块布尔值改成YES,这样OC就可以支持swift了.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-a50523996ab98cb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="define module.png"></p><p>#1. 2 创建桥接文件<br>桥接文件可以在你创建swift文件的时候Xcode自动生成,也可以自己手动创建,手动创建也就是一个头文件(.h文件).<br>这里需要说明一点的是,在oc项目中创建的swift文件必须都要继承自NSObject基类,而你自己想要创建的一些类可以这样来创建:</p><p>####创建步骤1<br><img src="http://upload-images.jianshu.io/upload_images/1715253-6cacd2bc47564e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>####创建步骤2<br><img src="http://upload-images.jianshu.io/upload_images/1715253-fd2a1b324f032568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><p>####创建步骤3<br>这里选择Create Bridging Header,如果不选的话,那就自己手动创建,然后指定索引位置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-e88dda48a82bc616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>####创建步骤4<br><img src="http://upload-images.jianshu.io/upload_images/1715253-19219fab149a7ca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>第三步中如果没有创建桥接文件的话,手动创建一个桥接文件,然后build setting 中搜索 Objective-C Bridging Header,将你手动创建的桥接文件路径输入进去</p><p>####桥接文件设置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-b9b8484bfd32bc58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接文件设置"></p><p>#1.3 swift中调用oc文件<br>现在基本上可以实现swift调用oc中代码了,首先在桥接文件中导入你想在swift中用到的oc类</p><p>####导入oc类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1228e43af95e8399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入oc类"></p><p>####使用oc中的类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-2b410f5097f1786c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用oc中的类"></p><p>#1. 4 oc中调用swift文件<br><img src="http://upload-images.jianshu.io/upload_images/1715253-25d7b46b350c3dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="oc中调用swift文件"></p><p>#2 oc和swift第三方库的使用<br>如果你的项目用cocoapods来管理你使用的第三方库,并且OC项目中已经集成了多个第三方库,那么这时你想在导入swift编写的第三方库,这时你不能用cocoapods管理第三方库了,因为Swift连接时不支持静态库,cocoapods也在其Podfile中有说明:</p><h1 id="Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks"><a href="#Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks" class="headerlink" title="Uncomment the next line if you’re using Swift or would like to use dynamic frameworks"></a>Uncomment the next line if you’re using Swift or would like to use dynamic frameworks</h1><h1 id="use-frameworks"><a href="#use-frameworks" class="headerlink" title="use_frameworks!"></a>use_frameworks!</h1><p>翻译过来就是:如果你想使用swift或者动态库,就把下面一行注释打开<br>然而打开后你是编译不过去的,这时需要手动导入swift库<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1910c75b87225c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用swift或者动态库使用use_frameworks"></p><p>下面手动导入Alamofire作为例子:</p><p>##1)首先下载Alamofire项目源码,解压<br><img src="http://upload-images.jianshu.io/upload_images/1715253-cc75cc2e87dd1875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alamofire项目源码"><br>可以删除多余的不需要的文件,比如Example文件夹,等等</p><p>##2)将Alamofire项目整个拖到你的项目中<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d0e942f8f731ffc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拖到自己项目中"></p><p>##3)在Embedded Binaries中添加Alamofire.framework<br><img src="http://upload-images.jianshu.io/upload_images/1715253-8007cc13803cec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Embedded Binaries中添加Alamofire.framework"></p><p>这样就可以cocoapods管理OC第三方库,swift第三方库手动管理,实现不同第三方框架的调用.</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
            <tag> 第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--tableView优化</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者基于之前自己所写的Swift项目–仿照推特客户端用纯Swift写的一个项目,目前已经公开放在GitHub上(<strong><em><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a></em></strong>); 接口用Python写的几个(<strong><em><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a></em></strong>),目前所实现的功能是登录,注册,发推,首页列表等功能,其他页面都是一些假数据.这里不主要分析项目了,有时间在详细说一下.本文的主要重点是说说自己对性能调优–tableView控件优化的一点理解,有些问题理解的不是很透彻,希望大家能多给些意见,建议,谢谢.下图是整个项目的总览(文章中多是gif动态,尺寸较大,使用流量看得慎重):<br><img src="https://upload-images.jianshu.io/upload_images/1715253-360caafd286f9f10.gif?imageMogr2/auto-orient/strip" alt="项目总览1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-35ff9103000752d7.GIF?imageMogr2/auto-orient/strip" alt="项目总览2.GIF"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>有一句话说:过早的优化是万恶之源, 过早并不是开发过程的早期，而是在还没弄清楚业务需求的情形下去做所谓的优化,有时候会适得其反——费时、费力、不讨好。正确的方法是，先有质量地实现你的需求，写够测试用例，然后做profile去找到性能的瓶颈，考虑究竟哪些地方应该优化，应该如何优化，哪些不应该优化.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-0e7f39942a7a6c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章结构.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者对一些显示的垂直信号,水平信号原理不是了解,大家如果想深入了解的可以查一下相关资料,相关大神也有总结,或许从硬件底层优化可能效果会更好.造成tableView卡顿的原因,从硬件上来说无非就两个,一个是CPU原因,一个是GPU原因.如果CPU核数较多,并发处理问题的能力也就越强,处理大量计算也不在话下;如果GPU显存够大,渲染能力足够强,处理复杂图形界面也就得心应手.但是,硬件的配置是有限度的,我们的目标是在有限度的硬件上,让其发挥最大限度的作用.这个也就是造成tableView卡顿的程序原因(软件原因)–卡住了主线程,本文将主要讨论是从程序角度讨论怎么优化tableView问题.</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最基本的就是减少cell的自定义类型,重用cell,每次只绘制屏幕显示cell的数量,其它cell从缓存中取.这些基础大家应该比我了解,这里不再陈述了.</p><h2 id="1-减轻CPU负荷"><a href="#1-减轻CPU负荷" class="headerlink" title="1. 减轻CPU负荷"></a>1. 减轻CPU负荷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道CPU的主要负责快速调度任务,大量计算工作,所以在tableView快速滚动的过程中让CPU的计算量降低是优化应该考虑的方向.下面总结了三个方面来尽可能的降低CPU计算:</p><h3 id="1-1提前计算好cell的高度-缓存在相应的数据源模型中"><a href="#1-1提前计算好cell的高度-缓存在相应的数据源模型中" class="headerlink" title="1.1提前计算好cell的高度,缓存在相应的数据源模型中"></a>1.1提前计算好cell的高度,缓存在相应的数据源模型中</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都已经知道tableView的代理回调方法中,先调用的是返回cell高度的方法,然后在返回实例化cell的方法.我们可以在返回cell高度时,提前计算好cell的高度,缓存到数据源模型中.例如:<em>MTTHomeModel</em>对应的是首页cell的数据模型,我们可以看到下面两个变量,是来存储cell的高度和内容高度的,:</p><pre><code>var cellHeight:CGFloat?var contentHeight:CGFloat?</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获取数据后台数据的时候,把cell高度计算出来,缓存起来:</p><pre><code>homeModel.contentHeight  = self.calculateTextHeight(text: homeModel.contentTextString!) + 150if(homeModel.retwitterType?.count)! &gt; Int(0){    homeModel.cellHeight = 255 + homeModel.contentHeight! - 150} else{    homeModel.cellHeight = 230 + homeModel.contentHeight! - 150 + 15}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在返回cell高度的方法中,直接读取缓存的高度,而不需要在重新计算了.</p><pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat    {        if self.homeDataArray != nil        {            let homeModel = homeDataArray![indexPath.row]            return homeModel.cellHeight!        } else        {            return 300        }    }</code></pre><h3 id="1-2-尽可能的降低storyboard-xib等使用度"><a href="#1-2-尽可能的降低storyboard-xib等使用度" class="headerlink" title="1.2 尽可能的降低storyboard,xib等使用度"></a>1.2 尽可能的降低storyboard,xib等使用度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前看到一些大家分享的相关资料,通过Interface知道xib或者storyboard本身就是一个xml文件,添加删除控件必然中间多了一个encode/decode过程,增加了cpu的计算量.并且 还要避免臃肿的 XIB 文件,因为XIB文件在主线程中进行加载布局.当用到一些自定义View或者XIB文件时,XIB的加载会把所有内容加载进来,如果XIB里面的一些控件并不会用到,这就可能造成一些资源的消耗浪费.网上有说:Storyboard 没这个问题,只会按需加载,这个作者还没有去考证.</p><h3 id="1-3-滑动过程中尽量减少重新布局"><a href="#1-3-滑动过程中尽量减少重新布局" class="headerlink" title="1.3 滑动过程中尽量减少重新布局"></a>1.3 滑动过程中尽量减少重新布局</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局就是给控件添加约束,约束最终还是转换成frame.所以,在满足业务需求情况下,如果图层层次较为复杂,要尽量减少自动布局约束,转为手动计算布局,大量的约束重叠也会增加cpu的计算量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者在获取到数据源时,每次都重新布局控件,这个也是一个重要开销,也是接下来需要优化的方向.</p><pre><code>private funclayoutSubview(homeModel:MTTHomeModel) -&gt; Void{       topLineView?.snp.makeConstraints({ (make) in           make.left.right.top.equalTo(0)           make.height.equalTo(0.3)       })}</code></pre><h2 id="2-不要阻塞主线程"><a href="#2-不要阻塞主线程" class="headerlink" title="2. 不要阻塞主线程"></a>2. 不要阻塞主线程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>UIKit的工作基本上都是在主线程上进行,界面绘制,用户输入响应等等.当所有的代码逻辑都放在主线程时,某些耗时任务可能会卡住主线程造成程序无法响应,流畅度降低等问题;在主线程中绘制大量界面图层,网络I/O,磁盘I/O等都可以造成界面卡顿现象.</strong></p><p>下面我们通过Xcode自带的调试工具Instruments来看看项目界面的流畅度,及其一些建议,Instruments给我提供了各种各样的调试查看工具,下面简单介绍一下:<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)Blank: 创建一个空的模板,可以从Library库中添加其他模板.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Activity Monitor: 监控进程级别的CPU,内存,磁盘,网络使用情况,可以得到你的应用程序在手机运行时总共占用的内存大小.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)Allocations: 跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史,可以检测每一个堆对象的分配内存情况.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Cocoa Layout : 观察NSLayoutConstraint对象的改变,帮助我们判断什么时间什么地点的constraint是否合理.观察约束变化,找出布局代码的问题所在.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5)Core Animation: 这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6)CoreData: 这个模块跟踪Core Data文件系统活动.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7)Counters : 收集使用时间或基于事件的抽样方法的性能监控计数器(PMC)事件.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8)Energy Log: 耗电量监控.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9)File Activity: 检测文件创建,移动,变化,删除等.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10)Leak: 一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11)Metal System Trace: Metal API是apple 2014年在ios平台上推出的高效底层的3D图形API,它通过减少驱动层的API调用CPU的消耗提高渲染效率.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12)Network: 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13)SceneKit: 3D性能状况分析.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14)System Trace: 系统跟踪,通过显示当前被调度线程提供综合的系统表现,显示从用户到系统的转换代码通过两个系统调用或内存操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15)System Usage: 这个模板记录关于文件读写,sockets,I/O系统活动,输入输出.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16)Time Profiler(时间探查): 执行对系统的CPU上运行的进程低负载时间为基础采样.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17)Zombies: 测量一般的内存使用,专注于检测过度释放的野指针对象,也提供对象分配统计，以及主动分配的内存地址历史.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要使用的是Instruments中的第5个工具:Core Animation(图形性能),这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们必须要把源码安装到测试设备上,1)连接Xcode运行程序;2)然后选择快捷键(Command + Control + i)调出Instruments,选择Core Animation.打开后我们可以看到Debug Options里面有多个调试选项,下面我们挨个尽量来分析看一下:</p><p>###2.1 Color Blended Layers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示,越红表示性能越差,会对帧率等指标造成较大的影响.红色通常是由于多个半透明图层叠加引起.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者项目可能项目比较简单,图层也不是很复杂,所以通过Color Blended Layers查看,深红色并不是很明显,在快速滑动的过程中,帧率依然能够保持在55+以上,并且图层中也没有大量的深红色区域出现.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-423fc34374dc56a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ColorBlendedLayers1-1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8641c471649c93a1.gif?imageMogr2/auto-orient/strip" alt="ColorBlendedLayers1-2-.gif"></p><p>###2.2 Color Hits Green and Misses Red<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当UIView.layer.shouldRasterize = YES 时,耗时的图片绘制会被缓存,并当做一个简单的扁平图片来呈现.这时候,如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中,就显示绿色,反之,如果不命中,这时就显示红色.红色越多,性能越差.因为栅格化生成缓存的过程是有开销的,如果缓存能被大量命中和有效使用,则总体上会降低开销,反之则意味着要频繁生成新的缓存,这会让性能问题雪上加霜.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-f99e1282e6919417.gif?imageMogr2/auto-orient/strip" alt="ColorHitsGreenandMissesRed2-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里笔者还要提一下图片的加载方式,我们知道图片的一般加载方式有两种:imageNamed 和imageWithContentsOfFile;它们的不同在于前者会对图片进行缓存,而后者只是简单的从文件加载文件.如果你加载的是大图,并且只会用到一次,比如欢迎引导图,那么就没必要缓存这个图片,可以使用[UIImage imageWithContentsOfFile:],用完就释放了.如果会多次使用到一张图时,用[UIImage imageNamed:] 就会高效很多,因为这种加载图片方式有一个缓存机制.YYImage实现原理应该就是后面这种思路,自己手动添加缓存.</p><p>###2.3 Color Copied Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理,把这样的图片标为蓝色.蓝色越多,性能越差.因为,我们不希望在滚动视图的时候,由 CPU 来处理图片,这样可能会对主线程造成阻塞.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-e802ac2215033c3f.gif?imageMogr2/auto-orient/strip" alt="ColorCopiedImages3-1.gif"></p><p>###2.4 Color Immediately<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说,这显然太慢了.这个选项就可以用来设置每帧都更新(可能会影响到渲染性能,而且会导致帧率测量不准,所以不要一直都设置它).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-d53301f12380ce80.gif?imageMogr2/auto-orient/strip" alt="ColorImmediately4-1.gif"></p><p>###2.5 Color Misaligned Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项检查了图片是否被缩放,以及像素是否对齐.被放缩的图片会被标记为黄色,像素不对齐则会标注为紫色.黄色,紫色越多,性能越差.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-7785ce1122d31e88.gif?imageMogr2/auto-orient/strip" alt="ColorMisalignedImages5-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里UI在切图的时候尽量切得尺寸和你控件的尺寸保持一致,尽量让图片保持原始尺寸.笔者这里所用图片几乎全部拉伸,由于图片都是从本地加载的,没有经过处理.</p><p>###2.6 Color Offscreen-Rendered Yellow<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把那些离屏渲染的图层显示为黄色.黄色越多,性能越差.这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-cdcbfd43e7b5efa2.gif?imageMogr2/auto-orient/strip" alt="ColorOffscreen-RenderedYellow6-1.gif"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染,即 Off-Screen Rendering.与之相对的是 On-Screen Rendering,即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行.那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染需要多次切&gt;换上下文环境:先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);等到离屏渲染结束以后,将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕,而上下文环境的切换是一项高开销的动作.<br>一般对控件属性操作会触发离屏渲染:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)阴影(UIView.layer.shadowOffset/shadowRadius/…)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)圆角(当 UIView.layer.cornerRadius 和UIView.layer.maskToBounds 一起使用时)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)图层蒙板<br>在实际开发中应尽量避免触发离屏渲染.</p></blockquote><p>###2.7 Color OpenGL Fast Path Blue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把任何直接使用OpenGL 绘制的图层显示为蓝色.蓝色越多,性能越好.如果仅仅使用 UIKit 或者 Core Animation 的 API,那么不会有任何效果.如果使用 GLKView 或者 CAEAGLLayer,那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理,而不是绘制到屏幕.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>任何优化都是以业务需求为前提,在满足基本需求的情况下,逐步提高代码的质量,提升程序性能,不仅是自我能力的表现,也能从中获得一些收获及成就感.以上优化方向思路也是在前人总结的基础上,作者在自己的项目中的简单应用,里面还有许许多多需要改进提升的地方,也希望大家能给一些深层次上的建议意见.</strong></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><strong><em><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--内存管理</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS内存管理无论是早期的MRC还是现在的ARC本质都是通过引用计数(Reference Counting)机制管理内存,当一个对象被创建出来时,它的引用计数从0到1,当有外部对象对它进行强引用时,它的应用计数会+1,当该对象收到一条release消息时,它的引用计数会-1;当对象的引用计数为0时,对象将被释放,对象指向的内存被回收.</p><h2 id="1-ARC内存管理的本质"><a href="#1-ARC内存管理的本质" class="headerlink" title="1. ARC内存管理的本质"></a>1. ARC内存管理的本质</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MRC时代需要程序员手动管理对象的生命周期,也就是对象的引用计数有程序员来控制,什么时候retain,什么时候release,完全自己掌握.ARC(Automatic Reference Counting)自动引用计数是编译器的一个特性,能够自动管理OC对象内存生命周期.在ARC中你需要专注于写你的代码, retain ,release, autorelease操作交给编译器去处理就行了.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-27c80639ff2b00b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MRC_ARC_示意图_来源_Apple_Document.jpg"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC 下编译器如何自动管理内存,其中,能想到的是在类的 dealloc 方法中，对该类的所持有的成员变量(strong)执行 release 操作,让所有成员变量的引用计数为0。对于局部变量,更可能是的对象在出作用域之前,编译器自动给对象加上一条 release消息.这些工作都是编译器为我们处理了.</p><pre><code>// 作用域    {        NSString *str = [[NSString alloc]initWithFormat:@&quot;%@&quot;,@&quot;str&quot;];        NSLog(@&quot;%@&quot;,str);        // 在对象出作用域时,编译器自动给对象发一条release消息        [str release];    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC,则无需我们自己显式持有(retain)和释放(release)对象,ARC通过对对像加上所有权修饰符(__strong等),编译器通过对象的所有权修饰符将会自动管理对象的引用计数.</p><h2 id="2-所有权修饰符"><a href="#2-所有权修饰符" class="headerlink" title="2. 所有权修饰符"></a>2. 所有权修饰符</h2><blockquote><p>基础知识:指针是其实也是一个对象,它指向一个内存地址单元,内存单元里存着各种变量.这样指针就可以指向这样变量,当我们用的时候我们就可以从内存单元取出变量内容.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C对象的ARC是通过所有权修饰符来管理对象的持有和释放。所有权修饰符一共有4种：</p></blockquote><h3 id="2-1-strong-修饰符"><a href="#2-1-strong-修饰符" class="headerlink" title="2.1 __strong 修饰符"></a>2.1 __strong 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认的修饰符,只要有一个强指针指向这个对象,这个对象就一直不会销毁,这个对象指向的指针也不会置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __strong person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:19:09.822168 TestARC[16592:5864784] person_one:(null),person_one地址:0x02018-03-19 16:19:22.443524 TestARC[16592:5864784] person_two:&lt;Person: 0x17001e450&gt;,person_two地址:0x17001e450</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-2902fc1e9aff3193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strong所有权修饰.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到,person_two是person_one的浅拷贝对象,也就是指针拷贝对象,而person_two是通过__strong修饰,相当于强指针,指向的是与person_one一块内存区域.而这块内存区域被retain了两次,引用计数为2,即使person_one = nil将引用计数-1了,person_two依然可以打印出内存地址.person_one的指针已经被置为NULL,所以打印出的地址是0x0.</p><h3 id="2-2-weak-修饰符"><a href="#2-2-weak-修饰符" class="headerlink" title="2.2 __weak 修饰符"></a>2.2 __weak 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当没有强指针指向弱引用的对象时,弱引用的对象将被置为nil,对象的指针置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __weak person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:28:21.453255 TestARC[16599:5866487] person_one:(null),person_one地址:0x02018-03-19 16:28:25.521762 TestARC[16599:5866487] person_two:(null),person_two地址:0x0</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-062710f6ab6758cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道__weak修饰的对象不会对对象进行retain,所以person_two指向的内存区域对象引用计数还是1.这里只有person_one强引用那块内存区域,当person_one = nil时,引用计数为0,内存区域被释放,person_two指向的内存地址为:0x0.</p><h3 id="2-3-unsafe-unretained-修饰符"><a href="#2-3-unsafe-unretained-修饰符" class="headerlink" title="2.3 __unsafe_unretained 修饰符"></a>2.3 __unsafe_unretained 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其表面意思一样:当没有强指针指向__unsafe_unretained修饰的对象时,这个对象会被置为nil,但是指向对象的指针不会被清空,苹果官方: the pointer is left dangling.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __unsafe_unretained person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:42:52.400375 TestARC[16608:5869804] person_one:(null),person_one地址:0x0这里已经报错:Thread 1: EXC_BAD_ACCESS (code=1, address=0xb84d2beb8)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-5666a219c62ae22c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unsafe__unretained所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在主线程中收到一条崩溃信息(EXC_BAD_ACCESS),通过<strong>unsafe_unretained官方文档解释,我们可以猜出address=0xb84d2beb8应该是person_one没被置为nil之前的内存地址,而当person_one = nil时,这块内存已经被回收,而person_two因为被</strong>unsafe_unretained修饰,其指针还没有被销毁,还想指向这块内存地址,所以造成了野指针错误.</p><h3 id="2-4-autoreleasing-修饰符"><a href="#2-4-autoreleasing-修饰符" class="headerlink" title="2.4 __autoreleasing 修饰符"></a>2.4 __autoreleasing 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorelease 本质上就是延迟调用 release,这里不做细致的分析了,大家感兴趣的可以自己找相关资料查看.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里我们对ARC的引用计数管理应该有了大概的了解.</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用计数的实现,我们可以通过查看苹果的源码(<a href="https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法</a>:</p><pre><code>- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上方法,就是编译器在合适的时机给对象所要发送的消息.我们点进去retain方法,我们可以在NSObject.mm文件的2138行可以看到其实现:</p><pre><code>// Replaced by ObjectAlloc- (id)retain {    return ((id)self)-&gt;rootRetain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;沿着调用链,我们可以在objc-object.h文件中看到id rootRetain(bool tryRetain, bool handleOverflow)方法的实现:</p><pre><code>LWAYS_INLINE idobjc_object::rootRetain(bool tryRetain, bool handleOverflow){    assert(!UseGC);    if (isTaggedPointer()) return (id)this;    bool sideTableLocked = false;    bool transcribeToSideTable = false;    isa_t oldisa;    isa_t newisa;    do {        transcribeToSideTable = false;        oldisa = LoadExclusive(&amp;isa.bits);        newisa = oldisa;        if (!newisa.indexed) goto unindexed;        // don&#39;t check newisa.fast_rr; we already called any RR overrides        if (tryRetain &amp;&amp; newisa.deallocating) goto tryfail;        uintptr_t carry;        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++        if (carry) {            // newisa.extra_rc++ overflowed            if (!handleOverflow) return rootRetain_overflow(tryRetain);            // Leave half of the retain counts inline and            // prepare to copy the other half to the side table.            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();            sideTableLocked = true;            transcribeToSideTable = true;            newisa.extra_rc = RC_HALF;            newisa.has_sidetable_rc = true;        }    } while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));    if (transcribeToSideTable) {        // Copy the other half of the retain counts to the side table.        sidetable_addExtraRC_nolock(RC_HALF);    }    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return (id)this; tryfail:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return nil; unindexed:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;    else return sidetable_retain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行sidetable_retain(),这个也是retain方法的最终调用的方法.而sidetable_retain()的实现:</p><pre><code>idobjc_object::sidetable_retain(){#if SUPPORT_NONPOINTER_ISA    assert(!isa.indexed);#endif    SideTable&amp; table = SideTables()[this];    if (table.trylock()) {        size_t&amp; refcntStorage = table.refcnts[this];        if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {            refcntStorage += SIDE_TABLE_RC_ONE;        }        table.unlock();        return (id)this;    }    return sidetable_retain_slow(table);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到这个方法中SideTable这个结构体,</p><pre><code>struct SideTable {    spinlock_t slock;    RefcountMap refcnts;    weak_table_t weak_table;    SideTable() {        memset(&amp;weak_table, 0, sizeof(weak_table));    }    ~SideTable() {        _objc_fatal(&quot;Do not delete SideTable.&quot;);    }    void lock() { slock.lock(); }    void unlock() { slock.unlock(); }    bool trylock() { return slock.trylock(); }    // Address-ordered lock discipline for a pair of side tables.    template&lt;bool HaveOld, bool HaveNew&gt;    static void lockTwo(SideTable *lock1, SideTable *lock2);    template&lt;bool HaveOld, bool HaveNew&gt;    static void unlockTwo(SideTable *lock1, SideTable *lock2);};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 RefcountMap 应该就是引用计数哈希表，而weak_table_t则是弱引用表(weak table).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefcountMap 则是一个简单的 map,其 key 为 object 内存地址，value 为引用计数值.通过SideTable源码，还可以得出如下结论：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在全局的若干个SideTable实例，它们保存在 static 成员变量table_buf中；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序运行过程中生成的所有对象都会通过其内存地址映射到table_buf中相应的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SideTable实例上.这里之所以会存在多个SideTable实例,object 映射到不同SideTable实例上,猜测是出于性能优化的目的，避免SideTable中的 reference table、weak table 过大.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到上面的sidetable_retain方法，其首先通过 object 的地址找到对应的 sidetale，然后通过 RefcountMap将该 object 的引用计数加1.简单地说，Apple 通过全局的 map 来记录Reference Counting，其key 为 object 地址，value 为引用计数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release、retainCount等相关方法的代码在该开源代码中也能找到,这里不细说了.</p><h2 id="4-ARC开发环境需要注意的管理内存"><a href="#4-ARC开发环境需要注意的管理内存" class="headerlink" title="4. ARC开发环境需要注意的管理内存:"></a>4. ARC开发环境需要注意的管理内存:</h2><h3 id="4-1CoreFoundation-Runtime以及其他C语言库的使用"><a href="#4-1CoreFoundation-Runtime以及其他C语言库的使用" class="headerlink" title="4.1CoreFoundation,Runtime以及其他C语言库的使用"></a>4.1CoreFoundation,Runtime以及其他C语言库的使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过malloc,create,copy等创建对象,还需要手动释放.</p><h3 id="4-2-循环引用"><a href="#4-2-循环引用" class="headerlink" title="4.2 循环引用"></a>4.2 循环引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环引用是两个或多个对象之间相互持有,形成环状,即使在没有外部对象指针指向这些对象内存区域(堆区)的时候,系统无法将每个对象的引用计数置为0,从而导致这些开辟出来的内存一直发挥着”占着茅坑不拉屎”的作用.这部分不容易检测,也容易背锅.不管新老司机遇到问题不假思索:循环引用的问题(所以遇到问题的时候,我们更多的是多思考,而不是在没有分析问题的情况下脱口而出,不仅误导别人,而且显得自己很水,多说了两句,见笑).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-674749fa15d20829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环引用示意图.png"></p><h2 id="5-内存管理检测"><a href="#5-内存管理检测" class="headerlink" title="5. 内存管理检测"></a>5. 内存管理检测</h2><h3 id="5-1-Analyze静态分析"><a href="#5-1-Analyze静态分析" class="headerlink" title="5.1 Analyze静态分析"></a>5.1 Analyze静态分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态内存分析, 指的是在程序没运行的时候, 通过预编译对代码进行预判断分析,分析代码的基本数据结构,语法等,编译器检查是否存在潜在的内存泄露及不规范的地方.常遇到问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)The ‘viewWillDisappear:’ instance method in UIViewController subclass ‘xxxxx’ is missing a [super viewWillDisappear:] call;这个错误提示是:重写父类中的实例方法viewWillDisappear,没有在子类中调用,从下图我们可以看到确实是这样,-(void)viewWillDisappear:(BOOL)animated方法内部调用的是[super viewDidAppear:animated];这种是很低级的错误.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-85ff5e032f373642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Value stored to ‘xxxxx’ is never read,声明的变量没有被用到<br><img src="https://upload-images.jianshu.io/upload_images/1715253-b74144bbc8d2352c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) API Misuse 接口应用错误,这里主要针对的是系统提供的接口<br>从下图中我们可以看到,_cachedStatements是一个字典,字典是不允许出现nil对象的,所以存数据之前我们要做容错判断.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-29cf84141853dc67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改完后就不再提示了<br><img src="https://upload-images.jianshu.io/upload_images/1715253-aa89d613c271f245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Memory error,内存错误:nil returned from a method that is expected to return a non-null value,方法返回中需要一个对象(指针),你返回了一个空指针.例如,下图在UITableView的数据源回调方法返回cell的方法中,本应返回一个UITableViewCell对象,可是这里返回了一个nil对象(空指针)<br><img src="https://upload-images.jianshu.io/upload_images/1715253-00e5d7fd34a88fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_4.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还存在其他潜在问题错误或者不规范的地方,大家可以照着这个自己去查找一下自己的项目.</p><h3 id="5-2-Instruments内存泄露检测"><a href="#5-2-Instruments内存泄露检测" class="headerlink" title="5.2 Instruments内存泄露检测"></a>5.2 Instruments内存泄露检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruments内存分析你应用内存的使用情况,帮助你查找定位出现问题的代码区域.详细介绍可以参考apple developer documentation(<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1</a>)<br>从文档中我们大概可以看到,一个应用所使用的内存可能占三种:</p><blockquote><p>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).<br>泄露的内存:应用无法再次应用或者释放的内存.<br>Abandoned memory: Memory still referenced by your application that has no useful purpose.<br>废弃的内存:你的应用还占据着这块内存,但是这块内存无法释放了,ARC中最有可能的是循环引用.<br>Cached memory: Memory still referenced by your application that might be used again for better performance.<br>缓存的内存:能够被你的应用正常释放回收利用的内存.<br>内存泄露：如果程序运行时一直分配内存而不及时释放无用的内存，程序占用的内存越来越大，直到把系统分配给该APP的内存消耗殚尽，程序因无内存可用导致崩溃，这样的情况我们称之为内存泄漏。可能引起的问题:<br>1)内存消耗殆尽的时候，程序会因没有内存被杀死，即crash。<br>2)当内存快要用完的时候，会非常的卡顿<br>3)如果是ViewController没有释放掉，引起的内存泄露，还会引起其他很多问题，尤其是和通知相关的。没有被释放掉的ViewController还能接收通知，还会执行相关的动作，所以会引起各种各样的异常情况的发生。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以我们现在开发的项目为例:这里打个广告,我们现在开发的应用叫做爱学.横版主要有我的班级,自学,消息,设置等模块,下面我们用Instruments来检查一下:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)打开调试工具步骤:首先先将待检测的源码安装到你的真机设备上(Command + r 或者 直接Run运行);然后按着快捷键:Command + Control + i,打开Instruments,选择Leaks.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)定位内存泄露区域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们选择call_tree,也就是函数调用栈,顺藤摸瓜,找到内存泄露的地方<br><img src="https://upload-images.jianshu.io/upload_images/1715253-35a0756984c09923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="call_tree.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8dd8d2a4259d6606.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="memory_leak.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不出意外,就可以看到具体内存泄露的代码了,我们这里是由于使用Runtime了,调用了class_copyPropertyList方法.我们知道Runtime是OC的底层,是OC的幕后工作者,所写的OC代码最终都转换成Runtime的C代码执行.这里通过class_copyPropertyList方法来获取类的所有成员变量的时候,没有释放.所以在使用C语言相关库的时候,一定要做好释放工作(不然装B就装大了😄,玩笑).最终在使用遍历完类中的成员变量后,free(properties);就没问题了.</p><pre><code>-(NSArray *)modelInfo:(Class)cls{    unsigned int  count = 0;    objc_property_t  * properties= class_copyPropertyList(cls, &amp;count);    NSMutableArray  * infoarr = [NSMutableArray new];    for (int i = 0; i&lt;count; i++)    {        objc_property_t property = properties[i];        NSString * name = [[NSString alloc]initWithCString:property_getName(property) encoding:NSUTF8StringEncoding ];        [infoarr addObject:name];    }    free(properties);    return infoarr;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的学习任务中一个视频类型的任务,视频播放器估计是从网上找的别人封装好的,没有细致分析就用了.从下图中我们可以看到至少有三个环,我们需要打破这种环状,消除引用循环,这里不细说,大家可以根据需要去详细看看怎么处理引用循环.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-96a1e31299fb670a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-bb436103f2dc0783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_2.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-15920f2bec2bed6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_3.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中简单介绍了iOS内存管理的相关内容,主要的还是ARC相关内容,这些大都是基于实际开发中的总结和平时学习的积累,里面不乏一些错误和不规范之处,希望没有没有大家没有被误导,更希望大家多给意见和建议.其实,基础知识扎牢了,对一些问题的理解,解决可能也会更加游刃有余,而不是天天纠结于一些”界面”上的问题.</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">https://blog.devtang.com/2016/07/30/ios-memory-management/</a><br><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS持续集成构建</title>
      <link href="/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前市面上持续集成的方案很多:例如,<strong>Jenkins, Fastlane,Xcode server</strong>等,这些持续集成的方案大同小异,他们之间的性能差异笔者没有做大量的横向分析,只是大体比较了一下打包时间.总结来说,持续集成主要是三个步骤:1.拉取代码;2.编译打包;3.分发数据(打包结果),下面将通过两种方案(Jenkins和Xcode server)来分析一下这三个过程.</p><h1 id="Jenkins集成方案"><a href="#Jenkins集成方案" class="headerlink" title="Jenkins集成方案"></a>Jenkins集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins作为免费集成方案,其社区拥有大量插件,非常友好,所以用户也众多.<br>首先来安装Jenkins,Jenkins官网提供了多个系统环境的软件包,我选择的是macOs系统,选择下载安装,步骤如下图:</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-74793443eb9d2e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Jenkins.png"></p><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-3767d8e62b58ab6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装Jenkins.png"></p><h3 id="设置管理员账号密码"><a href="#设置管理员账号密码" class="headerlink" title="设置管理员账号密码"></a>设置管理员账号密码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后,一般mac环境集成了Apache服务器会自动配置启动8080端口,Jenkins的初始化页面也会在安装完成后自动弹出.此时只要找到图中红色标记路径cat或者vi看一下里面的秘钥,进入Jenkins初始化设置工作.这个过程会设置管理员账号密码等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d1d90f913140c3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取初始密码Jenkins.png"></p><h3 id="Jenkins插件安装"><a href="#Jenkins插件安装" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化完成后,就可以利用管理员账号登录.登录后通常可以安装一些常用插件,一般有默认插件和自定义插件,选择默认插件即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4568ef21195c5c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins安装插件.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的环境搭建完成后,就可以实施上面的三个过程了.其实Jenkins的主要工作流程,可以通过下图来直观看出来.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-355b1d4d4cfc90bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins工作流程.png"></p><h2 id="步骤1-拉取代码"><a href="#步骤1-拉取代码" class="headerlink" title="步骤1 拉取代码"></a>步骤1 拉取代码</h2><p><img src="http://upload-images.jianshu.io/upload_images/1715253-fadcbca7317ace47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git仓库分支配置.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉取代码过程比较简单,主要是从指定仓库中克隆代码到Jenkins的工作目录.</p><h2 id="步骤2-编译打包"><a href="#步骤2-编译打包" class="headerlink" title="步骤2 编译打包"></a>步骤2 编译打包</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译打包命令主要有xcodebuild,xcrun,xctool(facebook)等,前两个是官方的,后一个是Facebook出品,xctool里面集成了个性化定制,需要的可以细研究一下,文中只是对xcodebuild做出使用分析.<br>xcodebuild编译过程也主要分三个过程:</p><pre><code>- clean    xcodebuild -workspace MyWorkspace.xcworkspace -scheme SchemeName- archive     xcodebuild archive -workspace MyWorkspace.xcworkspace -scheme SchemeName- export ipa     xcodebuild -exportArchive -archivePath MyMobileApp.xcarchive -exportPath ExportDestination.ipa -exportOptionsPlist &#39;exportPlist.plist&#39;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里多说两句:由于IDE变化,导致编辑脚本稍微有一些出入,主要是在编译的第三步(- export ipa),这步Xcode 8.0需要指定描述文件,Xcode 9.0需要指定exportOptionsPlist(这个是主要包含一些证书, ipa模式等键值表).下面贴出打包执行脚本的全部命令(Xcode 9.0):</strong></p><pre><code>export ETT_APP_NAME=app名称export ETT_WORKSPACE_NAME=工作区名称export ETT_SCHEME=scheme名称export ETT_PROVISIONING_PROFILE=描述文件(Xcode9.0用不到)export ETT_BUILD_TYPE=编译类型(用于区分发布还是AdHoc模式,可以忽略)export ETT_CONFIGURATION=编译配置(主要根据自己的多环境进行配置,比如Release,Debug等)###############################################################################################################export ETT_JENKINS_TIME=$(date +%m%d)export ETT_GIT_COMMIT=${GIT_COMMIT:0:7}export ETT_GIT_REV=`git rev-list HEAD | wc -l | awk &#39;{print $1}&#39;`export ETT_VERSION_PRO=`/usr/bin/agvtool mvers -terse1`export ETT_VERSION_NUMBER=$ETT_VERSION_PRO$ETT_BUILD_TYPEexport ETT_BUILD_VERSION=$ETT_GIT_REV.$BUILD_NUMBERexport ETT_BUILD_ID=$ETT_VERSION_NUMBER-$ETT_JENKINS_TIME-$ETT_GIT_REV-$BUILD_NUMBER-G$ETT_GIT_COMMITexport NEXUS_JENKINS_NAME=打包后上传账号export NEXUS_JENKINS_PASSWD=密码export ExportOptionsPlistPath=/Users/用户/Downloads/zhengshu/ExportOptions.plistexport XCODE=/usr/binexport ETT_DIST_ROOT_PATH=工作区路径export ETT_DIST_PATH=$ETT_DIST_ROOT_PATH/$BUILD_NUMBERexport ETT_ARCHIVE_PATH=$ETT_DIST_PATH/$ETT_APP_NAME.xcarchiveexport ETT_WORK_SPACE=$WORKSPACE/$ETT_WORKSPACE_NAME.xcworkspaceexport ETT_FILE_NAME=$ETT_APP_NAME-$ETT_BUILD_IDexport ETT_IPA_NAME=$ETT_FILE_NAME.ipaexport ETT_EXPORT_PATH=$ETT_DIST_PATH/$ETT_IPA_NAMEexport ETT_PACKAGE_NAME=$ETT_FILE_NAME.tar.gzexport ETT_PACKAGE_PATH=$ETT_DIST_PATH/$ETT_PACKAGE_NAMEexport ETT_NEXUS_FILE_NAME=$ETT_APP_NAME-$ETT_JENKINS_TIME-$BUILD_NUMBER-$ETT_GIT_COMMIT.tar.gzexport ETT_UPLOAD_DSYM_SRC=$ETT_WORKSPACE_NAME.app.dSYMexport ETT_UPLOAD_DSYM_FILE=$ETT_FILE_NAME-dSYM.zipexport ETT_UPLOAD_DSYM_PATH=$ETT_DIST_PATH/$ETT_UPLOAD_DSYM_FILEif [ ! -d &quot;$ETT_DIST_ROOT_PATH&quot; ]; then  mkdir $ETT_DIST_ROOT_PATHfiif [ ! -d &quot;$ETT_DIST_PATH&quot; ]; then  mkdir $ETT_DIST_PATHfi#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1/usr/bin/agvtool new-marketing-version $ETT_VERSION_PRO/usr/bin/agvtool new-version -all $ETT_VERSION_PRO.$ETT_BUILD_VERSION#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1$XCODE/xcodebuild clean build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; archive -archivePath &quot;$ETT_ARCHIVE_PATH&quot; -workspace $ETT_WORK_SPACE -destination generic/platform=iOS -scheme $ETT_SCHEME -configuration &quot;$ETT_CONFIGURATION&quot; BUILD_NUMBER=&quot;$ETT_BUILD_ID&quot; CONFIGURATION_BUILD_DIR=$ETT_DIST_PATH UPLOAD_dSYM_FILE=$ETT_UPLOAD_DSYM_FILE$XCODE/xcodebuild -exportArchive -archivePath $ETT_ARCHIVE_PATH -exportPath $ETT_EXPORT_PATH -exportOptionsPlist $ExportOptionsPlistPath -allowProvisioningUpdates</code></pre><h2 id="步骤3-分发数据-发布打包"><a href="#步骤3-分发数据-发布打包" class="headerlink" title="步骤3 分发数据(发布打包)"></a>步骤3 分发数据(发布打包)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程可以直接发布,也可以上传到自己指定的服务器,第三方托管服务器等.我们直接在执行打包脚本的最后面,将打包处理的ipa文件以及符号化文件打包后直接上传到指定服务器:</p><pre><code>cd $ETT_DIST_PATHzip -r $ETT_UPLOAD_DSYM_PATH $ETT_UPLOAD_DSYM_SRCtar -C $ETT_DIST_PATH -zcvf  $ETT_PACKAGE_PATH $ETT_IPA_NAME $ETT_UPLOAD_DSYM_FILEcurl -v -u $NEXUS_JENKINS_NAME:$NEXUS_JENKINS_PASSWD --upload-file $ETT_PACKAGE_PATH  服务器路径$ETT_APP_NAME/ios/$ETT_VERSION_PRO$ETT_BUILD_TYPE/$ETT_NEXUS_FILE_NAME</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>到这里,Jenkins的简单集成过程算完成了,里面涉及到一些环境变量和参数的设置,笔者因为还涉及到Swift和OC混合打包,问题稍多一点.因为业务需求不一样,需要自己去单独设置,有疑问的地方可以一起沟通一下.</strong></p><h1 id="Xcode-Server集成方案"><a href="#Xcode-Server集成方案" class="headerlink" title="Xcode Server集成方案"></a>Xcode Server集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案,将会把上面三个过程穿插进去,不在单列出来.网上有其他方案是macOS Server + Xcode Server集成方案,本文只是简单介绍一下通过Xcode Server集成</p><h3 id="打开Xcode-Server"><a href="#打开Xcode-Server" class="headerlink" title="打开Xcode Server"></a>打开Xcode Server</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-4cd4f93cfe501b21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Xcode Server.png"></p><h3 id="配置Xcode-Server管理员账号"><a href="#配置Xcode-Server管理员账号" class="headerlink" title="配置Xcode Server管理员账号"></a>配置Xcode Server管理员账号</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-6753a803a134b39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Xcode Server管理员账号.png"></p><h3 id="创建Bot-值守机器人"><a href="#创建Bot-值守机器人" class="headerlink" title="创建Bot(值守机器人)"></a>创建Bot(值守机器人)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置完成后,然后通过Xcode-&gt;Product-&gt;Create Bot<img src="http://upload-images.jianshu.io/upload_images/1715253-53baf11c43225437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建值守机器人.png"></p><h3 id="配置仓库分支"><a href="#配置仓库分支" class="headerlink" title="配置仓库分支"></a>配置仓库分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置代码仓库,Xcode集成了Git所以针对你的项目仓库直接添加分支即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-141e6996076bebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置仓库分支.png"></p><h3 id="编译打包参数配置"><a href="#编译打包参数配置" class="headerlink" title="编译打包参数配置"></a>编译打包参数配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分支添加完成后,就可配置编译的一些选项:scheme,ExportOptionsPlist,Configuration等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-5bacde388ac4ab5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译打包参数配置.png"></p><h3 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-1f389e834485879e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-04787e6efa4abd74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"></p><h3 id="添加签名文件"><a href="#添加签名文件" class="headerlink" title="添加签名文件"></a>添加签名文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步添加证书,描述文件等,作者这里选择的是自动签名模式,如果需要可自己指定签名证书,描述文件等,这里不再细说.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-24a9e3f9e9ab7c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加签名文件.png"></p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-bf5c804e22e172cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加环境变量.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步就是添加编译之前和编译打包之后的动作</p><h3 id="添加打包后的脚本命令"><a href="#添加打包后的脚本命令" class="headerlink" title="添加打包后的脚本命令"></a>添加打包后的脚本命令</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-200c086c7d6d92ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加打包后的脚本命令.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里你可以把打包结果上传到指定位置,脚本可自行查找.</p><h3 id="集成打包"><a href="#集成打包" class="headerlink" title="集成打包"></a>集成打包</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人创建完成后会自动运行编译打包一次,下次打包可以直接通过点击Integrate触发打包.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4ffe92eeb5c28e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集成打包.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两种方案,整个过程走下来并不是很复杂.这里提醒一下,由于Jenkins打包通过脚本命令执行编译打包,这个又依赖于一些环境变量和参数,如果一些插件和参数变了,IDE更新了,系统更新了等等原因,这些很容易造成打包失败,笔者经历多次了,一般就是先把命令拿到终端里面编译打包试一下,排除编译命令问题,然后在调试Jenkins环境.总结下来就是遇到问题时不要着急,慢慢分析,一点一点调试,总会解决的.</strong></p><p>最后打个广告:<br>模仿推特客户端(纯Swift开发,develop分支):<br><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a><br>针对这个客户端简单用Python写了几个接口:<br><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a><br>文章地址:<a href="https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉" target="_blank" rel="noopener">https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉</a>!</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
