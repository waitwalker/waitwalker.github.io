<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>objc_object解读</title>
      <link href="/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/10/objc-object%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是面向对象的语言.面向对象语言有一句话说:”万物皆对象”,这个”对象”从哪里来呢?下面从Runtime源码实现来进一步查看.</p><h3 id="一-objc-object声明相关"><a href="#一-objc-object声明相关" class="headerlink" title="一. objc_object声明相关"></a>一. objc_object声明相关</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先看runtime.h文件,这个文件相当于Runtime对外部提供的接口文件.包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明.当我们使用Xcode创建一个类的时候一般都是调用的这里.</p><pre><code>/**    Runtime对外提供的接口,包含方法,成员变量,分类,属性等结构声明,也包含了objc_class的完整声明 **//* Types */#if !OBJC_TYPES_DEFINED/// 表示一个类中的方法/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// 表示类中的一个成员变量/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// 表示一个分类/// An opaque type that represents a category.typedef struct objc_category *Category;/// 表示一个属性/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;/// 类的声明结构struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>可以看到objc_class的结构声明中有isa指针,这个指针是Class类型,然后我们顺藤摸瓜,继续查找Class的定义来源.然后找到了objc-private.h文件,进入文件后我们看到结构体objc_class和objc_object的不完整声明如下:</p><pre><code>// MARK: - objc_class 和 objc_object 不完整声明struct objc_class;struct objc_object;</code></pre><p>接着是用typedef 将这两个类型取了两个熟悉的名字:Class指针和id指针:</p><pre><code>// MARK: - 将objc_class类型取名为Class指针类型;将objc_object类型取名为id指针类型typedef struct objc_class *Class;typedef struct objc_object *id;</code></pre><p><br><br>往下就是isa的声明union(联合体),isa_t中有两个初始化函数,两个成员变量,cls和bits,还有一个结构体成员.其中在不同的os平台,有不同的声明.</p><pre><code># if __arm64__#   define ISA_MASK        0x0000000ffffffff8ULL#   define ISA_MAGIC_MASK  0x000003f000000001ULL#   define ISA_MAGIC_VALUE 0x000001a000000001ULL#   define ISA_BITFIELD                                                      \      uintptr_t nonpointer        : 1;                                       \      uintptr_t has_assoc         : 1;                                       \      uintptr_t has_cxx_dtor      : 1;                                       \      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \      uintptr_t magic             : 6;                                       \      uintptr_t weakly_referenced : 1;                                       \      uintptr_t deallocating      : 1;                                       \      uintptr_t has_sidetable_rc  : 1;                                       \      uintptr_t extra_rc          : 19#   define RC_ONE   (1ULL&lt;&lt;45)#   define RC_HALF  (1ULL&lt;&lt;18)# elif __x86_64__#   define ISA_MASK        0x00007ffffffffff8ULL#   define ISA_MAGIC_MASK  0x001f800000000001ULL#   define ISA_MAGIC_VALUE 0x001d800000000001ULL#   define ISA_BITFIELD                                                        \      uintptr_t nonpointer        : 1;                                         \      uintptr_t has_assoc         : 1;                                         \      uintptr_t has_cxx_dtor      : 1;                                         \      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \      uintptr_t magic             : 6;                                         \      uintptr_t weakly_referenced : 1;                                         \      uintptr_t deallocating      : 1;                                         \      uintptr_t has_sidetable_rc  : 1;                                         \      uintptr_t extra_rc          : 8#   define RC_ONE   (1ULL&lt;&lt;56)#   define RC_HALF  (1ULL&lt;&lt;7)# else#   error unknown architecture for packed isa# endif// SUPPORT_PACKED_ISA#endif#if SUPPORT_INDEXED_ISA# if  __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)    // armv7k or arm64_32#   define ISA_INDEX_IS_NPI_BIT  0#   define ISA_INDEX_IS_NPI_MASK 0x00000001#   define ISA_INDEX_MASK        0x0001FFFC#   define ISA_INDEX_SHIFT       2#   define ISA_INDEX_BITS        15#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)#   define ISA_INDEX_MAGIC_MASK  0x001E0001#   define ISA_INDEX_MAGIC_VALUE 0x001C0001#   define ISA_BITFIELD                         \      uintptr_t nonpointer        : 1;          \      uintptr_t has_assoc         : 1;          \      uintptr_t indexcls          : 15;         \      uintptr_t magic             : 4;          \      uintptr_t has_cxx_dtor      : 1;          \      uintptr_t weakly_referenced : 1;          \      uintptr_t deallocating      : 1;          \      uintptr_t has_sidetable_rc  : 1;          \      uintptr_t extra_rc          : 7#   define RC_ONE   (1ULL&lt;&lt;25)#   define RC_HALF  (1ULL&lt;&lt;6)</code></pre><p>nonpointer: 标记此isa是否是tagged pointer优化后的isa.占用1bit.值为1说明是优化后的isa.具体参考<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">链接</a>,tagged pointer是对实例对象的优化,默认是true,并且是isClass的判断,这是我看源码的理解,不对请指正<br><br>has_assoc:标记object是否有关联对象,没有,释放更快<br><br>has_cxx_dtor:标记是否有西沟函数,没有,释放更快<br><br>shiftcls:类对象(Class,meta-Class对象)内存地址信息<br><br>magic:标记object是否初始化完成<br><br>weakly_refrenced:标记object是否有weak指针指向它<br><br>deallocating:标记object是否正在释放<br><br>has_sidetable_rc:标记object的extra_rc位数能否存的下object的引用计数,存不下即has_sidetable_rc=1,存在全局的SideTable里面<br><br>extra_rc:存储object的引用计数,存不下,存在全局的SideTable里面<br></p><p><strong>下面是object的完整声明:</strong></p><pre><code>// MARK: - object的完整声明struct objc_object {private:    // 私有成员变量: isa指针    isa_t isa;// 公有函数public:    // 通过这个函数获取不支持tagged pointer的类指针    // ISA() assumes this is NOT a tagged pointer object    Class ISA();    // 通过这个函数获取支持tagged pointer的类指针    // getIsa() allows this to be a tagged pointer object    Class getIsa();    // 以下几个函数是isa的初始化函数    // initIsa()用来初始化一个新的对象的isa    // initIsa() should be used to init the isa of new objects only.    // changeIsa 修改一个对象的isa    // If this object already has an isa, use changeIsa() for correctness.    // initInstanceIsa()用来初始化一个实例对象的isa    // initInstanceIsa(): objects with no custom RR/AWZ    // initClassIsa()用来初始化一个类对象的isa    // initClassIsa(): class objects    // initProtocolIsa()用来初始化一个protocol的isa    // initProtocolIsa(): protocol objects    // initIsa()还用来初始化其它类型对象的isa    // initIsa(): other objects    void initIsa(Class cls /*nonpointer=false*/);    void initClassIsa(Class cls /*nonpointer=maybe*/);    void initProtocolIsa(Class cls /*nonpointer=maybe*/);    void initInstanceIsa(Class cls, bool hasCxxDtor);    // changeIsa() should be used to change the isa of existing objects.    // If this is a new object, use initIsa() for performance.    Class changeIsa(Class newCls);    // tagged pointer 相关    bool hasNonpointerIsa();    bool isTaggedPointer();    bool isBasicTaggedPointer();    bool isExtTaggedPointer();    // 是否是Class    bool isClass();    // 关联对象相关    // object may have associated objects?    bool hasAssociatedObjects();    void setHasAssociatedObjects();    // weak指针相关    // object may be weakly referenced?    bool isWeaklyReferenced();    void setWeaklyReferenced_nolock();    // 对象是否有析构函数    // object may have -.cxx_destruct implementation?    bool hasCxxDtor();    // retain 和 release 操作对象的引用计数 声明函数    // Optimized calls to retain/release methods    id retain();    void release();    id autorelease();    // retain 和 release 操作对象的引用计数 实现函数    // Implementations of retain/release methods    id rootRetain();    bool rootRelease();    id rootAutorelease();    bool rootTryRetain();    bool rootReleaseShouldDealloc();    uintptr_t rootRetainCount();    // 释放销毁对象相关    // Implementation of dealloc methods    bool rootIsDeallocating();    void clearDeallocating();    void rootDealloc();// 私有函数 上面一些公有函数的调用函数private:    void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor);    // Slow paths for inline control    id rootAutorelease2();    bool overrelease_error();#if SUPPORT_NONPOINTER_ISA    // Unified retain count manipulation for nonpointer isa    id rootRetain(bool tryRetain, bool handleOverflow);    bool rootRelease(bool performDealloc, bool handleUnderflow);    id rootRetain_overflow(bool tryRetain);    bool rootRelease_underflow(bool performDealloc);    void clearDeallocating_slow();    // Side table retain count overflow for nonpointer isa    void sidetable_lock();    void sidetable_unlock();    void sidetable_moveExtraRC_nolock(size_t extra_rc, bool isDeallocating, bool weaklyReferenced);    bool sidetable_addExtraRC_nolock(size_t delta_rc);    size_t sidetable_subExtraRC_nolock(size_t delta_rc);    size_t sidetable_getExtraRC_nolock();#endif    // Side-table-only retain count    bool sidetable_isDeallocating();    void sidetable_clearDeallocating();    bool sidetable_isWeaklyReferenced();    void sidetable_setWeaklyReferenced_nolock();    id sidetable_retain();    id sidetable_retain_slow(SideTable&amp; table);    uintptr_t sidetable_release(bool performDealloc = true);    uintptr_t sidetable_release_slow(SideTable&amp; table, bool performDealloc = true);    bool sidetable_tryRetain();    uintptr_t sidetable_retainCount();#if DEBUG    bool sidetable_present();#endif};</code></pre><p>以上就是objc_object的具体声明结构,里面有许多值得深究的问题,也是接下来会继续关注的问题.</p><h3 id="二-实例对象的初始化"><a href="#二-实例对象的初始化" class="headerlink" title="二.实例对象的初始化"></a>二.实例对象的初始化</h3><h4 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1.alloc"></a>1.alloc</h4><p>下面我们来看一个对象的实例化过程:</p><pre><code>Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);</code></pre><p>上面代码时创建一个newClass类,并且用这个新类实例化一个newObject对象.查看一下alloc方法和init方法的调用栈,其中省略了中间过程:</p><pre><code>id _objc_rootAlloc(Class cls)└── static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)    └── id class_createInstance(Class cls, size_t extraBytes)        └── id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct, size_t *outAllocatedSize)            ├── size_t instanceSize(size_t extraBytes)            ├── void    *calloc(size_t, size_t)            └── inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</code></pre><p>其中NSObject.mm中对alloc的实现如下:</p><pre><code>+ (id)alloc {    return _objc_rootAlloc(self);}</code></pre><p>这里面调用了一个私有函数,返回一个id类型(objc_object)如下:</p><pre><code>id_objc_rootAlloc(Class cls){    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);}</code></pre><p>NSObject.mm对callAlloc()实现:</p><pre><code>// Call [cls alloc] or [cls allocWithZone:nil], with appropriate// shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){    if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) {        // No alloc/allocWithZone implementation. Go straight to the allocator.        // fixme store hasCustomAWZ in the non-meta class and        // add it to canAllocFast&#39;s summary        if (fastpath(cls-&gt;canAllocFast())) {            // No ctors, raw isa, etc. Go straight to the metal.            bool dtor = cls-&gt;hasCxxDtor();            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());            if (slowpath(!obj)) return callBadAllocHandler(cls);            obj-&gt;initInstanceIsa(cls, dtor);            return obj;        }        else {            // Has ctor or raw isa or something. Use the slower path.            id obj = class_createInstance(cls, 0);            if (slowpath(!obj)) return callBadAllocHandler(cls);            return obj;        }    }#endif    // No shortcuts available.    if (allocWithZone) return [cls allocWithZone:nil];    return [cls alloc];}</code></pre><p>其中有个class_createInstance()函数,这函数中会调用_class_createInstanceFromZone()函数:</p><pre><code>static __attribute__((always_inline))id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil){    if (!cls) return nil;    assert(cls-&gt;isRealized());    // Read class&#39;s info bits all at once for performance    bool hasCxxCtor = cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size = cls-&gt;instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (!zone  &amp;&amp;  fast) {        obj = (id)calloc(1, size);        if (!obj) return nil;        obj-&gt;initInstanceIsa(cls, hasCxxDtor);    }    else {        if (zone) {            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);        } else {            obj = (id)calloc(1, size);        }        if (!obj) return nil;        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj-&gt;initIsa(cls);    }    if (cxxConstruct &amp;&amp; hasCxxCtor) {        obj = _objc_constructOrFree(obj, cls);    }    return obj;}</code></pre><p>这里面有:1)instanceSize()是给对象分配内存空间:</p><pre><code>size_t instanceSize(size_t extraBytes) {    size_t size = alignedInstanceSize() + extraBytes;    if (size &lt; 16) size = 16;    return size;}uint32_t alignedInstanceSize() {    return word_align(unalignedInstanceSize());}uint32_t unalignedInstanceSize() {    assert(isRealized());    return data()-&gt;ro-&gt;instanceSize;}</code></pre><p>2)initIsa()初始化isa指针</p><pre><code>inline voidobjc_object::initIsa(Class cls){    initIsa(cls, false, false);}inline voidobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor){    assert(!isTaggedPointer());    // 不是tagged pointer    if (!nonpointer) {        isa.cls = cls;    } else {        assert(!DisableNonpointerIsa);        assert(!cls-&gt;instancesRequireRawIsa());        isa_t newisa(0);#if SUPPORT_INDEXED_ISA        assert(cls-&gt;classArrayIndex() &gt; 0);        newisa.bits = ISA_INDEX_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else        newisa.bits = ISA_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif        // This write must be performed in a single store in some cases        // (for example when realizing a class because other threads        // may simultaneously try to use the class).        // fixme use atomics here to guarantee single-store and to        // guarantee memory order w.r.t. the class index table        // ...but not too atomic because we don&#39;t want to hurt instantiation        isa = newisa;    }}</code></pre><h4 id="2-init"><a href="#2-init" class="headerlink" title="2.init"></a>2.init</h4><p>init()函数调用栈很简单,只是调用了_objc_rootInit()私有函数,并返回对象本身</p><pre><code>- (id)init {    return _objc_rootInit(self);}id_objc_rootInit(id obj){    // In practice, it will be hard to rely on this function.    // Many classes do not properly chain -init calls.    return obj;}</code></pre><p><strong>对象的初始化过程可以总结为分配内存空间并且初始化isa_t结构的过程.</strong></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">https://blog.devtang.com/2014/05/30/understand-tagged-pointer/</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Extension</title>
      <link href="/2019/04/09/Swift-Extension/"/>
      <url>/2019/04/09/Swift-Extension/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift Extension 字面意思就是扩展.有点类似OC中Category,按照官方文档,Extension可以用来:</p><h3 id="1-添加计算型属性"><a href="#1-添加计算型属性" class="headerlink" title="1.添加计算型属性"></a>1.添加计算型属性</h3><p><strong>拓展一下:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算型属性:计算型属性不直接存储值,而是提供一个getter和setter来间接获取和设置属性值</p><pre><code>var name:Stringvar _name:String {set {name = newValue}get {return name}}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储型属性:用来存储一个变量或者常量</p><pre><code>var name:String = &quot;zhangsan&quot;let age:Int = 10</code></pre><pre><code>// MARK: - 扩展计算型属性extension UIView {    var x:CGFloat {        set{            self.frame.origin.x = newValue        }        get{           return self.frame.origin.x        }    }}</code></pre><h3 id="2-添加方法"><a href="#2-添加方法" class="headerlink" title="2.添加方法"></a>2.添加方法</h3><p><strong>扩展实例方法</strong></p><pre><code>// MARK: - 扩展实例方法    func size(height:CGFloat, width:CGFloat) -&gt; CGFloat {        return height * width    }</code></pre><p><strong>添加突变方法 - mutating method:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过extension添加的实例方法同样可以修改(modify)或突变(mutate)该实例本身，如果结构体和枚举定义的方法想要改变自身或自身的属性，那么该实例方法必须被标记为突变(mutating)的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的例子为Int类型添加了一个名为square的突变方法，它的作用是计算原始值的平方:</p><pre><code>extension Int {    mutating func square() {        self = self * self    }}</code></pre><h3 id="3-提供便利构造器"><a href="#3-提供便利构造器" class="headerlink" title="3.提供便利构造器"></a>3.提供便利构造器</h3><pre><code>// MARK: - 便利构造器    convenience init(info:[String:String]) {        self.init()// todo:    }</code></pre><h3 id="4-定义下标subscripts"><a href="#4-定义下标subscripts" class="headerlink" title="4.定义下标subscripts"></a>4.定义下标subscripts</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附属脚本可以定义在class,struct,enum中,可以认为是访问对象,集合或者序列的快捷方式,凌辱我们常用的通过所以访问数组中的值,array[index];通过key访问字典中的value,dict[key]等.</p><pre><code>// MARK: - 官方示例:计算某个整数第某位上的值extension Int {    subscript(digitIndex: Int) -&gt; Int {        var decimalBase = 1        for _ in 0..&lt;digitIndex {            decimalBase *= 10        }        return (self / decimalBase) % 10    }}746381295[0]// returns 5746381295[1]// returns 9746381295[2]// returns 2746381295[8]// returns 7</code></pre><h3 id="5-添加嵌套类型"><a href="#5-添加嵌套类型" class="headerlink" title="5.添加嵌套类型"></a>5.添加嵌套类型</h3><pre><code>extension Int {    enum Kind {        case negative, zero, positive    }    var kind: Kind {        switch self {        case 0:            return .zero        case let x where x &gt; 0:            return .positive        default:            return .negative        }    }}</code></pre><h3 id="6-实现遵守协议的方法"><a href="#6-实现遵守协议的方法" class="headerlink" title="6.实现遵守协议的方法"></a>6.实现遵守协议的方法</h3><pre><code>// MARK: - 实现遵守协议的方法extension UIView:UITableViewDataSource {    public func numberOfSections(in tableView: UITableView) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        &lt;#code#&gt;    }    public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        &lt;#code#&gt;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift_Equable</title>
      <link href="/2019/04/09/Swift-Equable/"/>
      <url>/2019/04/09/Swift-Equable/</url>
      
        <content type="html"><![CDATA[<p>一般判断两个对象是否相等方法:<br><br>如果两个对象相等其hashValue一定相等,不能反过来倒推.<br><br>1)如果两个对象的hashValue不相等,则认为这两个对象一定不相等<br><br>2)如果两个对象的hashValue相等,则比较两个对象的指针和两对象的内容是否相等,如果相等,则认为这两个对象是相等的<br><br>Swift中一些数据类型Int,Double,Bool等均已遵守实现Equable协议,所以在使用的时候可以用”==”操作符直接比较两个变量就行.<br></p><p>如果有一些自定义类型需要比较,需要遵守Equable协议,并且重写 public static func == (lhs: Self, rhs: Self) -&gt; Bool方法.<br></p><pre><code>class Person {    var name:String?    var age:Int?    init(name:String,age:Int) {        self.name = name        self.age = age    }}extension Person:Equatable {    static func == (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age    }}let person1 = Person(name: &quot;zhangsan&quot;, age: 18)let person2 = Person(name: &quot;lisi&quot;, age: 20)print(person1==person2) //false</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift 开发 </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/04/09/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/09/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="表的简单定义"><a href="#表的简单定义" class="headerlink" title="表的简单定义:"></a>表的简单定义:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将处理一般的形如A1,A2,A3,…An的表,称这个表的大小是N.我们称大小为0的表为空表.表是一种线性的数据结构集合.对于除空表外的任何表,我们称Ai+1是Ai的后继,Ai-1是Ai的前驱.</p><h2 id="表常见的操作"><a href="#表常见的操作" class="headerlink" title="表常见的操作:"></a>表常见的操作:</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find返回关键字首次出现的位置例程,Delete删除某个关键字例程,Insert在某个位置插入例程,遍历等</p><h2 id="表的实现方式"><a href="#表的实现方式" class="headerlink" title="表的实现方式:"></a>表的实现方式:</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于表的所有操作都可以通过数组来实现,数组实现表有一定的局限性,数组的大小事先要指定;数组的插入和删除操作会对插入和删除以后的所有元素都要调整,这种时间复杂度最坏为O(n).但是数组的查找和遍历是线性时间复杂度,而查找某个位置上的元素时间复杂度仅为常数时间,这些可以算作数组的优势.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为插入和删除的运行时间以及表的大小还要事先已知,因此对于插入和删除操作比较多的情况,一般不用数组来实现表结构.</p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表由一系列不必在内存中相连的结构组成.每一个结构均含有表元素和指向包含该元素后继元的结构的指针,即next指针.最后一个结构的next指针指向NULL.遍历和查找某个元素链表的时间复杂度为线性时间,我们只要将一个指针传递到该表的第一个元素,然后用一些next指针穿越该表即可.而查找某个位置上的元素其优势不如数组效率高.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除操作可以将待删除结构前驱的next指针指向待删除结构的后继即可.插入操作需要先实例化创建一个结构,然后获取插入位置的结构的前驱,将其next指针指向新创建的结构,然后新创建的结构next指针指向插入位置结构后继.</p><h3 id="3-链表结构类型"><a href="#3-链表结构类型" class="headerlink" title="3.链表结构类型"></a>3.链表结构类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表分为单链表,双链表,循环链表,块链表等.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双链表比单链表多了一个previous指针,指向前驱.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环链表是将首尾连接起来,这种方式在单向和双向链表中皆可实现.要转换一个循环链表,你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点.再来看另一种方法,循环链表可以被视为“无头无尾”.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块状链表本身是一个链表,但是链表储存的并不是一般的数据,而是由这些数据组成的顺序表.每一个块状链表的节点,也就是顺序表,可以被叫做一个块.<br></p><p>[图片上传失败…(image-e79610-1554800955920)])</p><h4 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h4><pre><code>/// 节点元素的值var value:T/// 节点元素的next指针var next:NodeList?/// 链表节点元素的构造函数////// - Parameter val: 值init(val:T) {self.value = val}</code></pre><h4 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历链表用next指针穿越整个表,创建一个临时节点,把当前节点赋值给临时节点.如果当前节点不为nil,将当前节点的next赋值给临时节点.</p><pre><code>/// 遍历链表////// - Parameter nodeList: 链表/// - Returns: 链表长度func traverse(with nodeList:NodeList?) -&gt; Int {var nodeListLength:Int = 0var tmpNode = nodeListwhile tmpNode != nil {nodeListLength += 1tmpNode = tmpNode!.next}return nodeListLength}</code></pre><h4 id="根据给定索引查找对应节点的值"><a href="#根据给定索引查找对应节点的值" class="headerlink" title="根据给定索引查找对应节点的值"></a>根据给定索引查找对应节点的值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找例程还是基于遍历思想,用next指针穿越.如果当前节点不为空,比较当前索引与指定索引事都相等,相等返回当前节点的值;不相等则递增当前索引并且将当前节点的后继赋值给当前节点,直到当前索引与指定索引相等.</p><pre><code>/// 根据指定索引查找某个链表节点的值////// - Parameters:/// - nodeList: 链表/// - index: 要查询的节点/// - Returns: 某个索引节点的值func find(with nodeList:NodeList?, index:Int) -&gt; T? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if currentIndex == index {return tmpNode?.value}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="根据指定值查找某个链表节点的索引"><a href="#根据指定值查找某个链表节点的索引" class="headerlink" title="根据指定值查找某个链表节点的索引"></a>根据指定值查找某个链表节点的索引</h4><pre><code>/// 根据指定值查找某个链表节点的索引////// - Parameters:/// - nodeList: 链表/// - value: 值/// - Returns: 值对应节点的索引func find(with nodeList:NodeList?, value:T?) -&gt; Int? {var tmpNode = nodeListvar currentIndex:Int = 0while tmpNode != nil {if tmpNode?.value == value {return currentIndex}currentIndex += 1tmpNode = tmpNode?.next}return nil}</code></pre><h4 id="在指定位置插入新的节点"><a href="#在指定位置插入新的节点" class="headerlink" title="在指定位置插入新的节点"></a>在指定位置插入新的节点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先判断当前链表是否存在,然后获取插入位置的前一个节点previousN,把previousN的后继赋值给插入节点的next指针;把插入节点赋值给previousN的next指针;</p><pre><code>/// 在链表指定位置插入新的节点并返回新的链表////// - Parameters:/// - nodeList: 链表/// - node: 待插入节点/// - index: 插入位置/// - Returns: 新的链表func insert(with nodeList:NodeList?, node:NodeList, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return node }if traverse(with: nodeL) &lt;= index {return node}var previousN:NodeList?if index != 0 {previousN = nodeL.find(with: nodeL, at: index - 1)node.next = previousN!.nextpreviousN!.next = nodereturn nodeL} else {node.next = nodeLreturn node}}</code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除指定位置的节点先要找到当前节点currentN和当前节点的前驱previousN,然后把previousN的next指针指向currentN的后继.</p><pre><code>/// 删除指定位置的节点并返回新的列表////// - Parameters:/// - nodeList: 链表/// - index: 待删除的位置/// - Returns: 删除后的链表func delete(with nodeList:NodeList?, index:Int) -&gt; NodeList? {guard let nodeL = nodeList else { return nil }if nodeL.traverse(with: nodeL) &lt;= index {return nodeL}if index == 0 {return nodeL.next}let previousN = nodeL.find(with: nodeL, at: index - 1)let currentN = nodeL.find(with: nodeL, at: index)previousN?.next = currentN?.nextreturn nodeL}</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的实现代码已放到<a href="https://github.com/waitwalker/DataStructureAlgorithm" target="_blank" rel="noopener">GitHub</a>,测试用例详见DataStructureAlgorithmTests.swift文件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数据结构与算法分析C语言描述》(Data Structures and Algorithm Analysis in C:Second Edition)–译者: 冯舜玺</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime源码编译</title>
      <link href="/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2019/04/08/Runtime%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C是基于c语言的封装,使C语言具有了面向对象的能力.OC的本质最终还是转换c语言来执行,而这个转换的过程是通过Runtime这个运行时库来完成的.平常我们只需要写面对对象的OC代码,不用太关心一些底层转换原理及过程.但是有些情况.比如需要动态给一个类添加方法,添加成员变量,添加协议,没有实现方法的报错解析定位等,就需要了解这个底层实现来更好的解决实际开发中遇到的问题.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文也是对之前编译查看的Runtime源码的一个复习过程,主要有以下几步:</p><h3 id="一-下载源码及相关依赖"><a href="#一-下载源码及相关依赖" class="headerlink" title="一.下载源码及相关依赖"></a>一.下载源码及相关依赖<br></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果开源网站:<a href="http://opensource.apple.com/" target="_blank" rel="noopener">http://opensource.apple.com/</a>,其为我们提供了Runtime的实现源码objc4,这个objc4有多个版本,版本号越大说明是最新源码.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-131232ef2da1515f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果开源平台"></p><h4 id="1-下载objc4源码"><a href="#1-下载objc4源码" class="headerlink" title="1.下载objc4源码"></a>1.下载objc4源码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先打开苹果开源网站,可以看到苹果针对不同的设备平台有不同的开源项目已经对应的系统版本,找到对应的平台对应的版本点击下载objc4源码,本文依赖的是objc4-750版本.也可以在<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/</a>上面搜索所有开源项目源码的压缩包.<br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fbed6e632659dcff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc4源码"></p><h4 id="2-下载objc4相关依赖库"><a href="#2-下载objc4相关依赖库" class="headerlink" title="2.下载objc4相关依赖库"></a>2.下载objc4相关依赖库</h4><p>objc4相关依赖库:Libc，dyld，libauto，libclosure，libdispatch，libpthread，xnu.这些依赖库中包含了Runtime源码库中需要的一些文件.</p><h4 id="3-解压缩所有下载的压缩包库"><a href="#3-解压缩所有下载的压缩包库" class="headerlink" title="3.解压缩所有下载的压缩包库."></a>3.解压缩所有下载的压缩包库.</h4><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fabaa6bd03263beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码解压后"></p><h3 id="二-编译-amp-错误解决"><a href="#二-编译-amp-错误解决" class="headerlink" title="二.编译&amp;错误解决"></a>二.编译&amp;错误解决<br></h3><h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境:"></a>1.环境:</h4><p>target platform:<strong>macOS</strong><br><br>macOS:<strong>10.14</strong><br><br>Xcode:<strong>10.1</strong><br></p><h4 id="2-遇到的错误-amp-解决"><a href="#2-遇到的错误-amp-解决" class="headerlink" title="2.遇到的错误&amp;解决"></a>2.遇到的错误&amp;解决</h4><p><strong>1)error: The i386 architecture is deprecated. You should update your ARCHS build setting to remove the i386 architecture. (in target ‘objc’)</strong><br><br>解决:找target对应编译设置(Build Settings)-&gt;CPU架构(Architecture)-&gt;标准(Standard arcgutectures)<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-bebc4c3e29d47f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误1"><br><strong>2)在objc-os.h头文件中报’sys/reason.h’ file not found错误</strong><br><br>解决:工程目录下创建include/sys目录,在编译设置(Build Settings里面搜索,Header Search Paths,然后将include索引添加进去),然后在之前下载的依赖包中搜索reason.h头文件,复制到include/sys目录下<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-149cea545b66f79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误2"><br><strong>3)在objc-os.h头文件中报’mach-o/dyld_priv.h’ file not found错误</strong><br><br>解决:同上一步,创建include/mach-o目录,复制dyld_priv.h头文件到相应目录<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7a009d4875664966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误3"><br><strong>4)在objc-os.h头文件中报’os/lock_private.h’ file not found错误</strong><br><br>解决:这个文件并没有再我们下载的依赖库中,需要去开源官网下载,然后操作同上一步<br><br><strong>5)以下是遇到的类似问题:</strong><br><br>‘os/base_private.h’ file not found;<br><br>‘pthread/tsd_private.h’ file not found;<br><br>‘System/machine/cpu_capabilities.h’ file not found;<br><br>‘os/tsd.h’ file not found;<br><br>‘pthread/spinlock_private.h’ file not found;<br><br>‘System/pthread_machdep.h’ file not found;<br><br>‘CrashReporterClient.h’ file not found;这个需要在编译设置(Build Settings添加宏变量Build Settings-&gt;Preprocessor Macros中加入：LIBC_NO_LIBCRASHREPORTERCLIENT)<br><br>‘Block_private.h’ file not found;<br><br>‘objc-shared-cache.h’ file not found;<br><br>‘isa.h’ file not found;<br><br>‘_simple.h’ file not found;<br><br>在objc-errors.mm文件中报:Use of undeclared identifier ‘CRGetCrashLogMessage’错误;<br><br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-7730fb32289af992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误5"><br><strong>6)链接时候错误:</strong><br><br>ld: can’t open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/<br>Developer/SDKs/MacOSX10.14.sdk/AppleInternal/OrderFiles/libobjc.order<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br><br>解决:将Build Settings-&gt;Linking-&gt;Order File改为工程根目录下的libobjc.order，即：$(SRCROOT)/libobjc.order。<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-81be9877600720d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误6"><br><strong>7)编译脚本错误</strong><br><br>xcodebuild: error: SDK “macosx.internal” cannot be located.<br>xcrun: error: unable to find utility “clang++”, not a developer tool or in PATH<br><br>解决:把Target-objc的Build Phases-&gt;Run Script(markgc)里的内容macosx.internal改为macosx，这里猜测macosx.internal为苹果内部的macosx<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-fe07a0f8d034da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误7"><br><strong>8)error: no such public header file: ‘/tmp/objc.dst/usr/include/objc/ObjectiveC.apinotes’错误</strong><br><br>解决:把Text-Based InstallAPI Verification Model里的值改为Errors Only<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-0bd60bd7502eb574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误8"></p><h4 id="3-编译成功"><a href="#3-编译成功" class="headerlink" title="3.编译成功"></a>3.编译成功</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决以上错误后,再次编译应该基本Succeeded.<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-d6481492106e77dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功"><br></p><h3 id="三-调试"><a href="#三-调试" class="headerlink" title="三.调试"></a>三.调试<br></h3><h4 id="1-创建调试target"><a href="#1-创建调试target" class="headerlink" title="1.创建调试target"></a>1.创建调试target</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文编译针对的是macOS平台,可以创建一个macOS app或者一个 Command Line Tool 来调试.这里我们就创建一个Command Line Tool target:<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-5b9356137395b41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug target"></p><h4 id="2-编写代码调试"><a href="#2-编写代码调试" class="headerlink" title="2.编写代码调试"></a>2.编写代码调试</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新创建一个class,命名为newClass,打印出class name.可以查看调用栈,确实调用的是我们编译后的Runtime库:</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/message.h&gt;#import &lt;objc/runtime.h&gt;int main(int argc, const char * argv[]) {    @autoreleasepool {        Class newClass = objc_allocateClassPair(objc_getClass(&quot;NSObject&quot;), &quot;newClass&quot;, 0);        objc_registerClassPair(newClass);        id newObject = [[newClass alloc]init];        NSLog(@&quot;%s&quot;,class_getName([newObject class]));        NSLog(@&quot;Hello, World!&quot;);    }    return 0;}</code></pre><p><br><br><img src="http://upload-images.jianshu.io/upload_images/1715253-ff32f2b6e67bfb93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_1"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-41cd2b1e03f16de5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug_2"></p><h3 id="四-编译后源码库"><a href="#四-编译后源码库" class="headerlink" title="四.编译后源码库"></a>四.编译后源码库</h3><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译后的源码放在<a href="https://github.com/waitwalker/Runtime" target="_blank" rel="noopener">Github</a></strong></p><h3 id="五-参考文献"><a href="#五-参考文献" class="headerlink" title="五.参考文献"></a>五.参考文献</h3><p><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="noopener">https://pewpewthespells.com/blog/buildsettings.html</a><br><br><a href="https://blog.csdn.net/wotors/article/details/52489464" target="_blank" rel="noopener">https://blog.csdn.net/wotors/article/details/52489464</a></p>]]></content>
      
      
      <categories>
          
          <category> Runtime源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中Objective-C和Swift混编及第三方框架相互调用</title>
      <link href="/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
      <url>/2019/04/07/iOS%E4%B8%ADObjective-C%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E5%8F%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将详细介绍一下OC和swift混编问题,其中涉及两大部分:1)oc项目中混编swift的实现; 2)oc或者swift第三库的导入及使用.</p><p>#1 oc项目中混编swift<br>在oc项目中想要使用swift,并且实现相互调用,需要一些基本的设置,桥接文件也是必须得.</p><p>#1. 1 基本设置支持swift<br>在bulid setting中找到 Packaging 下的 define module,将是否定义模块布尔值改成YES,这样OC就可以支持swift了.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-a50523996ab98cb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="define module.png"></p><p>#1. 2 创建桥接文件<br>桥接文件可以在你创建swift文件的时候Xcode自动生成,也可以自己手动创建,手动创建也就是一个头文件(.h文件).<br>这里需要说明一点的是,在oc项目中创建的swift文件必须都要继承自NSObject基类,而你自己想要创建的一些类可以这样来创建:</p><p>####创建步骤1<br><img src="http://upload-images.jianshu.io/upload_images/1715253-6cacd2bc47564e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>####创建步骤2<br><img src="http://upload-images.jianshu.io/upload_images/1715253-fd2a1b324f032568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><p>####创建步骤3<br>这里选择Create Bridging Header,如果不选的话,那就自己手动创建,然后指定索引位置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-e88dda48a82bc616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>####创建步骤4<br><img src="http://upload-images.jianshu.io/upload_images/1715253-19219fab149a7ca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>第三步中如果没有创建桥接文件的话,手动创建一个桥接文件,然后build setting 中搜索 Objective-C Bridging Header,将你手动创建的桥接文件路径输入进去</p><p>####桥接文件设置<br><img src="http://upload-images.jianshu.io/upload_images/1715253-b9b8484bfd32bc58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接文件设置"></p><p>#1.3 swift中调用oc文件<br>现在基本上可以实现swift调用oc中代码了,首先在桥接文件中导入你想在swift中用到的oc类</p><p>####导入oc类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1228e43af95e8399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入oc类"></p><p>####使用oc中的类<br><img src="http://upload-images.jianshu.io/upload_images/1715253-2b410f5097f1786c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用oc中的类"></p><p>#1. 4 oc中调用swift文件<br><img src="http://upload-images.jianshu.io/upload_images/1715253-25d7b46b350c3dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="oc中调用swift文件"></p><p>#2 oc和swift第三方库的使用<br>如果你的项目用cocoapods来管理你使用的第三方库,并且OC项目中已经集成了多个第三方库,那么这时你想在导入swift编写的第三方库,这时你不能用cocoapods管理第三方库了,因为Swift连接时不支持静态库,cocoapods也在其Podfile中有说明:</p><h1 id="Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks"><a href="#Uncomment-the-next-line-if-you’re-using-Swift-or-would-like-to-use-dynamic-frameworks" class="headerlink" title="Uncomment the next line if you’re using Swift or would like to use dynamic frameworks"></a>Uncomment the next line if you’re using Swift or would like to use dynamic frameworks</h1><h1 id="use-frameworks"><a href="#use-frameworks" class="headerlink" title="use_frameworks!"></a>use_frameworks!</h1><p>翻译过来就是:如果你想使用swift或者动态库,就把下面一行注释打开<br>然而打开后你是编译不过去的,这时需要手动导入swift库<br><img src="http://upload-images.jianshu.io/upload_images/1715253-1910c75b87225c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用swift或者动态库使用use_frameworks"></p><p>下面手动导入Alamofire作为例子:</p><p>##1)首先下载Alamofire项目源码,解压<br><img src="http://upload-images.jianshu.io/upload_images/1715253-cc75cc2e87dd1875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alamofire项目源码"><br>可以删除多余的不需要的文件,比如Example文件夹,等等</p><p>##2)将Alamofire项目整个拖到你的项目中<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d0e942f8f731ffc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拖到自己项目中"></p><p>##3)在Embedded Binaries中添加Alamofire.framework<br><img src="http://upload-images.jianshu.io/upload_images/1715253-8007cc13803cec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Embedded Binaries中添加Alamofire.framework"></p><p>这样就可以cocoapods管理OC第三方库,swift第三方库手动管理,实现不同第三方框架的调用.</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--tableView优化</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-tableView%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者基于之前自己所写的Swift项目–仿照推特客户端用纯Swift写的一个项目,目前已经公开放在GitHub上(<strong><em><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a></em></strong>); 接口用Python写的几个(<strong><em><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a></em></strong>),目前所实现的功能是登录,注册,发推,首页列表等功能,其他页面都是一些假数据.这里不主要分析项目了,有时间在详细说一下.本文的主要重点是说说自己对性能调优–tableView控件优化的一点理解,有些问题理解的不是很透彻,希望大家能多给些意见,建议,谢谢.下图是整个项目的总览(文章中多是gif动态,尺寸较大,使用流量看得慎重):<br><img src="https://upload-images.jianshu.io/upload_images/1715253-360caafd286f9f10.gif?imageMogr2/auto-orient/strip" alt="项目总览1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-35ff9103000752d7.GIF?imageMogr2/auto-orient/strip" alt="项目总览2.GIF"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>有一句话说:过早的优化是万恶之源, 过早并不是开发过程的早期，而是在还没弄清楚业务需求的情形下去做所谓的优化,有时候会适得其反——费时、费力、不讨好。正确的方法是，先有质量地实现你的需求，写够测试用例，然后做profile去找到性能的瓶颈，考虑究竟哪些地方应该优化，应该如何优化，哪些不应该优化.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-0e7f39942a7a6c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章结构.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者对一些显示的垂直信号,水平信号原理不是了解,大家如果想深入了解的可以查一下相关资料,相关大神也有总结,或许从硬件底层优化可能效果会更好.造成tableView卡顿的原因,从硬件上来说无非就两个,一个是CPU原因,一个是GPU原因.如果CPU核数较多,并发处理问题的能力也就越强,处理大量计算也不在话下;如果GPU显存够大,渲染能力足够强,处理复杂图形界面也就得心应手.但是,硬件的配置是有限度的,我们的目标是在有限度的硬件上,让其发挥最大限度的作用.这个也就是造成tableView卡顿的程序原因(软件原因)–卡住了主线程,本文将主要讨论是从程序角度讨论怎么优化tableView问题.</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最基本的就是减少cell的自定义类型,重用cell,每次只绘制屏幕显示cell的数量,其它cell从缓存中取.这些基础大家应该比我了解,这里不再陈述了.</p><h2 id="1-减轻CPU负荷"><a href="#1-减轻CPU负荷" class="headerlink" title="1. 减轻CPU负荷"></a>1. 减轻CPU负荷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道CPU的主要负责快速调度任务,大量计算工作,所以在tableView快速滚动的过程中让CPU的计算量降低是优化应该考虑的方向.下面总结了三个方面来尽可能的降低CPU计算:</p><h3 id="1-1提前计算好cell的高度-缓存在相应的数据源模型中"><a href="#1-1提前计算好cell的高度-缓存在相应的数据源模型中" class="headerlink" title="1.1提前计算好cell的高度,缓存在相应的数据源模型中"></a>1.1提前计算好cell的高度,缓存在相应的数据源模型中</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都已经知道tableView的代理回调方法中,先调用的是返回cell高度的方法,然后在返回实例化cell的方法.我们可以在返回cell高度时,提前计算好cell的高度,缓存到数据源模型中.例如:<em>MTTHomeModel</em>对应的是首页cell的数据模型,我们可以看到下面两个变量,是来存储cell的高度和内容高度的,:</p><pre><code>var cellHeight:CGFloat?var contentHeight:CGFloat?</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获取数据后台数据的时候,把cell高度计算出来,缓存起来:</p><pre><code>homeModel.contentHeight  = self.calculateTextHeight(text: homeModel.contentTextString!) + 150if(homeModel.retwitterType?.count)! &gt; Int(0){    homeModel.cellHeight = 255 + homeModel.contentHeight! - 150} else{    homeModel.cellHeight = 230 + homeModel.contentHeight! - 150 + 15}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在返回cell高度的方法中,直接读取缓存的高度,而不需要在重新计算了.</p><pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat    {        if self.homeDataArray != nil        {            let homeModel = homeDataArray![indexPath.row]            return homeModel.cellHeight!        } else        {            return 300        }    }</code></pre><h3 id="1-2-尽可能的降低storyboard-xib等使用度"><a href="#1-2-尽可能的降低storyboard-xib等使用度" class="headerlink" title="1.2 尽可能的降低storyboard,xib等使用度"></a>1.2 尽可能的降低storyboard,xib等使用度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前看到一些大家分享的相关资料,通过Interface知道xib或者storyboard本身就是一个xml文件,添加删除控件必然中间多了一个encode/decode过程,增加了cpu的计算量.并且 还要避免臃肿的 XIB 文件,因为XIB文件在主线程中进行加载布局.当用到一些自定义View或者XIB文件时,XIB的加载会把所有内容加载进来,如果XIB里面的一些控件并不会用到,这就可能造成一些资源的消耗浪费.网上有说:Storyboard 没这个问题,只会按需加载,这个作者还没有去考证.</p><h3 id="1-3-滑动过程中尽量减少重新布局"><a href="#1-3-滑动过程中尽量减少重新布局" class="headerlink" title="1.3 滑动过程中尽量减少重新布局"></a>1.3 滑动过程中尽量减少重新布局</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局就是给控件添加约束,约束最终还是转换成frame.所以,在满足业务需求情况下,如果图层层次较为复杂,要尽量减少自动布局约束,转为手动计算布局,大量的约束重叠也会增加cpu的计算量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者在获取到数据源时,每次都重新布局控件,这个也是一个重要开销,也是接下来需要优化的方向.</p><pre><code>private funclayoutSubview(homeModel:MTTHomeModel) -&gt; Void{       topLineView?.snp.makeConstraints({ (make) in           make.left.right.top.equalTo(0)           make.height.equalTo(0.3)       })}</code></pre><h2 id="2-不要阻塞主线程"><a href="#2-不要阻塞主线程" class="headerlink" title="2. 不要阻塞主线程"></a>2. 不要阻塞主线程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>UIKit的工作基本上都是在主线程上进行,界面绘制,用户输入响应等等.当所有的代码逻辑都放在主线程时,某些耗时任务可能会卡住主线程造成程序无法响应,流畅度降低等问题;在主线程中绘制大量界面图层,网络I/O,磁盘I/O等都可以造成界面卡顿现象.</strong></p><p>下面我们通过Xcode自带的调试工具Instruments来看看项目界面的流畅度,及其一些建议,Instruments给我提供了各种各样的调试查看工具,下面简单介绍一下:<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)Blank: 创建一个空的模板,可以从Library库中添加其他模板.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Activity Monitor: 监控进程级别的CPU,内存,磁盘,网络使用情况,可以得到你的应用程序在手机运行时总共占用的内存大小.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)Allocations: 跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史,可以检测每一个堆对象的分配内存情况.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Cocoa Layout : 观察NSLayoutConstraint对象的改变,帮助我们判断什么时间什么地点的constraint是否合理.观察约束变化,找出布局代码的问题所在.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5)Core Animation: 这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6)CoreData: 这个模块跟踪Core Data文件系统活动.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7)Counters : 收集使用时间或基于事件的抽样方法的性能监控计数器(PMC)事件.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8)Energy Log: 耗电量监控.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9)File Activity: 检测文件创建,移动,变化,删除等.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10)Leak: 一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11)Metal System Trace: Metal API是apple 2014年在ios平台上推出的高效底层的3D图形API,它通过减少驱动层的API调用CPU的消耗提高渲染效率.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12)Network: 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13)SceneKit: 3D性能状况分析.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14)System Trace: 系统跟踪,通过显示当前被调度线程提供综合的系统表现,显示从用户到系统的转换代码通过两个系统调用或内存操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15)System Usage: 这个模板记录关于文件读写,sockets,I/O系统活动,输入输出.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16)Time Profiler(时间探查): 执行对系统的CPU上运行的进程低负载时间为基础采样.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17)Zombies: 测量一般的内存使用,专注于检测过度释放的野指针对象,也提供对象分配统计，以及主动分配的内存地址历史.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要使用的是Instruments中的第5个工具:Core Animation(图形性能),这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们必须要把源码安装到测试设备上,1)连接Xcode运行程序;2)然后选择快捷键(Command + Control + i)调出Instruments,选择Core Animation.打开后我们可以看到Debug Options里面有多个调试选项,下面我们挨个尽量来分析看一下:</p><p>###2.1 Color Blended Layers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示,越红表示性能越差,会对帧率等指标造成较大的影响.红色通常是由于多个半透明图层叠加引起.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者项目可能项目比较简单,图层也不是很复杂,所以通过Color Blended Layers查看,深红色并不是很明显,在快速滑动的过程中,帧率依然能够保持在55+以上,并且图层中也没有大量的深红色区域出现.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-423fc34374dc56a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ColorBlendedLayers1-1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8641c471649c93a1.gif?imageMogr2/auto-orient/strip" alt="ColorBlendedLayers1-2-.gif"></p><p>###2.2 Color Hits Green and Misses Red<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当UIView.layer.shouldRasterize = YES 时,耗时的图片绘制会被缓存,并当做一个简单的扁平图片来呈现.这时候,如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中,就显示绿色,反之,如果不命中,这时就显示红色.红色越多,性能越差.因为栅格化生成缓存的过程是有开销的,如果缓存能被大量命中和有效使用,则总体上会降低开销,反之则意味着要频繁生成新的缓存,这会让性能问题雪上加霜.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-f99e1282e6919417.gif?imageMogr2/auto-orient/strip" alt="ColorHitsGreenandMissesRed2-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里笔者还要提一下图片的加载方式,我们知道图片的一般加载方式有两种:imageNamed 和imageWithContentsOfFile;它们的不同在于前者会对图片进行缓存,而后者只是简单的从文件加载文件.如果你加载的是大图,并且只会用到一次,比如欢迎引导图,那么就没必要缓存这个图片,可以使用[UIImage imageWithContentsOfFile:],用完就释放了.如果会多次使用到一张图时,用[UIImage imageNamed:] 就会高效很多,因为这种加载图片方式有一个缓存机制.YYImage实现原理应该就是后面这种思路,自己手动添加缓存.</p><p>###2.3 Color Copied Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理,把这样的图片标为蓝色.蓝色越多,性能越差.因为,我们不希望在滚动视图的时候,由 CPU 来处理图片,这样可能会对主线程造成阻塞.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-e802ac2215033c3f.gif?imageMogr2/auto-orient/strip" alt="ColorCopiedImages3-1.gif"></p><p>###2.4 Color Immediately<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说,这显然太慢了.这个选项就可以用来设置每帧都更新(可能会影响到渲染性能,而且会导致帧率测量不准,所以不要一直都设置它).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-d53301f12380ce80.gif?imageMogr2/auto-orient/strip" alt="ColorImmediately4-1.gif"></p><p>###2.5 Color Misaligned Images<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项检查了图片是否被缩放,以及像素是否对齐.被放缩的图片会被标记为黄色,像素不对齐则会标注为紫色.黄色,紫色越多,性能越差.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-7785ce1122d31e88.gif?imageMogr2/auto-orient/strip" alt="ColorMisalignedImages5-1.gif"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里UI在切图的时候尽量切得尺寸和你控件的尺寸保持一致,尽量让图片保持原始尺寸.笔者这里所用图片几乎全部拉伸,由于图片都是从本地加载的,没有经过处理.</p><p>###2.6 Color Offscreen-Rendered Yellow<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把那些离屏渲染的图层显示为黄色.黄色越多,性能越差.这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-cdcbfd43e7b5efa2.gif?imageMogr2/auto-orient/strip" alt="ColorOffscreen-RenderedYellow6-1.gif"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染,即 Off-Screen Rendering.与之相对的是 On-Screen Rendering,即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行.那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离屏渲染需要多次切&gt;换上下文环境:先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);等到离屏渲染结束以后,将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕,而上下文环境的切换是一项高开销的动作.<br>一般对控件属性操作会触发离屏渲染:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)阴影(UIView.layer.shadowOffset/shadowRadius/…)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)圆角(当 UIView.layer.cornerRadius 和UIView.layer.maskToBounds 一起使用时)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)图层蒙板<br>在实际开发中应尽量避免触发离屏渲染.</p></blockquote><p>###2.7 Color OpenGL Fast Path Blue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项会把任何直接使用OpenGL 绘制的图层显示为蓝色.蓝色越多,性能越好.如果仅仅使用 UIKit 或者 Core Animation 的 API,那么不会有任何效果.如果使用 GLKView 或者 CAEAGLLayer,那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理,而不是绘制到屏幕.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>任何优化都是以业务需求为前提,在满足基本需求的情况下,逐步提高代码的质量,提升程序性能,不仅是自我能力的表现,也能从中获得一些收获及成就感.以上优化方向思路也是在前人总结的基础上,作者在自己的项目中的简单应用,里面还有许许多多需要改进提升的地方,也希望大家能给一些深层次上的建议意见.</strong></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><strong><em><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能调优之--内存管理</title>
      <link href="/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/04/07/iOS%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS内存管理无论是早期的MRC还是现在的ARC本质都是通过引用计数(Reference Counting)机制管理内存,当一个对象被创建出来时,它的引用计数从0到1,当有外部对象对它进行强引用时,它的应用计数会+1,当该对象收到一条release消息时,它的引用计数会-1;当对象的引用计数为0时,对象将被释放,对象指向的内存被回收.</p><h2 id="1-ARC内存管理的本质"><a href="#1-ARC内存管理的本质" class="headerlink" title="1. ARC内存管理的本质"></a>1. ARC内存管理的本质</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MRC时代需要程序员手动管理对象的生命周期,也就是对象的引用计数有程序员来控制,什么时候retain,什么时候release,完全自己掌握.ARC(Automatic Reference Counting)自动引用计数是编译器的一个特性,能够自动管理OC对象内存生命周期.在ARC中你需要专注于写你的代码, retain ,release, autorelease操作交给编译器去处理就行了.</strong><br><img src="https://upload-images.jianshu.io/upload_images/1715253-27c80639ff2b00b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MRC_ARC_示意图_来源_Apple_Document.jpg"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC 下编译器如何自动管理内存,其中,能想到的是在类的 dealloc 方法中，对该类的所持有的成员变量(strong)执行 release 操作,让所有成员变量的引用计数为0。对于局部变量,更可能是的对象在出作用域之前,编译器自动给对象加上一条 release消息.这些工作都是编译器为我们处理了.</p><pre><code>// 作用域    {        NSString *str = [[NSString alloc]initWithFormat:@&quot;%@&quot;,@&quot;str&quot;];        NSLog(@&quot;%@&quot;,str);        // 在对象出作用域时,编译器自动给对象发一条release消息        [str release];    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARC,则无需我们自己显式持有(retain)和释放(release)对象,ARC通过对对像加上所有权修饰符(__strong等),编译器通过对象的所有权修饰符将会自动管理对象的引用计数.</p><h2 id="2-所有权修饰符"><a href="#2-所有权修饰符" class="headerlink" title="2. 所有权修饰符"></a>2. 所有权修饰符</h2><blockquote><p>基础知识:指针是其实也是一个对象,它指向一个内存地址单元,内存单元里存着各种变量.这样指针就可以指向这样变量,当我们用的时候我们就可以从内存单元取出变量内容.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objective-C对象的ARC是通过所有权修饰符来管理对象的持有和释放。所有权修饰符一共有4种：</p></blockquote><h3 id="2-1-strong-修饰符"><a href="#2-1-strong-修饰符" class="headerlink" title="2.1 __strong 修饰符"></a>2.1 __strong 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认的修饰符,只要有一个强指针指向这个对象,这个对象就一直不会销毁,这个对象指向的指针也不会置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __strong person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:19:09.822168 TestARC[16592:5864784] person_one:(null),person_one地址:0x02018-03-19 16:19:22.443524 TestARC[16592:5864784] person_two:&lt;Person: 0x17001e450&gt;,person_two地址:0x17001e450</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-2902fc1e9aff3193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strong所有权修饰.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到,person_two是person_one的浅拷贝对象,也就是指针拷贝对象,而person_two是通过__strong修饰,相当于强指针,指向的是与person_one一块内存区域.而这块内存区域被retain了两次,引用计数为2,即使person_one = nil将引用计数-1了,person_two依然可以打印出内存地址.person_one的指针已经被置为NULL,所以打印出的地址是0x0.</p><h3 id="2-2-weak-修饰符"><a href="#2-2-weak-修饰符" class="headerlink" title="2.2 __weak 修饰符"></a>2.2 __weak 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当没有强指针指向弱引用的对象时,弱引用的对象将被置为nil,对象的指针置为NULL.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __weak person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:28:21.453255 TestARC[16599:5866487] person_one:(null),person_one地址:0x02018-03-19 16:28:25.521762 TestARC[16599:5866487] person_two:(null),person_two地址:0x0</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-062710f6ab6758cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道__weak修饰的对象不会对对象进行retain,所以person_two指向的内存区域对象引用计数还是1.这里只有person_one强引用那块内存区域,当person_one = nil时,引用计数为0,内存区域被释放,person_two指向的内存地址为:0x0.</p><h3 id="2-3-unsafe-unretained-修饰符"><a href="#2-3-unsafe-unretained-修饰符" class="headerlink" title="2.3 __unsafe_unretained 修饰符"></a>2.3 __unsafe_unretained 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其表面意思一样:当没有强指针指向__unsafe_unretained修饰的对象时,这个对象会被置为nil,但是指向对象的指针不会被清空,苹果官方: the pointer is left dangling.</p><pre><code>//这里person_one 可以理解为一个指针 指向 Person创建的出来的对象(指针)的内存,可以读取内存上的内容    Person * __strong person_one = [[Person alloc]init];    Person * __unsafe_unretained person_two = person_one;    person_one = nil;    NSLog(@&quot;person_one:%@,person_one地址:%p&quot;,person_one,person_one);    NSLog(@&quot;person_two:%@,person_two地址:%p&quot;,person_two,person_two);Log:2018-03-19 16:42:52.400375 TestARC[16608:5869804] person_one:(null),person_one地址:0x0这里已经报错:Thread 1: EXC_BAD_ACCESS (code=1, address=0xb84d2beb8)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1715253-5666a219c62ae22c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unsafe__unretained所有权修饰.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在主线程中收到一条崩溃信息(EXC_BAD_ACCESS),通过<strong>unsafe_unretained官方文档解释,我们可以猜出address=0xb84d2beb8应该是person_one没被置为nil之前的内存地址,而当person_one = nil时,这块内存已经被回收,而person_two因为被</strong>unsafe_unretained修饰,其指针还没有被销毁,还想指向这块内存地址,所以造成了野指针错误.</p><h3 id="2-4-autoreleasing-修饰符"><a href="#2-4-autoreleasing-修饰符" class="headerlink" title="2.4 __autoreleasing 修饰符"></a>2.4 __autoreleasing 修饰符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorelease 本质上就是延迟调用 release,这里不做细致的分析了,大家感兴趣的可以自己找相关资料查看.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里我们对ARC的引用计数管理应该有了大概的了解.</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用计数的实现,我们可以通过查看苹果的源码(<a href="https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/).我们下面主要来看看retain的实现源码,我们可以在OC的鼻祖类--NSObject中可以看到协议NSObject中定义的几个方法</a>:</p><pre><code>- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上方法,就是编译器在合适的时机给对象所要发送的消息.我们点进去retain方法,我们可以在NSObject.mm文件的2138行可以看到其实现:</p><pre><code>// Replaced by ObjectAlloc- (id)retain {    return ((id)self)-&gt;rootRetain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;沿着调用链,我们可以在objc-object.h文件中看到id rootRetain(bool tryRetain, bool handleOverflow)方法的实现:</p><pre><code>LWAYS_INLINE idobjc_object::rootRetain(bool tryRetain, bool handleOverflow){    assert(!UseGC);    if (isTaggedPointer()) return (id)this;    bool sideTableLocked = false;    bool transcribeToSideTable = false;    isa_t oldisa;    isa_t newisa;    do {        transcribeToSideTable = false;        oldisa = LoadExclusive(&amp;isa.bits);        newisa = oldisa;        if (!newisa.indexed) goto unindexed;        // don&#39;t check newisa.fast_rr; we already called any RR overrides        if (tryRetain &amp;&amp; newisa.deallocating) goto tryfail;        uintptr_t carry;        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++        if (carry) {            // newisa.extra_rc++ overflowed            if (!handleOverflow) return rootRetain_overflow(tryRetain);            // Leave half of the retain counts inline and            // prepare to copy the other half to the side table.            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();            sideTableLocked = true;            transcribeToSideTable = true;            newisa.extra_rc = RC_HALF;            newisa.has_sidetable_rc = true;        }    } while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));    if (transcribeToSideTable) {        // Copy the other half of the retain counts to the side table.        sidetable_addExtraRC_nolock(RC_HALF);    }    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return (id)this; tryfail:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    return nil; unindexed:    if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();    if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;    else return sidetable_retain();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行sidetable_retain(),这个也是retain方法的最终调用的方法.而sidetable_retain()的实现:</p><pre><code>idobjc_object::sidetable_retain(){#if SUPPORT_NONPOINTER_ISA    assert(!isa.indexed);#endif    SideTable&amp; table = SideTables()[this];    if (table.trylock()) {        size_t&amp; refcntStorage = table.refcnts[this];        if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {            refcntStorage += SIDE_TABLE_RC_ONE;        }        table.unlock();        return (id)this;    }    return sidetable_retain_slow(table);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到这个方法中SideTable这个结构体,</p><pre><code>struct SideTable {    spinlock_t slock;    RefcountMap refcnts;    weak_table_t weak_table;    SideTable() {        memset(&amp;weak_table, 0, sizeof(weak_table));    }    ~SideTable() {        _objc_fatal(&quot;Do not delete SideTable.&quot;);    }    void lock() { slock.lock(); }    void unlock() { slock.unlock(); }    bool trylock() { return slock.trylock(); }    // Address-ordered lock discipline for a pair of side tables.    template&lt;bool HaveOld, bool HaveNew&gt;    static void lockTwo(SideTable *lock1, SideTable *lock2);    template&lt;bool HaveOld, bool HaveNew&gt;    static void unlockTwo(SideTable *lock1, SideTable *lock2);};</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 RefcountMap 应该就是引用计数哈希表，而weak_table_t则是弱引用表(weak table).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefcountMap 则是一个简单的 map,其 key 为 object 内存地址，value 为引用计数值.通过SideTable源码，还可以得出如下结论：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在全局的若干个SideTable实例，它们保存在 static 成员变量table_buf中；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序运行过程中生成的所有对象都会通过其内存地址映射到table_buf中相应的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SideTable实例上.这里之所以会存在多个SideTable实例,object 映射到不同SideTable实例上,猜测是出于性能优化的目的，避免SideTable中的 reference table、weak table 过大.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到上面的sidetable_retain方法，其首先通过 object 的地址找到对应的 sidetale，然后通过 RefcountMap将该 object 的引用计数加1.简单地说，Apple 通过全局的 map 来记录Reference Counting，其key 为 object 地址，value 为引用计数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release、retainCount等相关方法的代码在该开源代码中也能找到,这里不细说了.</p><h2 id="4-ARC开发环境需要注意的管理内存"><a href="#4-ARC开发环境需要注意的管理内存" class="headerlink" title="4. ARC开发环境需要注意的管理内存:"></a>4. ARC开发环境需要注意的管理内存:</h2><h3 id="4-1CoreFoundation-Runtime以及其他C语言库的使用"><a href="#4-1CoreFoundation-Runtime以及其他C语言库的使用" class="headerlink" title="4.1CoreFoundation,Runtime以及其他C语言库的使用"></a>4.1CoreFoundation,Runtime以及其他C语言库的使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过malloc,create,copy等创建对象,还需要手动释放.</p><h3 id="4-2-循环引用"><a href="#4-2-循环引用" class="headerlink" title="4.2 循环引用"></a>4.2 循环引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环引用是两个或多个对象之间相互持有,形成环状,即使在没有外部对象指针指向这些对象内存区域(堆区)的时候,系统无法将每个对象的引用计数置为0,从而导致这些开辟出来的内存一直发挥着”占着茅坑不拉屎”的作用.这部分不容易检测,也容易背锅.不管新老司机遇到问题不假思索:循环引用的问题(所以遇到问题的时候,我们更多的是多思考,而不是在没有分析问题的情况下脱口而出,不仅误导别人,而且显得自己很水,多说了两句,见笑).<br><img src="https://upload-images.jianshu.io/upload_images/1715253-674749fa15d20829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环引用示意图.png"></p><h2 id="5-内存管理检测"><a href="#5-内存管理检测" class="headerlink" title="5. 内存管理检测"></a>5. 内存管理检测</h2><h3 id="5-1-Analyze静态分析"><a href="#5-1-Analyze静态分析" class="headerlink" title="5.1 Analyze静态分析"></a>5.1 Analyze静态分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态内存分析, 指的是在程序没运行的时候, 通过预编译对代码进行预判断分析,分析代码的基本数据结构,语法等,编译器检查是否存在潜在的内存泄露及不规范的地方.常遇到问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)The ‘viewWillDisappear:’ instance method in UIViewController subclass ‘xxxxx’ is missing a [super viewWillDisappear:] call;这个错误提示是:重写父类中的实例方法viewWillDisappear,没有在子类中调用,从下图我们可以看到确实是这样,-(void)viewWillDisappear:(BOOL)animated方法内部调用的是[super viewDidAppear:animated];这种是很低级的错误.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-85ff5e032f373642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)Value stored to ‘xxxxx’ is never read,声明的变量没有被用到<br><img src="https://upload-images.jianshu.io/upload_images/1715253-b74144bbc8d2352c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) API Misuse 接口应用错误,这里主要针对的是系统提供的接口<br>从下图中我们可以看到,_cachedStatements是一个字典,字典是不允许出现nil对象的,所以存数据之前我们要做容错判断.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-29cf84141853dc67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_1.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改完后就不再提示了<br><img src="https://upload-images.jianshu.io/upload_images/1715253-aa89d613c271f245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_3_2.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)Memory error,内存错误:nil returned from a method that is expected to return a non-null value,方法返回中需要一个对象(指针),你返回了一个空指针.例如,下图在UITableView的数据源回调方法返回cell的方法中,本应返回一个UITableViewCell对象,可是这里返回了一个nil对象(空指针)<br><img src="https://upload-images.jianshu.io/upload_images/1715253-00e5d7fd34a88fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Analyze_4.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还存在其他潜在问题错误或者不规范的地方,大家可以照着这个自己去查找一下自己的项目.</p><h3 id="5-2-Instruments内存泄露检测"><a href="#5-2-Instruments内存泄露检测" class="headerlink" title="5.2 Instruments内存泄露检测"></a>5.2 Instruments内存泄露检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruments内存分析你应用内存的使用情况,帮助你查找定位出现问题的代码区域.详细介绍可以参考apple developer documentation(<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1</a>)<br>从文档中我们大概可以看到,一个应用所使用的内存可能占三种:</p><blockquote><p>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).<br>泄露的内存:应用无法再次应用或者释放的内存.<br>Abandoned memory: Memory still referenced by your application that has no useful purpose.<br>废弃的内存:你的应用还占据着这块内存,但是这块内存无法释放了,ARC中最有可能的是循环引用.<br>Cached memory: Memory still referenced by your application that might be used again for better performance.<br>缓存的内存:能够被你的应用正常释放回收利用的内存.<br>内存泄露：如果程序运行时一直分配内存而不及时释放无用的内存，程序占用的内存越来越大，直到把系统分配给该APP的内存消耗殚尽，程序因无内存可用导致崩溃，这样的情况我们称之为内存泄漏。可能引起的问题:<br>1)内存消耗殆尽的时候，程序会因没有内存被杀死，即crash。<br>2)当内存快要用完的时候，会非常的卡顿<br>3)如果是ViewController没有释放掉，引起的内存泄露，还会引起其他很多问题，尤其是和通知相关的。没有被释放掉的ViewController还能接收通知，还会执行相关的动作，所以会引起各种各样的异常情况的发生。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以我们现在开发的项目为例:这里打个广告,我们现在开发的应用叫做爱学.横版主要有我的班级,自学,消息,设置等模块,下面我们用Instruments来检查一下:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)打开调试工具步骤:首先先将待检测的源码安装到你的真机设备上(Command + r 或者 直接Run运行);然后按着快捷键:Command + Control + i,打开Instruments,选择Leaks.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)定位内存泄露区域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们选择call_tree,也就是函数调用栈,顺藤摸瓜,找到内存泄露的地方<br><img src="https://upload-images.jianshu.io/upload_images/1715253-35a0756984c09923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="call_tree.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-8dd8d2a4259d6606.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="memory_leak.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不出意外,就可以看到具体内存泄露的代码了,我们这里是由于使用Runtime了,调用了class_copyPropertyList方法.我们知道Runtime是OC的底层,是OC的幕后工作者,所写的OC代码最终都转换成Runtime的C代码执行.这里通过class_copyPropertyList方法来获取类的所有成员变量的时候,没有释放.所以在使用C语言相关库的时候,一定要做好释放工作(不然装B就装大了😄,玩笑).最终在使用遍历完类中的成员变量后,free(properties);就没问题了.</p><pre><code>-(NSArray *)modelInfo:(Class)cls{    unsigned int  count = 0;    objc_property_t  * properties= class_copyPropertyList(cls, &amp;count);    NSMutableArray  * infoarr = [NSMutableArray new];    for (int i = 0; i&lt;count; i++)    {        objc_property_t property = properties[i];        NSString * name = [[NSString alloc]initWithCString:property_getName(property) encoding:NSUTF8StringEncoding ];        [infoarr addObject:name];    }    free(properties);    return infoarr;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的学习任务中一个视频类型的任务,视频播放器估计是从网上找的别人封装好的,没有细致分析就用了.从下图中我们可以看到至少有三个环,我们需要打破这种环状,消除引用循环,这里不细说,大家可以根据需要去详细看看怎么处理引用循环.<br><img src="https://upload-images.jianshu.io/upload_images/1715253-96a1e31299fb670a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_1.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-bb436103f2dc0783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_2.png"><br><img src="https://upload-images.jianshu.io/upload_images/1715253-15920f2bec2bed6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retain_recycle_3.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中简单介绍了iOS内存管理的相关内容,主要的还是ARC相关内容,这些大都是基于实际开发中的总结和平时学习的积累,里面不乏一些错误和不规范之处,希望没有没有大家没有被误导,更希望大家多给意见和建议.其实,基础知识扎牢了,对一些问题的理解,解决可能也会更加游刃有余,而不是天天纠结于一些”界面”上的问题.</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">https://blog.devtang.com/2016/07/30/ios-memory-management/</a><br><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS持续集成构建</title>
      <link href="/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/04/07/iOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前市面上持续集成的方案很多:例如,<strong>Jenkins, Fastlane,Xcode server</strong>等,这些持续集成的方案大同小异,他们之间的性能差异笔者没有做大量的横向分析,只是大体比较了一下打包时间.总结来说,持续集成主要是三个步骤:1.拉取代码;2.编译打包;3.分发数据(打包结果),下面将通过两种方案(Jenkins和Xcode server)来分析一下这三个过程.</p><h1 id="Jenkins集成方案"><a href="#Jenkins集成方案" class="headerlink" title="Jenkins集成方案"></a>Jenkins集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins作为免费集成方案,其社区拥有大量插件,非常友好,所以用户也众多.<br>首先来安装Jenkins,Jenkins官网提供了多个系统环境的软件包,我选择的是macOs系统,选择下载安装,步骤如下图:</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-74793443eb9d2e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Jenkins.png"></p><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-3767d8e62b58ab6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装Jenkins.png"></p><h3 id="设置管理员账号密码"><a href="#设置管理员账号密码" class="headerlink" title="设置管理员账号密码"></a>设置管理员账号密码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后,一般mac环境集成了Apache服务器会自动配置启动8080端口,Jenkins的初始化页面也会在安装完成后自动弹出.此时只要找到图中红色标记路径cat或者vi看一下里面的秘钥,进入Jenkins初始化设置工作.这个过程会设置管理员账号密码等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-d1d90f913140c3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取初始密码Jenkins.png"></p><h3 id="Jenkins插件安装"><a href="#Jenkins插件安装" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化完成后,就可以利用管理员账号登录.登录后通常可以安装一些常用插件,一般有默认插件和自定义插件,选择默认插件即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4568ef21195c5c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins安装插件.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的环境搭建完成后,就可以实施上面的三个过程了.其实Jenkins的主要工作流程,可以通过下图来直观看出来.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-355b1d4d4cfc90bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins工作流程.png"></p><h2 id="步骤1-拉取代码"><a href="#步骤1-拉取代码" class="headerlink" title="步骤1 拉取代码"></a>步骤1 拉取代码</h2><p><img src="http://upload-images.jianshu.io/upload_images/1715253-fadcbca7317ace47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git仓库分支配置.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉取代码过程比较简单,主要是从指定仓库中克隆代码到Jenkins的工作目录.</p><h2 id="步骤2-编译打包"><a href="#步骤2-编译打包" class="headerlink" title="步骤2 编译打包"></a>步骤2 编译打包</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译打包命令主要有xcodebuild,xcrun,xctool(facebook)等,前两个是官方的,后一个是Facebook出品,xctool里面集成了个性化定制,需要的可以细研究一下,文中只是对xcodebuild做出使用分析.<br>xcodebuild编译过程也主要分三个过程:</p><pre><code>- clean    xcodebuild -workspace MyWorkspace.xcworkspace -scheme SchemeName- archive     xcodebuild archive -workspace MyWorkspace.xcworkspace -scheme SchemeName- export ipa     xcodebuild -exportArchive -archivePath MyMobileApp.xcarchive -exportPath ExportDestination.ipa -exportOptionsPlist &#39;exportPlist.plist&#39;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里多说两句:由于IDE变化,导致编辑脚本稍微有一些出入,主要是在编译的第三步(- export ipa),这步Xcode 8.0需要指定描述文件,Xcode 9.0需要指定exportOptionsPlist(这个是主要包含一些证书, ipa模式等键值表).下面贴出打包执行脚本的全部命令(Xcode 9.0):</strong></p><pre><code>export ETT_APP_NAME=app名称export ETT_WORKSPACE_NAME=工作区名称export ETT_SCHEME=scheme名称export ETT_PROVISIONING_PROFILE=描述文件(Xcode9.0用不到)export ETT_BUILD_TYPE=编译类型(用于区分发布还是AdHoc模式,可以忽略)export ETT_CONFIGURATION=编译配置(主要根据自己的多环境进行配置,比如Release,Debug等)###############################################################################################################export ETT_JENKINS_TIME=$(date +%m%d)export ETT_GIT_COMMIT=${GIT_COMMIT:0:7}export ETT_GIT_REV=`git rev-list HEAD | wc -l | awk &#39;{print $1}&#39;`export ETT_VERSION_PRO=`/usr/bin/agvtool mvers -terse1`export ETT_VERSION_NUMBER=$ETT_VERSION_PRO$ETT_BUILD_TYPEexport ETT_BUILD_VERSION=$ETT_GIT_REV.$BUILD_NUMBERexport ETT_BUILD_ID=$ETT_VERSION_NUMBER-$ETT_JENKINS_TIME-$ETT_GIT_REV-$BUILD_NUMBER-G$ETT_GIT_COMMITexport NEXUS_JENKINS_NAME=打包后上传账号export NEXUS_JENKINS_PASSWD=密码export ExportOptionsPlistPath=/Users/用户/Downloads/zhengshu/ExportOptions.plistexport XCODE=/usr/binexport ETT_DIST_ROOT_PATH=工作区路径export ETT_DIST_PATH=$ETT_DIST_ROOT_PATH/$BUILD_NUMBERexport ETT_ARCHIVE_PATH=$ETT_DIST_PATH/$ETT_APP_NAME.xcarchiveexport ETT_WORK_SPACE=$WORKSPACE/$ETT_WORKSPACE_NAME.xcworkspaceexport ETT_FILE_NAME=$ETT_APP_NAME-$ETT_BUILD_IDexport ETT_IPA_NAME=$ETT_FILE_NAME.ipaexport ETT_EXPORT_PATH=$ETT_DIST_PATH/$ETT_IPA_NAMEexport ETT_PACKAGE_NAME=$ETT_FILE_NAME.tar.gzexport ETT_PACKAGE_PATH=$ETT_DIST_PATH/$ETT_PACKAGE_NAMEexport ETT_NEXUS_FILE_NAME=$ETT_APP_NAME-$ETT_JENKINS_TIME-$BUILD_NUMBER-$ETT_GIT_COMMIT.tar.gzexport ETT_UPLOAD_DSYM_SRC=$ETT_WORKSPACE_NAME.app.dSYMexport ETT_UPLOAD_DSYM_FILE=$ETT_FILE_NAME-dSYM.zipexport ETT_UPLOAD_DSYM_PATH=$ETT_DIST_PATH/$ETT_UPLOAD_DSYM_FILEif [ ! -d &quot;$ETT_DIST_ROOT_PATH&quot; ]; then  mkdir $ETT_DIST_ROOT_PATHfiif [ ! -d &quot;$ETT_DIST_PATH&quot; ]; then  mkdir $ETT_DIST_PATHfi#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1/usr/bin/agvtool new-marketing-version $ETT_VERSION_PRO/usr/bin/agvtool new-version -all $ETT_VERSION_PRO.$ETT_BUILD_VERSION#/usr/bin/agvtool vers -terse#/usr/bin/agvtool mvers -terse1$XCODE/xcodebuild clean build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; archive -archivePath &quot;$ETT_ARCHIVE_PATH&quot; -workspace $ETT_WORK_SPACE -destination generic/platform=iOS -scheme $ETT_SCHEME -configuration &quot;$ETT_CONFIGURATION&quot; BUILD_NUMBER=&quot;$ETT_BUILD_ID&quot; CONFIGURATION_BUILD_DIR=$ETT_DIST_PATH UPLOAD_dSYM_FILE=$ETT_UPLOAD_DSYM_FILE$XCODE/xcodebuild -exportArchive -archivePath $ETT_ARCHIVE_PATH -exportPath $ETT_EXPORT_PATH -exportOptionsPlist $ExportOptionsPlistPath -allowProvisioningUpdates</code></pre><h2 id="步骤3-分发数据-发布打包"><a href="#步骤3-分发数据-发布打包" class="headerlink" title="步骤3 分发数据(发布打包)"></a>步骤3 分发数据(发布打包)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程可以直接发布,也可以上传到自己指定的服务器,第三方托管服务器等.我们直接在执行打包脚本的最后面,将打包处理的ipa文件以及符号化文件打包后直接上传到指定服务器:</p><pre><code>cd $ETT_DIST_PATHzip -r $ETT_UPLOAD_DSYM_PATH $ETT_UPLOAD_DSYM_SRCtar -C $ETT_DIST_PATH -zcvf  $ETT_PACKAGE_PATH $ETT_IPA_NAME $ETT_UPLOAD_DSYM_FILEcurl -v -u $NEXUS_JENKINS_NAME:$NEXUS_JENKINS_PASSWD --upload-file $ETT_PACKAGE_PATH  服务器路径$ETT_APP_NAME/ios/$ETT_VERSION_PRO$ETT_BUILD_TYPE/$ETT_NEXUS_FILE_NAME</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>到这里,Jenkins的简单集成过程算完成了,里面涉及到一些环境变量和参数的设置,笔者因为还涉及到Swift和OC混合打包,问题稍多一点.因为业务需求不一样,需要自己去单独设置,有疑问的地方可以一起沟通一下.</strong></p><h1 id="Xcode-Server集成方案"><a href="#Xcode-Server集成方案" class="headerlink" title="Xcode Server集成方案"></a>Xcode Server集成方案</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案,将会把上面三个过程穿插进去,不在单列出来.网上有其他方案是macOS Server + Xcode Server集成方案,本文只是简单介绍一下通过Xcode Server集成</p><h3 id="打开Xcode-Server"><a href="#打开Xcode-Server" class="headerlink" title="打开Xcode Server"></a>打开Xcode Server</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-4cd4f93cfe501b21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Xcode Server.png"></p><h3 id="配置Xcode-Server管理员账号"><a href="#配置Xcode-Server管理员账号" class="headerlink" title="配置Xcode Server管理员账号"></a>配置Xcode Server管理员账号</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-6753a803a134b39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Xcode Server管理员账号.png"></p><h3 id="创建Bot-值守机器人"><a href="#创建Bot-值守机器人" class="headerlink" title="创建Bot(值守机器人)"></a>创建Bot(值守机器人)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置完成后,然后通过Xcode-&gt;Product-&gt;Create Bot<img src="http://upload-images.jianshu.io/upload_images/1715253-53baf11c43225437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建值守机器人.png"></p><h3 id="配置仓库分支"><a href="#配置仓库分支" class="headerlink" title="配置仓库分支"></a>配置仓库分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置代码仓库,Xcode集成了Git所以针对你的项目仓库直接添加分支即可.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-141e6996076bebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置仓库分支.png"></p><h3 id="编译打包参数配置"><a href="#编译打包参数配置" class="headerlink" title="编译打包参数配置"></a>编译打包参数配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分支添加完成后,就可配置编译的一些选项:scheme,ExportOptionsPlist,Configuration等.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-5bacde388ac4ab5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译打包参数配置.png"></p><h3 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-1f389e834485879e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"><br><img src="http://upload-images.jianshu.io/upload_images/1715253-04787e6efa4abd74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建触发器.png"></p><h3 id="添加签名文件"><a href="#添加签名文件" class="headerlink" title="添加签名文件"></a>添加签名文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步添加证书,描述文件等,作者这里选择的是自动签名模式,如果需要可自己指定签名证书,描述文件等,这里不再细说.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-24a9e3f9e9ab7c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加签名文件.png"></p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-bf5c804e22e172cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加环境变量.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步就是添加编译之前和编译打包之后的动作</p><h3 id="添加打包后的脚本命令"><a href="#添加打包后的脚本命令" class="headerlink" title="添加打包后的脚本命令"></a>添加打包后的脚本命令</h3><p><img src="http://upload-images.jianshu.io/upload_images/1715253-200c086c7d6d92ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加打包后的脚本命令.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里你可以把打包结果上传到指定位置,脚本可自行查找.</p><h3 id="集成打包"><a href="#集成打包" class="headerlink" title="集成打包"></a>集成打包</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人创建完成后会自动运行编译打包一次,下次打包可以直接通过点击Integrate触发打包.<br><img src="http://upload-images.jianshu.io/upload_images/1715253-4ffe92eeb5c28e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集成打包.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两种方案,整个过程走下来并不是很复杂.这里提醒一下,由于Jenkins打包通过脚本命令执行编译打包,这个又依赖于一些环境变量和参数,如果一些插件和参数变了,IDE更新了,系统更新了等等原因,这些很容易造成打包失败,笔者经历多次了,一般就是先把命令拿到终端里面编译打包试一下,排除编译命令问题,然后在调试Jenkins环境.总结下来就是遇到问题时不要着急,慢慢分析,一点一点调试,总会解决的.</strong></p><p>最后打个广告:<br>模仿推特客户端(纯Swift开发,develop分支):<br><a href="https://github.com/waitwalker/MyTwitter" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitter</a><br>针对这个客户端简单用Python写了几个接口:<br><a href="https://github.com/waitwalker/MyTwitterAPI" target="_blank" rel="noopener">https://github.com/waitwalker/MyTwitterAPI</a><br>文章地址:<a href="https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉" target="_blank" rel="noopener">https://www.jianshu.com/p/42ed698c57ad,因为一直在写code,文章比较糙,还没来及整理,抱歉</a>!</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
